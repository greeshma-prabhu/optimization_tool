<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daily Orders - Zuidplas Logistics</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/layout.css">
    <style>
        /* CRITICAL: Ensure Sync Now button is always clickable and doesn't trigger date picker */
        #sync-orders-btn,
        #export-orders-btn {
            position: relative;
            z-index: 1000;
            pointer-events: auto !important;
        }
        
        .action-buttons {
            position: relative;
            z-index: 1000;
        }
        
        /* Prevent date input from interfering with button clicks */
        #order-date-picker {
            pointer-events: auto;
        }
        
        /* Make customer names visible and scrollable */
        #orders-table {
            width: 100%;
            table-layout: auto; /* Allow columns to expand */
        }
        
        #orders-table td {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px; /* Prevent super wide columns */
            padding: 8px;
        }
        
        #orders-table td:hover {
            white-space: normal; /* Show full text on hover */
            overflow: visible;
            background: #f0f0f0;
            position: relative;
            z-index: 10;
            max-width: none;
        }
        
        /* Make customer name column wider */
        #orders-table th:nth-child(2),
        #orders-table td:nth-child(2) {
            min-width: 150px;
            max-width: 250px;
        }
        
        /* When button is clicked, ensure date input doesn't get focus */
        #sync-orders-btn:active,
        #export-orders-btn:active {
            z-index: 1001;
        }
    </style>
</head>
<body>
    <!-- Top Header -->
    <header class="top-header">
        <div class="header-left">
            <div class="header-logo">
                <div class="logo-blocks">
                    <div class="logo-block d">D</div>
                    <div class="logo-block flower">
                        <div class="logo-flower-icon"></div>
                    </div>
                    <div class="logo-block z">Z</div>
                </div>
                <div class="logo-text-large">
                    <div class="logo-main-text">DE ZUIDPLAS</div>
                </div>
            </div>
        </div>
        <div class="header-right">
            <div class="user-menu">
                <div class="user-avatar">A</div>
                <span style="font-size: 14px; color: #374151;">Admin User</span>
                <div class="user-badge">Admin</div>
            </div>
            <button class="logout-btn-header" onclick="handleLogout()" data-i18n="common.logout">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                    <polyline points="16 17 21 12 16 7"></polyline>
                    <line x1="21" y1="12" x2="9" y2="12"></line>
                </svg>
                <span>Uitloggen</span>
            </button>
        </div>
    </header>

    <!-- Top Navigation Bar -->
    <nav class="top-nav">
        <div class="nav-items">
            <a href="index.html" class="nav-item" data-page="index">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="7" height="7"></rect>
                    <rect x="14" y="3" width="7" height="7"></rect>
                    <rect x="14" y="14" width="7" height="7"></rect>
                    <rect x="3" y="14" width="7" height="7"></rect>
                </svg>
                <span data-i18n="nav.dashboard">Dashboard</span>
            </a>
            
            <a href="orders.html" class="nav-item active" data-page="orders">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                </svg>
                <span data-i18n="nav.orders">Orders</span>
            </a>
            
            <a href="optimization.html" class="nav-item " data-page="optimization">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polyline>
                </svg>
                <span data-i18n="nav.optimization">Optimization</span>
            </a>
            
            <a href="cart-loading.html" class="nav-item " data-page="cart-loading">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="2" y="7" width="20" height="14" rx="2"></rect>
                    <path d="M16 7V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v2"></path>
                    <line x1="12" y1="12" x2="12" y2="16"></line>
                    <line x1="8" y1="12" x2="8" y2="16"></line>
                    <line x1="16" y1="12" x2="16" y2="16"></line>
                </svg>
                <span data-i18n="nav.cartOptimization">Cart Optimization</span>
            </a>
            
            <a href="trucks.html" class="nav-item " data-page="trucks">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="1" y="3" width="15" height="13"></rect>
                    <polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon>
                    <circle cx="5.5" cy="18.5" r="2.5"></circle>
                    <circle cx="18.5" cy="18.5" r="2.5"></circle>
                </svg>
                <span data-i18n="nav.trucks">Trucks</span>
            </a>
            
            <a href="costs.html" class="nav-item " data-page="costs">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="12" y1="1" x2="12" y2="23"></line>
                    <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>
                </svg>
                <span data-i18n="nav.costs">Costs</span>
            </a>
        </div>
    </nav>

    <!-- Main Content -->
        <div class="header-left">
            <div class="header-logo">
                <div class="logo-blocks">
                    <div class="logo-block d">D</div>
                    <div class="logo-block flower">
                        <div class="logo-flower-icon"></div>
                    </div>
                    <div class="logo-block z">Z</div>
                </div>
                <div class="logo-text-large">
                    <div class="logo-main-text">DE ZUIDPLAS</div>
                </div>
            </div>
        </div>
        <div class="header-right">
            <div class="user-menu">
                <div class="user-avatar">A</div>
                <span style="font-size: 14px; color: #374151;">Admin User</span>
                <div class="user-badge">Admin</div>
            </div>
            <button class="logout-btn-header" onclick="handleLogout()" data-i18n="common.logout">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                    <polyline points="16 17 21 12 16 7"></polyline>
                    <line x1="21" y1="12" x2="9" y2="12"></line>
                </svg>
                <span>Uitloggen</span>
            </button>
        </div>
    </header>

    

    

    

    <!-- Main Content -->
    <main class="main-content" style="margin-left: 0;">
        <div class="page-header">
            <div class="page-header-top">
                <div>
                    <h1 class="page-title" data-i18n="orders.title">Daily Orders</h1>
                    <p class="page-subtitle" id="orders-date">Loading...</p>
                </div>
                <div class="dashboard-controls">
                    <div class="date-picker-wrapper">
                        <label class="date-picker-label" data-i18n="dashboard.selectDate">Select Date</label>
                        <div class="date-input-group">
                            <input type="date" id="order-date-picker" class="date-input" value="" onchange="updateOrdersDate()" tabindex="0" style="pointer-events: auto;">
                            <button type="button" class="btn-icon" onclick="document.getElementById('order-date-picker').focus(); document.getElementById('order-date-picker').showPicker ? document.getElementById('order-date-picker').showPicker() : null;" title="Open calendar">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                    <line x1="16" y1="2" x2="16" y2="6"></line>
                                    <line x1="8" y1="2" x2="8" y2="6"></line>
                                    <line x1="3" y1="10" x2="21" y2="10"></line>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="action-buttons">
                        <button type="button" class="btn btn-primary" id="sync-orders-btn" data-i18n="orders.syncNow" style="padding: 10px 20px;">üîÑ Sync Now</button>
                        <button type="button" class="btn btn-secondary" id="export-orders-btn" data-i18n="orders.exportCSV" style="padding: 10px 20px;">üì• Export CSV</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Filters -->
        <div class="card">
            <h3 data-i18n="orders.filters">Filters</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                <div class="form-group">
                    <label class="form-label" data-i18n="orders.search">Search</label>
                    <input type="text" class="form-select" id="search-input" data-i18n-placeholder="orders.search" placeholder="Search orders..." oninput="searchOrders()">
                </div>
                <div class="form-group">
                    <label class="form-label" data-i18n="orders.route">Route</label>
                    <select class="form-select" id="route-filter" onchange="applyFilters()">
                        <option value="" data-i18n="orders.allRoutes">All Routes</option>
                        <option value="rijnsburg">Rijnsburg</option>
                        <option value="aalsmeer">Aalsmeer</option>
                        <option value="naaldwijk">Naaldwijk</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label" data-i18n="orders.cartType">Cart Type</label>
                    <select class="form-select" id="cart-filter" onchange="applyFilters()">
                        <option value="" data-i18n="orders.allTypes">All Types</option>
                        <option value="standard" data-i18n="cartLoading.standard">Standard</option>
                        <option value="danish" data-i18n="cartLoading.danish">Danish</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label" data-i18n="orders.status">Status</label>
                    <select class="form-select" id="status-filter" onchange="applyFilters()">
                        <option value="" data-i18n="orders.allStatus">All Status</option>
                        <option value="pending" data-i18n="orders.pending">Pending</option>
                        <option value="assigned" data-i18n="orders.assigned">Assigned</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Cart Summary -->
        <div class="stats-grid">
            <div class="stat-card primary">
                <div class="icon">üõí</div>
                <div class="label" data-i18n="orders.standardCarts">Standard Carts</div>
                <div class="value" id="standard-carts-summary">0</div>
            </div>
            <div class="stat-card warning">
                <div class="icon">üå∫</div>
                <div class="label" data-i18n="orders.danishCarts">Danish Carts</div>
                <div class="value" id="danish-carts-summary">0</div>
            </div>
            <div class="stat-card success">
                <div class="icon">‚≠ê</div>
                <div class="label" data-i18n="orders.specialHandling">Special Handling</div>
                <div class="value" id="special-handling-summary">0</div>
            </div>
        </div>

        <!-- Orders Table -->
        <div class="card">
            <h2 data-i18n="orders.ordersTable">Orders Table</h2>
            <div class="table-container">
                <table class="data-table">
                    <thead>
                        <tr>
                            <th data-i18n="orders.orderId">Order ID</th>
                            <th data-i18n="orders.customer">Customer</th>
                            <th>üéØ Assigned Route</th>
                            <th>üïê Departure</th>
                            <th data-i18n="orders.deliveryLocation">Delivery Location</th>
                            <th data-i18n="orders.productType">Product Type</th>
                            <th data-i18n="orders.quantity">Quantity</th>
                            <th data-i18n="orders.crateType">Crate Type</th>
                            <th data-i18n="orders.cartType">Cart Type</th>
                            <th data-i18n="orders.cartsNeeded">Carts Needed</th>
                            <th data-i18n="orders.status">Status</th>
                        </tr>
                    </thead>
                    <tbody id="orders-table-body">
                        <tr>
                            <td colspan="10" style="text-align: center; padding: 40px;" data-i18n="orders.clickToSync">
                                Click "Sync Now" to fetch orders from API
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div id="error-message" class="info-box danger" style="display: none; margin-top: 20px;"></div>
    </div>

    <!-- LANGUAGE SCRIPTS - MUST BE FIRST -->
    <script src="js/i18n.js"></script>
    <script src="js/i18n-init.js"></script>
    
    <!-- GLOBAL STATE MANAGER - CRITICAL FOR DATA SYNC -->
    <script src="js/app-state.js"></script>
    
    <!-- PAGE-SPECIFIC SCRIPTS -->
    <script src="js/data.js"></script>
    <script src="js/auth.js"></script>
    <script src="js/api.js"></script>
    <script src="js/route-mapping.js"></script> <!-- CLIENT-TO-ROUTE MAPPING -->
    <script src="js/cart-calculation.js"></script> <!-- CRITICAL: FUST-based cart calculation -->
    <script src="js/cart-display-manager.js"></script> <!-- Unified cart display -->
    <script src="js/carts.js"></script>
    <script src="js/ordermanager-shim.js"></script>
    <script src="js/orders.js"></script>
    <script src="js/navigation.js"></script>
    <script>
        // Set date - USE SELECTED DATE FROM PICKER
        function updateOrdersDate() {
            const dateEl = document.getElementById('orders-date');
            const datePicker = document.getElementById('order-date-picker');
            if (!dateEl || !datePicker) return;
            
            // Get selected date or default to today
            let selectedDate;
            if (datePicker.value) {
                selectedDate = new Date(datePicker.value);
            } else {
                selectedDate = new Date();
                datePicker.value = selectedDate.toISOString().split('T')[0];
            }
            
            const savedLang = localStorage.getItem('zuidplas_user_language') || localStorage.getItem('zuidplas_language') || 'nl';
            const locale = savedLang === 'nl' ? 'nl-NL' : 'en-US';
            const dateStr = selectedDate.toLocaleDateString(locale, { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
            
            if (typeof i18n !== 'undefined') {
                dateEl.textContent = i18n.t('orders.ordersFor', 'Orders for') + ' ' + dateStr;
            } else {
                dateEl.textContent = 'Orders for ' + dateStr;
            }
        }
        
        // Initialize date picker on page load
        document.addEventListener('DOMContentLoaded', () => {
            const datePicker = document.getElementById('order-date-picker');
            if (datePicker && !datePicker.value) {
                const today = new Date();
                datePicker.value = today.toISOString().split('T')[0];
            }
            updateOrdersDate();
            
            // CRITICAL: Make date input only focusable when clicking directly on it
            if (datePicker) {
                // Prevent date input from getting focus when clicking buttons
                datePicker.addEventListener('focus', function(e) {
                    // Check if focus came from a button click
                    const activeElement = document.activeElement;
                    if (activeElement && activeElement.tagName === 'BUTTON') {
                        e.preventDefault();
                        datePicker.blur();
                        return false;
                    }
                });
                
                // Prevent date input from opening when clicking nearby
                datePicker.addEventListener('mousedown', function(e) {
                    // Only allow if clicking directly on the input
                    if (e.target !== datePicker) {
                        e.stopPropagation();
                    }
                });
            }
            
            // Fix Sync Now button - AGGRESSIVE FIX
            const syncBtn = document.getElementById('sync-orders-btn');
            if (syncBtn) {
                // Remove any existing listeners by cloning
                const newSyncBtn = syncBtn.cloneNode(true);
                syncBtn.parentNode.replaceChild(newSyncBtn, syncBtn);
                const finalSyncBtn = document.getElementById('sync-orders-btn');
                
                // CRITICAL: Handle mousedown to blur date picker but DON'T prevent default
                finalSyncBtn.addEventListener('mousedown', function(e) {
                    // Don't prevent default - we want the click to fire
                    e.stopPropagation();
                    
                    // Immediately blur date picker if it has focus
                    if (datePicker) {
                        datePicker.blur();
                        if (document.activeElement === datePicker) {
                            datePicker.blur();
                        }
                    }
                }, true); // Capture phase
                
                // Handle click to actually sync - THIS IS THE MAIN HANDLER
                finalSyncBtn.addEventListener('click', async function(e) {
                    console.log('üîÑ Sync Now button CLICKED');
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Ensure date picker is NOT focused
                    if (datePicker) {
                        if (document.activeElement === datePicker) {
                            datePicker.blur();
                        }
                        datePicker.blur();
                    }
                    
                    // Call syncOrders function - it's now on window object
                    try {
                        if (typeof window.syncOrders === 'function') {
                            console.log('‚úÖ Calling window.syncOrders() function');
                            await window.syncOrders();
                        } else {
                            console.error('‚ùå syncOrders function not found on window!');
                            console.log('Available window functions:', Object.keys(window).filter(k => k.includes('sync')));
                            alert('Error: syncOrders function not found. Please refresh the page.');
                        }
                    } catch (error) {
                        console.error('‚ùå Error calling syncOrders:', error);
                        alert('Error calling syncOrders: ' + error.message);
                    }
                }, false); // Use bubble phase, not capture
            }
            
            // Fix Export CSV button
            const exportBtn = document.getElementById('export-orders-btn');
            if (exportBtn) {
                // Remove any existing listeners
                const newExportBtn = exportBtn.cloneNode(true);
                exportBtn.parentNode.replaceChild(newExportBtn, exportBtn);
                const finalExportBtn = document.getElementById('export-orders-btn');
                
                finalExportBtn.addEventListener('mousedown', function(e) {
                    // Close date picker immediately on mousedown
                    if (datePicker) {
                        datePicker.blur();
                    }
                }, true);
                
                finalExportBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    // Ensure date picker is closed
                    if (datePicker) {
                        datePicker.blur();
                    }
                    
                    exportOrders();
                    return false;
                }, true); // Use capture phase
            }
        });
        
        // Update date on load (fallback)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', updateOrdersDate);
        } else {
            updateOrdersDate();
        }

        // Orders page - Independent data fetching
        class OrdersPageManager {
            constructor() {
                this.orders = [];
                this.cartResult = null;
                this.currentDate = null;
            }
            
            async syncOrders(date) {
                try {
                    console.log(`üìã Orders page: Syncing data for ${date}...`);
                    
                    // Show loading state
                    const syncBtn = document.getElementById('sync-orders-btn');
                    if (syncBtn) {
                        syncBtn.disabled = true;
                        syncBtn.textContent = '‚è≥ Syncing...';
                    }
                    
                    // Authenticate first
                    if (typeof florinetAPI === 'undefined') {
                        throw new Error('FlorinetAPI not available');
                    }
                    
                    await florinetAPI.authenticate();
                    console.log('‚úÖ Authenticated');
                    
                    // CRITICAL: Use SAME API method as Dashboard
                    // Dashboard uses fetchOrdersForDate() which does enrichment and returns ready-to-use orders
                    console.log(`üì¶ Fetching orders for date: ${date} (using SAME method as Dashboard)...`);
                    const dateObj = new Date(date);
                    const apiOrders = await florinetAPI.fetchOrdersForDate(dateObj);
                    
                    if (!apiOrders || apiOrders.length === 0) {
                        console.warn('‚ö†Ô∏è No orders returned from API');
                        this.orders = [];
                        this.cartResult = null;
                        this.displayOrders();
                        this.updateCartSummary();
                        return;
                    }
                    
                    console.log(`‚úÖ Fetched ${apiOrders.length} orders from API (same method as Dashboard)`);
                    
                    // STEP 1: Filter by actual delivery date (7am-7am window)
                    const filteredByDate = this.filterOrdersByDeliveryDate(apiOrders, date);
                    console.log(`üìÖ Filtered by delivery date: ${apiOrders.length} ‚Üí ${filteredByDate.length} orders`);
                    
                    // STEP 2: Validate orders using SAME validator as Dashboard
                    // This ensures we filter out invalid/test/cancelled/duplicates the SAME way
                    let validatedOrders = filteredByDate;
                    if (window.OrderValidator && typeof window.OrderValidator.validateOrders === 'function') {
                        console.log('üîç Orders page: Validating orders (same as Dashboard)...');
                        const validationResult = window.OrderValidator.validateOrders(filteredByDate);
                        validatedOrders = validationResult.orders;
                        console.log(`‚úÖ Orders page: ${validatedOrders.length} valid orders (filtered from ${filteredByDate.length})`);
                        console.log(`   Dashboard would also filter to ${validatedOrders.length} orders`);
                    } else {
                        console.warn('‚ö†Ô∏è OrderValidator not available - using all orders without validation');
                        // Fallback: Basic validation
                        validatedOrders = this.validateAndCleanOrders(filteredByDate);
                    }
                    
                    // Store validated orders
                    this.orders = validatedOrders;
                    this.currentDate = date;
                    
                    // CRITICAL: Calculate independently using SAME function as Dashboard
                    // Orders page works for ANY date, so it calculates fresh (not from cache)
                    // But uses the EXACT SAME calculation logic as Dashboard
                    if (window.CartCalculation && window.CartCalculation.calculateCarts) {
                        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                        console.log('üßÆ Orders page: Calculating carts using SAME FUST formula as Dashboard');
                        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                        console.log(`   Date: ${date}`);
                        console.log(`   API orders fetched: ${apiOrders.length}`);
                        console.log(`   Validated orders: ${validatedOrders.length}`);
                        console.log(`   üîµ Using calculateCarts() - EXACT SAME function as Dashboard!`);
                        console.log(`   üîµ Using SAME validation - OrderValidator.validateOrders()!`);
                        console.log(`   üîµ Using SAME API method - fetchOrdersForDate()!`);
                        console.log('');
                        
                        // Log sample orders for debugging
                        console.log('üìã Sample orders (first 3, for debugging):');
                        validatedOrders.slice(0, 3).forEach((o, i) => {
                            const customerName = o.customer_name || 'Unknown';
                            const assembly = o.assembly_amount || 0;
                            const locationId = o.delivery_location_id || o.order?.delivery_location_id || 'N/A';
                            console.log(`   ${i + 1}. Customer: "${customerName}", Assembly: ${assembly}, Location ID: ${locationId}`);
                        });
                        console.log('');
                        
                        // Calculate carts using EXACT SAME function
                        this.cartResult = window.CartCalculation.calculateCarts(validatedOrders);
                        
                        // CRITICAL VERIFICATION: Ensure total = standard + danish
                        const calculatedTotal = (this.cartResult.standard || 0) + (this.cartResult.danish || 0);
                        if (Math.abs(this.cartResult.total - calculatedTotal) > 0.01) {
                            console.error('‚ùå‚ùå‚ùå CRITICAL BUG IN calculateCarts()! ‚ùå‚ùå‚ùå');
                            console.error(`   total: ${this.cartResult.total}`);
                            console.error(`   standard: ${this.cartResult.standard}`);
                            console.error(`   danish: ${this.cartResult.danish}`);
                            console.error(`   standard + danish: ${calculatedTotal}`);
                            console.error('   FIXING: Setting total = standard + danish');
                            this.cartResult.total = calculatedTotal;
                            this.cartResult.trucks = Math.ceil(calculatedTotal / 17);
                        }
                        
                        console.log('');
                        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                        console.log(`‚úÖ Orders page calculated: ${this.cartResult.total} carts`);
                        console.log(`   Standard: ${this.cartResult.standard || 0} carts`);
                        console.log(`   Danish: ${this.cartResult.danish || 0} carts`);
                        console.log(`   ‚úÖ VERIFICATION: ${this.cartResult.standard || 0} + ${this.cartResult.danish || 0} = ${this.cartResult.total} ‚úÖ`);
                        console.log(`   Aalsmeer: ${this.cartResult.byRoute.Aalsmeer || 0}`);
                        console.log(`   Naaldwijk: ${this.cartResult.byRoute.Naaldwijk || 0}`);
                        console.log(`   Rijnsburg: ${this.cartResult.byRoute.Rijnsburg || 0}`);
                        console.log(`   Trucks: ${this.cartResult.trucks || 0}`);
                        console.log('');
                        
                        // Compare with Dashboard if same date
                        const dashboardCache = window.__zuidplas_cart_cache;
                        if (dashboardCache && dashboardCache.date === date) {
                            console.log('üîç COMPARING WITH DASHBOARD (same date):');
                            console.log(`   Dashboard: ${dashboardCache.cartResult?.total || 'unknown'} carts`);
                            console.log(`   Orders page: ${this.cartResult.total} carts`);
                            if (dashboardCache.cartResult?.total !== this.cartResult.total) {
                                console.error('‚ùå‚ùå‚ùå MISMATCH DETECTED! ‚ùå‚ùå‚ùå');
                                console.error(`   Dashboard: ${dashboardCache.cartResult?.total} carts`);
                                console.error(`   Orders page: ${this.cartResult.total} carts`);
                                console.error(`   Dashboard orders: ${dashboardCache.ordersCount || 'unknown'}`);
                                console.error(`   Orders page orders: ${validatedOrders.length}`);
                                console.error('   ‚ö†Ô∏è Both should show SAME numbers for same date!');
                            } else {
                                console.log('   ‚úÖ Numbers match!');
                            }
                        } else {
                            console.log('‚ÑπÔ∏è Dashboard cache not found or different date - cannot compare');
                        }
                        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    } else {
                        console.error('‚ùå CartCalculation.calculateCarts() not available!');
                        throw new Error('Cart calculation not available');
                    }
                    
                    // Show unmapped customers summary
                    if (window.RouteMapping && window.RouteMapping.showUnmappedCustomersSummary) {
                        window.RouteMapping.showUnmappedCustomersSummary();
                    }
                    
                    // Clear unmapped customers for next sync
                    if (window.unmappedCustomers) {
                        window.unmappedCustomers.clear();
                    }
                    
                    // Update UI
                    this.displayOrders();
                    this.updateCartSummary();
                    this.displayUnmatchedOrdersSection();
                    
                    // Hide error message if it exists
                    const errorMsg = document.getElementById('error-message');
                    if (errorMsg) {
                        errorMsg.style.display = 'none';
                    }
                    
                    console.log('‚úÖ Sync complete!');
                    
                } catch (error) {
                    console.error('‚ùå Orders page sync failed:', error);
                    showError('Failed to fetch orders: ' + error.message);
                } finally {
                    // Restore button state
                    const syncBtn = document.getElementById('sync-orders-btn');
                    if (syncBtn) {
                        syncBtn.disabled = false;
                        syncBtn.textContent = 'üîÑ Sync Now';
                    }
                }
            }
            
            /**
             * Filter orders by actual delivery date
             * Only show orders where delivery_date matches the selected day
             */
            filterOrdersByDeliveryDate(orderrows, targetDate) {
                // Format target date as DD-MM-YYYY
                const formatDateToDD_MM_YYYY = (dateStr) => {
                    if (!dateStr) return null;
                    const d = new Date(dateStr);
                    if (isNaN(d.getTime())) return null;
                    const day = String(d.getDate()).padStart(2, '0');
                    const month = String(d.getMonth() + 1).padStart(2, '0');
                    const year = d.getFullYear();
                    return `${day}-${month}-${year}`;
                };
                
                const targetDateObj = new Date(targetDate);
                const targetDateStr = formatDateToDD_MM_YYYY(targetDate);
                
                if (!targetDateStr) {
                    console.warn('‚ö†Ô∏è Invalid target date, returning all orders');
                    return orderrows;
                }
                
                const filtered = orderrows.filter(row => {
                    const deliveryDate = row.order?.delivery_date || row.delivery_date;
                    
                    if (!deliveryDate) {
                        // Skip orders without delivery_date
                        return false;
                    }
                    
                    // Extract date from "2026-02-03T14:00:00.000000Z" or "03-02-2026"
                    let orderDateStr = null;
                    if (deliveryDate.includes('T')) {
                        // ISO format: "2026-02-03T14:00:00.000000Z"
                        orderDateStr = formatDateToDD_MM_YYYY(deliveryDate.split('T')[0]);
                    } else {
                        // Already in DD-MM-YYYY format
                        orderDateStr = deliveryDate;
                    }
                    
                    return orderDateStr === targetDateStr;
                });
                
                console.log(`üìÖ Filtered by delivery date (${targetDateStr}): ${orderrows.length} ‚Üí ${filtered.length} orders`);
                return filtered;
            }
            
            /**
             * Validate and clean orders - filter out invalid/duplicate orders
             */
            validateAndCleanOrders(orderrows) {
                const valid = [];
                const seen = new Set();
                
                orderrows.forEach(row => {
                    // Skip if no order data
                    if (!row.order || !row.order.id) {
                        console.warn('‚ö†Ô∏è Skipping orderrow without order data:', row.id);
                        return;
                    }
                    
                    // Skip if state is cancelled/void
                    const state = row.state || row.order?.state || '';
                    if (state === 'Geannuleerd' || state === 'Void' || state === 'Cancelled') {
                        console.warn('‚ö†Ô∏è Skipping cancelled order:', row.id);
                        return;
                    }
                    
                    // Skip if assembly_amount is 0 or missing
                    if (!row.assembly_amount || row.assembly_amount <= 0) {
                        console.warn('‚ö†Ô∏è Skipping zero-quantity order:', row.id);
                        return;
                    }
                    
                    // Skip duplicates (same orderrow ID)
                    if (seen.has(row.id)) {
                        console.warn('‚ö†Ô∏è Skipping duplicate orderrow:', row.id);
                        return;
                    }
                    seen.add(row.id);
                    
                    valid.push(row);
                });
                
                console.log(`‚úÖ Validation: ${orderrows.length} ‚Üí ${valid.length} valid orders`);
                console.log(`   Removed: ${orderrows.length - valid.length} invalid/duplicate orders`);
                
                return valid;
            }
            
            displayOrders() {
                const tableBody = document.getElementById('orders-table-body');
                
                if (!tableBody) {
                    console.error('‚ùå Table body not found');
                    return;
                }
                
                // Clear table
                tableBody.innerHTML = '';
                
                if (this.orders.length === 0) {
                    tableBody.innerHTML = '<tr><td colspan="10" style="text-align: center; padding: 40px;">No orders found for this date</td></tr>';
                    return;
                }
                
                // Route colors for visual distinction
                const routeColors = {
                    'rijnsburg': '#10b981',   // Green
                    'aalsmeer': '#3b82f6',    // Blue
                    'naaldwijk': '#f59e0b'    // Orange
                };
                
                // Add rows
                this.orders.forEach((order, index) => {
                    const row = document.createElement('tr');
                    
                    const orderObj = order.order || {};
                    const fustType = this.extractFustType(order);
                    const customerName = order.customer_name || 'Unknown';
                    
                    // Get route assignment using RouteMapping (same as calculation)
                    let route = 'rijnsburg';
                    let departureTime = '09:00';
                    if (window.RouteMapping && window.RouteMapping.getRouteForCustomer) {
                        route = window.RouteMapping.getRouteForCustomer(customerName);
                        departureTime = window.RouteMapping.getDepartureTime(route);
                    } else {
                        // Fallback to old method
                        route = this.getRoute(order);
                        const routeNames = { 'Aalsmeer': 'aalsmeer', 'Naaldwijk': 'naaldwijk', 'Rijnsburg': 'rijnsburg' };
                        route = routeNames[route] || 'rijnsburg';
                    }
                    
                    const routeColor = routeColors[route] || '#6b7280';
                    const routeDisplay = route.charAt(0).toUpperCase() + route.slice(1);
                    
                    row.innerHTML = `
                        <td>${order.id || orderObj.id || index + 1}</td>
                        <td>${customerName}</td>
                        <td style="background: ${routeColor}; color: white; font-weight: bold; text-align: center; border-radius: 4px; padding: 4px 8px;">
                            ${routeDisplay}
                        </td>
                        <td style="font-weight: bold; text-align: center;">${departureTime}</td>
                        <td>${order.location_name || '-'}</td>
                        <td>${order.product_name || '-'}</td>
                        <td>${order.assembly_amount || 0}</td>
                        <td>${fustType}</td>
                        <td>${this.getCartType(order)}</td>
                        <td>${this.calculateCartsForOrder(order)}</td>
                        <td><span class="status-${order.state || 'pending'}">${order.state || 'Pending'}</span></td>
                    `;
                    
                    tableBody.appendChild(row);
                });
                
                console.log(`‚úÖ Displayed ${this.orders.length} orders in table`);
            }
            
            updateCartSummary() {
                if (!this.cartResult) return;
                
                // CRITICAL: Use standard and danish directly from calculation result
                // calculateCarts() now returns these values directly
                const standardCarts = this.cartResult.standard || 0;
                const danishCarts = this.cartResult.danish || 0;
                const totalCarts = this.cartResult.total || 0;
                
                // Verify: total should equal standard + danish
                const calculatedTotal = standardCarts + danishCarts;
                if (totalCarts !== calculatedTotal) {
                    console.error('‚ùå‚ùå‚ùå CARTS MISMATCH IN ORDERS PAGE! ‚ùå‚ùå‚ùå');
                    console.error(`   total: ${totalCarts}`);
                    console.error(`   standard: ${standardCarts}`);
                    console.error(`   danish: ${danishCarts}`);
                    console.error(`   calculatedTotal: ${calculatedTotal}`);
                    console.error(`   Difference: ${Math.abs(totalCarts - calculatedTotal)}`);
                    console.error('   ‚ö†Ô∏è This should never happen - total should equal standard + danish!');
                }
                
                document.getElementById('standard-carts-summary').textContent = standardCarts;
                document.getElementById('danish-carts-summary').textContent = danishCarts;
                document.getElementById('special-handling-summary').textContent = '0';
                
                // CRITICAL: Verify this matches Dashboard
                this.verifySameCalculation('Orders', this.cartResult);
                
                console.log('‚úÖ Cart summary updated:', {
                    total: totalCarts,
                    standard: standardCarts,
                    danish: danishCarts,
                    verification: `${standardCarts} + ${danishCarts} = ${calculatedTotal} (should equal ${totalCarts})`,
                    routes: this.cartResult.byRoute
                });
            }
            
            verifySameCalculation(pageName, cartData) {
                // Only verify if same date as Dashboard
                const currentDate = this.currentDate || new Date().toISOString().split('T')[0];
                const cacheKey = `cart_verification_${currentDate}`;
                const cached = sessionStorage.getItem(cacheKey);
                
                if (cached) {
                    const cachedData = JSON.parse(cached);
                    // Only compare if same date
                    if (cachedData.date === currentDate) {
                        if (cachedData.total !== cartData.total) {
                            console.error(`‚ùå‚ùå‚ùå CALCULATION MISMATCH FOR SAME DATE! ‚ùå‚ùå‚ùå`);
                            console.error(`  Date: ${currentDate}`);
                            console.error(`  ${cachedData.page}: ${cachedData.total} carts`);
                            console.error(`  ${pageName}: ${cartData.total} carts`);
                            console.error(`  BOTH PAGES MUST SHOW SAME NUMBER FOR SAME DATE!`);
                            console.error(`  Aalsmeer: ${cachedData.page}=${cachedData.byRoute?.Aalsmeer}, ${pageName}=${cartData.byRoute?.Aalsmeer}`);
                            console.error(`  Naaldwijk: ${cachedData.page}=${cachedData.byRoute?.Naaldwijk}, ${pageName}=${cartData.byRoute?.Naaldwijk}`);
                            console.error(`  Rijnsburg: ${cachedData.page}=${cachedData.byRoute?.Rijnsburg}, ${pageName}=${cartData.byRoute?.Rijnsburg}`);
                            console.error(`  ‚ö†Ô∏è Both pages use SAME validation and SAME calculation - why different?`);
                        } else {
                            console.log(`‚úÖ ${pageName} matches ${cachedData.page} for ${currentDate}: ${cartData.total} carts`);
                        }
                    } else {
                        console.log(`‚ÑπÔ∏è ${pageName} date (${currentDate}) differs from ${cachedData.page} date (${cachedData.date}) - no comparison`);
                    }
                } else {
                    // Store this page's result for future comparison
                    sessionStorage.setItem(cacheKey, JSON.stringify({
                        page: pageName,
                        total: cartData.total,
                        date: currentDate,
                        byRoute: cartData.byRoute
                    }));
                    console.log(`üìù ${pageName} result stored for date ${currentDate}: ${cartData.total} carts`);
                }
            }
            
            extractFustType(order) {
                const properties = order.properties || [];
                const fustProp = properties.find(p => p.code === '901');
                return fustProp?.pivot?.value || fustProp?.value || '612';
            }
            
            getCartType(order) {
                const customerName = (order.customer_name || '').toLowerCase();
                if (customerName.includes('superflora') || customerName.includes('flamingo')) {
                    return 'Danish';
                }
                return 'Standard';
            }
            
            calculateCartsForOrder(order) {
                const assemblyAmount = order.assembly_amount || 0;
                const bundlesPerFust = parseInt(order.bundles_per_fust) || 5;
                const fust = assemblyAmount / bundlesPerFust;
                const fustType = this.extractFustType(order);
                const capacity = (window.CartCalculation && window.CartCalculation.FUST_CAPACITY && window.CartCalculation.FUST_CAPACITY[fustType]) || 72;
                return Math.ceil(fust / capacity);
            }
            
            getRoute(order) {
                const locationId = order.delivery_location_id || order.order?.delivery_location_id;
                const routes = { 32: 'Aalsmeer', 34: 'Naaldwijk', 36: 'Rijnsburg' };
                return routes[locationId] || 'Rijnsburg';
            }
        }
        
        // Initialize OrdersPageManager
        const ordersPageManager = new OrdersPageManager();
        
        // Make syncOrders globally accessible
        window.syncOrders = async function syncOrders() {
            const datePicker = document.getElementById('order-date-picker');
            let selectedDate = null;
            
            if (datePicker && datePicker.value) {
                selectedDate = datePicker.value; // YYYY-MM-DD format
            } else {
                // Default to today
                selectedDate = new Date().toISOString().split('T')[0];
                if (datePicker) {
                    datePicker.value = selectedDate;
                }
            }
            
            await ordersPageManager.syncOrders(selectedDate);
        };

        // Apply filters
        function applyFilters() {
            const filters = {
                route: document.getElementById('route-filter').value,
                cartType: document.getElementById('cart-filter').value,
                status: document.getElementById('status-filter').value
            };
            orderManager.filterOrders(filters);
            updateSummary();
        }

        // Search orders
        function searchOrders() {
            const query = document.getElementById('search-input').value;
            orderManager.searchOrders(query);
            updateSummary();
        }

        // Update summary - uses OrdersPageManager's cart result
        function updateSummary() {
            // Use OrdersPageManager's cart result if available
            if (ordersPageManager && ordersPageManager.cartResult) {
                ordersPageManager.updateCartSummary();
            } else {
                // No data yet
                document.getElementById('standard-carts-summary').textContent = '0';
                document.getElementById('danish-carts-summary').textContent = '0';
                document.getElementById('special-handling-summary').textContent = '0';
            }
        }
        
        // Calculate cart types from breakdown
        // DEPRECATED: calculateCarts() now returns standard and danish directly
        // This function is kept for backward compatibility but should not be used
        function calculateCartTypes(cartResult) {
            // CRITICAL: Use standard and danish directly from calculation result
            // calculateCarts() now returns these values directly, no need to parse breakdown
            if (cartResult && typeof cartResult.standard !== 'undefined' && typeof cartResult.danish !== 'undefined') {
                return {
                    standard: cartResult.standard || 0,
                    danish: cartResult.danish || 0
                };
            }
            
            // Fallback: Parse breakdown if standard/danish not available (shouldn't happen)
            console.warn('‚ö†Ô∏è calculateCartTypes: Using fallback parsing - calculateCarts() should return standard/danish directly!');
            if (!cartResult || !cartResult.breakdown) {
                return { standard: 0, danish: 0 };
            }
            
            let standardCarts = 0;
            let danishCarts = 0;
            
            cartResult.breakdown.forEach(routeData => {
                // Use route-level standard/danish if available
                if (typeof routeData.standardCarts !== 'undefined') {
                    standardCarts += routeData.standardCarts || 0;
                }
                if (typeof routeData.danishCarts !== 'undefined') {
                    danishCarts += routeData.danishCarts || 0;
                } else {
                    // Fallback: Parse fust breakdown
                    routeData.fustBreakdown?.forEach(fust => {
                        if (fust.fustType && fust.fustType.includes('(Danish)')) {
                            danishCarts += fust.carts || 0;
                        } else {
                            standardCarts += fust.carts || 0;
                        }
                    });
                }
            });
            
            return { standard: standardCarts, danish: danishCarts };
        }

        // Export orders
        function exportOrders() {
            orderManager.exportToCSV();
        }

        // Show error
        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 5000);
            }
        }

        // Auto-load today's orders on page load
        document.addEventListener('DOMContentLoaded', async () => {
            // Wait for API to be ready
            function checkAndLoadOrders() {
                if (typeof florinetAPI === 'undefined') {
                    setTimeout(checkAndLoadOrders, 100);
                    return;
                }
                
                // Set default date to today if not set
                const datePicker = document.getElementById('order-date-picker');
                if (datePicker && !datePicker.value) {
                    const today = new Date().toISOString().split('T')[0];
                    datePicker.value = today;
                    console.log(`üìÖ Set default date to: ${today}`);
                }
                
                // Fetch orders from API for the selected date
                console.log('üîÑ Orders page: Auto-loading orders for selected date...');
                setTimeout(async () => {
                    try {
                        await window.syncOrders();
                    } catch (error) {
                        console.error('Auto-load error:', error);
                    }
                }, 500);
            }
            
            checkAndLoadOrders();
        });
        
        // Listen for orders updates from Dashboard
        window.addEventListener('ordersUpdated', (event) => {
            console.log(`üì¢ Orders page: Orders updated (${event.detail.count} orders), reloading...`);
            if (typeof orderManager !== 'undefined') {
                orderManager.orders = event.detail.orders;
                orderManager.filteredOrders = [...event.detail.orders];
                // DISABLED: orderManager.assignCarts() - using FUST-based calculation in updateSummary()
                orderManager.updateOrderCount();
                orderManager.displayOrders();
                updateSummary(); // This now uses CartCalculation.calculateTotalCarts()
            }
        });
        
        // Toggle sidebar collapse (desktop)
        function toggleSidebarCollapse() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('collapsed');
            localStorage.setItem('sidebarCollapsed', sidebar.classList.contains('collapsed'));
        }
        
        // Toggle sidebar on mobile
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('open');
        }
        
        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function(event) {
            const sidebar = document.getElementById('sidebar');
            const menuBtn = document.querySelector('.mobile-menu-btn');
            
            if (window.innerWidth <= 768 && 
                sidebar.classList.contains('open') && 
                !sidebar.contains(event.target) && 
                !menuBtn.contains(event.target)) {
                sidebar.classList.remove('open');
            }
        });
        
        // Restore sidebar state on load
        document.addEventListener('DOMContentLoaded', () => {
            const sidebar = document.getElementById('sidebar');
            const isCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
            if (isCollapsed && window.innerWidth > 768) {
                sidebar.classList.add('collapsed');
            }
        });
        
        // Language switcher - Global and persistent
        window.setLanguage = function(lang) {
            localStorage.setItem('zuidplas_language', lang);
            if (typeof i18n !== 'undefined') {
                i18n.setLanguage(lang);
                updateLanguageButtons();
            } else {
                window.location.reload();
            }
        };
        
        function updateLanguageButtons() {
            const currentLang = localStorage.getItem('zuidplas_user_language') || localStorage.getItem('zuidplas_language') || 'nl';
            document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(`lang-btn-${currentLang}`);
            if (activeBtn) activeBtn.classList.add('active');
        }
        
        // Load language on page load - FROM LOCALSTORAGE (GLOBAL PERSISTENCE)
        document.addEventListener('DOMContentLoaded', () => {
            const savedLang = localStorage.getItem('zuidplas_user_language') || localStorage.getItem('zuidplas_language') || 'nl';
            
            // Try immediately
            if (typeof i18n !== 'undefined') {
                i18n.currentLang = savedLang;
                i18n.setLanguage(savedLang);
                i18n.updatePage();
            } else {
                // Wait for i18n to load
                setTimeout(() => {
                    if (typeof i18n !== 'undefined') {
                        i18n.currentLang = savedLang;
                        i18n.setLanguage(savedLang);
                        i18n.updatePage();
                    }
                }, 200);
            }
            
            // Listen for language changes from other pages
            window.addEventListener('storage', (e) => {
                if (e.key === 'zuidplas_language' && typeof i18n !== 'undefined') {
                    const newLang = e.newValue || 'nl';
                    i18n.setLanguage(newLang);
                    i18n.updatePage();
                    updateOrdersDate(); // Update date format
                    // Re-display orders with new language
                    if (orderManager && orderManager.filteredOrders) {
                        orderManager.displayOrders();
                    }
                }
            });
            
            // Listen for custom language change events
            window.addEventListener('languageChanged', (e) => {
                if (typeof i18n !== 'undefined' && e.detail && e.detail.language) {
                    i18n.setLanguage(e.detail.language);
                    i18n.updatePage();
                    updateOrdersDate(); // Update date format
                    // Re-display orders with new language
                    if (orderManager && orderManager.filteredOrders) {
                        orderManager.displayOrders();
                    }
                }
            });
        });
    
        // Logout function - clears session and redirects to login
        function handleLogout() {
            if (confirm(typeof i18n !== 'undefined' ? i18n.t('common.confirmLogout', 'Are you sure you want to logout?') : 'Are you sure you want to logout?')) {
                // Clear all session data
                localStorage.removeItem('zuidplas_logged_in');
                localStorage.removeItem('florinet_token');
                localStorage.removeItem('florinet_token_expiry');
                localStorage.removeItem('florinet_username');
                localStorage.removeItem('florinet_password');
                localStorage.removeItem('zuidplas_demo_mode');
                sessionStorage.clear();
                
                // Redirect to login
                window.location.href = 'login.html';
            }
        }
        
        // Make logout function global
        window.handleLogout = handleLogout;

    </script>
</body>