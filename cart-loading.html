<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cart Loading Optimizer - Zuidplas Logistics</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/layout.css">
    <style>
        .truck-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 30px;
            margin: 30px 0;
        }
        
        @media (max-width: 1200px) {
            .truck-container {
                grid-template-columns: 1fr;
            }
        }
        
        .route-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .truck-selector {
            margin: 15px 0;
            padding: 12px;
            background: #f9fafb;
            border-radius: 8px;
        }
        
        .truck-selector label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-primary);
        }
        
        .truck-selector select {
            width: 100%;
            padding: 10px;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-size: 1rem;
            background: white;
            cursor: pointer;
        }
        
        .truck-selector select:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .truck-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .truck-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border);
        }
        
        .truck-slots {
            display: grid;
            grid-template-columns: repeat(17, 1fr);
            gap: 8px;
            align-items: start;
            margin: 20px 0;
        }
        
        .cart-slot {
            aspect-ratio: 1;
            border: 2px solid var(--border);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: 600;
            position: relative;
            transition: all 0.2s;
        }
        
        .cart-slot.filled-standard {
            color: white;
            border-width: 2px;
            font-weight: 600;
        }
        
        .cart-slot.filled-danish {
            color: white;
            border-width: 3px;
            font-weight: 600;
        }
        
        .client-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 16px;
            padding: 16px;
            background: #f9fafb;
            border-radius: 8px;
        }
        
        .client-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
        }
        
        .client-color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        
        .cart-visualization {
            margin-top: 20px;
            padding: 20px;
            background: #f9fafb;
            border-radius: 8px;
        }
        
        .cart-visual-item {
            display: inline-block;
            margin: 4px;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            color: white;
            border: 2px solid rgba(0,0,0,0.1);
        }
        
        .cart-slot.empty {
            background: #f9fafb;
            color: var(--text-secondary);
            border-style: dashed;
        }
        
        .cart-slot.overflow {
            background: #fee2e2;
            border-color: #ef4444;
            color: #ef4444;
        }
        
        .route-assignment {
            background: #f0f9ff;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .route-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            margin: 5px 5px 5px 0;
        }
        
        .route-rijnsburg { background: #dbeafe; color: #1e40af; }
        .route-aalsmeer { background: #dcfce7; color: #166534; }
        .route-naaldwijk { background: #fef3c7; color: #92400e; }
        
        .cart-list {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
        }
        
        .cart-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin-bottom: 8px;
            background: #f9fafb;
            border-radius: 8px;
            border-left: 4px solid;
        }
        
        .cart-item.standard { border-left-color: #3b82f6; }
        .cart-item.danish { border-left-color: #8b5cf6; }
        
        .capacity-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .capacity-bar {
            flex: 1;
            height: 20px;
            background: #e5e7eb;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .capacity-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981 0%, #059669 100%);
            transition: width 0.3s;
        }
        
        .capacity-fill.warning {
            background: linear-gradient(90deg, #f59e0b 0%, #d97706 100%);
        }
        
        .capacity-fill.danger {
            background: linear-gradient(90deg, #ef4444 0%, #dc2626 100%);
        }
        
        /* Route Timeline Visualization */
        .route-timeline {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin: 30px 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .timeline-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            margin-top: 30px;
        }
        
        .timeline-connector {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3b82f6 0%, #10b981 50%, #f59e0b 100%);
            z-index: 0;
        }
        
        .timeline-point {
            position: relative;
            z-index: 1;
            text-align: center;
            flex: 1;
        }
        
        .timeline-time {
            background: white;
            border: 3px solid;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.1rem;
            margin: 0 auto 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .timeline-time.route1 { border-color: #3b82f6; color: #3b82f6; }
        .timeline-time.route2 { border-color: #10b981; color: #10b981; }
        .timeline-time.route3 { border-color: #f59e0b; color: #f59e0b; }
        
        .timeline-route-info {
            background: #f9fafb;
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .timeline-truck {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 5px;
        }
        
        /* Color-Coded Route Sections */
        .route-section {
            margin: 15px 0;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid;
        }
        
        .route-section.rijnsburg {
            background: #eff6ff;
            border-left-color: #3b82f6;
        }
        
        .route-section.aalsmeer {
            background: #f0fdf4;
            border-left-color: #10b981;
        }
        
        .route-section.naaldwijk {
            background: #fffbeb;
            border-left-color: #f59e0b;
        }
        
        .route-section-header {
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Cost Impact Display */
        .cost-impact {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-left: 8px;
        }
        
        .cost-impact.positive {
            background: #dcfce7;
            color: #166534;
        }
        
        .cost-impact.negative {
            background: #fee2e2;
            color: #991b1b;
        }
        
        /* Alternative Assignments */
        .alternatives-toggle {
            margin: 20px 0;
            text-align: center;
        }
        
        .alternatives-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .alternative-card {
            background: #f9fafb;
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 15px;
        }
        
        .alternative-card.recommended {
            border-color: var(--primary);
            background: #eff6ff;
        }
        
        /* Loading Sequence */
        .loading-sequence {
            margin-top: 15px;
            padding: 12px;
            background: #f9fafb;
            border-radius: 8px;
        }
        
        .loading-sequence-title {
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .loading-sequence-help {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
            font-style: italic;
        }
        
        .loading-steps {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .loading-step {
            background: white;
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid var(--border);
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: default;
        }
        
        .loading-step-number {
            background: var(--primary);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .loading-more-btn {
            background: var(--primary);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            border: none;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .loading-more-btn:hover {
            background: #ea580c;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(249, 115, 22, 0.3);
        }
        
        .loading-full-list {
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border: 1px solid var(--border);
            max-height: 200px;
            overflow-y: auto;
        }
        
        .loading-full-item {
            padding: 6px 8px;
            border-bottom: 1px solid #f3f4f6;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .loading-full-item:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body>
    <!-- Top Header -->
    <header class="top-header">
        <div class="header-left">
            <div class="header-logo">
                <div class="logo-blocks">
                    <div class="logo-block d">D</div>
                    <div class="logo-block flower">
                        <div class="logo-flower-icon"></div>
                    </div>
                    <div class="logo-block z">Z</div>
                </div>
                <div class="logo-text-large">
                    <div class="logo-main-text">DE ZUIDPLAS</div>
                </div>
            </div>
        </div>
        <div class="header-right">
            <div class="user-menu">
                <div class="user-avatar">A</div>
                <span style="font-size: 14px; color: #374151;">Admin User</span>
                <div class="user-badge">Admin</div>
            </div>
            <button class="logout-btn-header" onclick="handleLogout()" data-i18n="common.logout">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                    <polyline points="16 17 21 12 16 7"></polyline>
                    <line x1="21" y1="12" x2="9" y2="12"></line>
                </svg>
                <span>Uitloggen</span>
            </button>
        </div>
    </header>

    <!-- Top Navigation Bar -->
    <nav class="top-nav">
        <div class="nav-items">
            <a href="index.html" class="nav-item" data-page="index">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="7" height="7"></rect>
                    <rect x="14" y="3" width="7" height="7"></rect>
                    <rect x="14" y="14" width="7" height="7"></rect>
                    <rect x="3" y="14" width="7" height="7"></rect>
                </svg>
                <span data-i18n="nav.dashboard">Dashboard</span>
            </a>
            
            <a href="orders.html" class="nav-item " data-page="orders">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                </svg>
                <span data-i18n="nav.orders">Orders</span>
            </a>
            
            <a href="optimization.html" class="nav-item " data-page="optimization">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polyline>
                </svg>
                <span data-i18n="nav.optimization">Optimization</span>
            </a>
            
            <a href="cart-loading.html" class="nav-item active" data-page="cart-loading">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="2" y="7" width="20" height="14" rx="2"></rect>
                    <path d="M16 7V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v2"></path>
                    <line x1="12" y1="12" x2="12" y2="16"></line>
                    <line x1="8" y1="12" x2="8" y2="16"></line>
                    <line x1="16" y1="12" x2="16" y2="16"></line>
                </svg>
                <span data-i18n="nav.cartOptimization">Cart Optimization</span>
            </a>
            
            <a href="trucks.html" class="nav-item " data-page="trucks">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="1" y="3" width="15" height="13"></rect>
                    <polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon>
                    <circle cx="5.5" cy="18.5" r="2.5"></circle>
                    <circle cx="18.5" cy="18.5" r="2.5"></circle>
                </svg>
                <span data-i18n="nav.trucks">Trucks</span>
            </a>
            
            <a href="costs.html" class="nav-item " data-page="costs">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="12" y1="1" x2="12" y2="23"></line>
                    <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>
                </svg>
                <span data-i18n="nav.costs">Costs</span>
            </a>
        </div>
    </nav>
<!-- Main Content -->
    <main class="main-content" style="margin-left: 0;">
        <div class="page-header">
            <h1 class="page-title" data-i18n="cartLoading.title">Cart Optimization</h1>
            <p class="page-subtitle" data-i18n="cartLoading.subtitle">Place all carts on 2 trucks - Cover all 3 routes efficiently</p>
            <button class="btn btn-primary" onclick="optimizeCartLoading()" style="margin-top: 20px;" data-i18n="cartLoading.optimizeButton">üîÑ Optimize Cart Loading</button>
        </div>

        <!-- Summary Stats -->
        <div class="stats-grid">
            <div class="stat-card primary">
                <div class="icon">üì¶</div>
                <div class="label" data-i18n="cartLoading.totalCarts">Total Carts</div>
                <div class="value" id="total-carts">0</div>
            </div>
            <div class="stat-card success">
                <div class="icon">‚úÖ</div>
                <div class="label" data-i18n="cartLoading.cartsAssigned">Carts Assigned</div>
                <div class="value" id="carts-assigned">0</div>
            </div>
            <div class="stat-card warning">
                <div class="icon">‚ö†Ô∏è</div>
                <div class="label" data-i18n="cartLoading.overflow">Overflow</div>
                <div class="value" id="overflow-count">0</div>
            </div>
            <div class="stat-card info">
                <div class="icon">üéØ</div>
                <div class="label" data-i18n="cartLoading.routesCovered">Routes Covered</div>
                <div class="value" id="routes-covered">0/3</div>
            </div>
        </div>

        <!-- Route Timeline Visualization -->
        <div class="route-timeline" id="route-timeline" style="display: none;">
            <h2 data-i18n="cartLoading.routeTimeline">Route Timeline</h2>
            <div class="timeline-container">
                <div class="timeline-connector"></div>
                <!-- Populated by JavaScript -->
            </div>
        </div>

        <!-- Alternative Assignments Toggle -->
        <div class="alternatives-toggle" id="alternatives-toggle" style="display: none;">
            <button class="btn btn-secondary" onclick="toggleAlternatives()" data-i18n="cartLoading.showAlternatives">üîÑ Show Alternative Assignments</button>
            <div class="alternatives-container" id="alternatives-container" style="display: none;">
                <!-- Populated by JavaScript -->
            </div>
        </div>

        <!-- Truck Loading Visualization -->
        <div class="truck-container" id="truck-container">
            <!-- Populated by JavaScript -->
        </div>

        <!-- Cart List by Route -->
        <div class="card">
            <h2 data-i18n="cartLoading.cartsByRoute">Carts by Route</h2>
            <div id="cart-list-by-route">
                <!-- Populated by JavaScript -->
            </div>
        </div>
    </main>

    <!-- LANGUAGE SCRIPTS - MUST BE FIRST -->
    <script src="js/i18n.js"></script>
    <script src="js/i18n-init.js"></script>
    
    <!-- GLOBAL STATE MANAGER - BEFORE PAGE SCRIPTS -->
    <script src="js/app-state.js"></script>
    
    <!-- PAGE-SPECIFIC SCRIPTS -->
    <script src="js/data.js"></script>
    <script src="js/auth.js"></script>
    <script src="js/api.js"></script>
    <script src="js/route-mapping.js"></script> <!-- CLIENT-TO-ROUTE MAPPING -->
    <script src="js/cart-calculation.js"></script> <!-- CRITICAL: Cart calculation -->
    <script src="js/cart-display-manager.js"></script> <!-- Unified cart display -->
    <script src="js/carts.js"></script>
    <script src="js/ordermanager-shim.js"></script>
    <script src="js/orders.js"></script>
    <script src="js/optimizer.js"></script>
    <script src="js/navigation.js"></script>
    <script>
        let cartLoadingOptimizer = null;

        class CartLoadingOptimizer {
            constructor(orders) {
                this.orders = orders || [];
                this.cartManager = cartManager;
                this.truckAssignments = {
                    truck1: { carts: [], routes: [], danishCount: 0, standardCount: 0 },
                    truck2: { carts: [], routes: [], danishCount: 0, standardCount: 0 }
                };
            }

            /**
             * Get all carts that need to be loaded
             * MUST MATCH DASHBOARD LOGIC EXACTLY!
             * Uses the CORRECT cart-calculation.js method
             */
            getAllCarts() {
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('üì¶ CART CALCULATION (using CACHED result from Dashboard)');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                
                // CRITICAL: Use CACHED result from Dashboard, NEVER calculate independently!
                let cartResult = null;
                if (window.CartCalculation && window.CartCalculation.getGlobalOrdersAndCarts) {
                    const globalData = window.CartCalculation.getGlobalOrdersAndCarts(); // NO forceRefresh - only reads cache!
                    cartResult = globalData.cartResult;
                    
                    console.log('‚úÖ Using CACHED result from Dashboard:');
                    console.log(`   Total carts: ${cartResult.total}`);
                    console.log(`   Aalsmeer: ${cartResult.byRoute.Aalsmeer || 0} carts`);
                    console.log(`   Naaldwijk: ${cartResult.byRoute.Naaldwijk || 0} carts`);
                    console.log(`   Rijnsburg: ${cartResult.byRoute.Rijnsburg || 0} carts`);
                    console.log(`   Trucks: ${cartResult.trucks}`);
                    console.log(`   ‚úÖ This is the SAME result as Dashboard - SINGLE SOURCE OF TRUTH!`);
                    
                    if (!cartResult || cartResult.total === 0) {
                        console.warn('‚ö†Ô∏è WARNING: Got 0 carts from cache - Dashboard may not have calculated yet!');
                        console.warn('‚ö†Ô∏è Please load Dashboard and click "Sync" or "Refresh Data" to calculate carts!');
                        return [];
                    }
                    
                    // Convert breakdown to cart objects for the UI
                    const allCarts = [];
                    let cartIdCounter = 1;
                    
                    // Group orders by customer for cart assignment
                    const ordersByCustomer = {};
                    this.orders.forEach(order => {
                        const customerName = order.customer_name || order.customer || order.customerName || 'Unknown';
                        if (!ordersByCustomer[customerName]) {
                            ordersByCustomer[customerName] = [];
                        }
                        ordersByCustomer[customerName].push(order);
                    });
                    
                    // Create cart objects based on the breakdown
                    if (cartResult.breakdown && Array.isArray(cartResult.breakdown)) {
                        cartResult.breakdown.forEach(routeData => {
                            const route = routeData.route.toLowerCase();
                            if (routeData.fustBreakdown && Array.isArray(routeData.fustBreakdown)) {
                                routeData.fustBreakdown.forEach(fustData => {
                                    // Create carts for this fust type
                                    for (let i = 0; i < fustData.carts; i++) {
                                        // Find a customer for this route
                                        const customerName = Object.keys(ordersByCustomer).find(cust => {
                                            const order = ordersByCustomer[cust][0];
                                            if (order && this.cartManager && this.cartManager.determineRoute) {
                                                const orderRoute = this.cartManager.determineRoute(order).toLowerCase();
                                                return orderRoute === route;
                                            }
                                            return false;
                                        }) || 'Unknown';
                                        
                                        allCarts.push({
                                            id: `cart-${cartIdCounter++}`,
                                            client: customerName,
                                            customer: customerName,
                                            route: route,
                                            type: 'standard', // TODO: Determine Danish vs Standard
                                            orders: ordersByCustomer[customerName] || [],
                                            cartNumber: i + 1,
                                            totalCarts: fustData.carts,
                                            fustType: fustData.fustType
                                        });
                                    }
                                });
                            }
                        });
                    }
                    
                    console.log(`   Standard: ${allCarts.filter(c => c.type === 'standard').length}`);
                    console.log(`   Danish: ${allCarts.filter(c => c.type === 'danish').length}`);
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    
                    return allCarts;
                } else {
                    console.error('‚ùå CartCalculation not available! Using fallback...');
                    // Fallback to old method if needed
                    return [];
                }
            }

            /**
             * Optimize cart assignment to trucks - ROUTE-BY-ROUTE
             * Each route is handled separately, showing breakdown per route
             */
            optimizeAssignment() {
                const allCarts = this.getAllCarts();
                
                // Reset assignments - track routes separately
                this.truckAssignments = {
                    truck1: { 
                        carts: [], 
                        routes: new Set(), 
                        danishCount: 0, 
                        standardCount: 0,
                        routeBreakdown: {
                            rijnsburg: { carts: [], danishCount: 0, standardCount: 0 },
                            naaldwijk: { carts: [], danishCount: 0, standardCount: 0 }
                        }
                    },
                    truck2: { 
                        carts: [], 
                        routes: new Set(), 
                        danishCount: 0, 
                        standardCount: 0,
                        routeBreakdown: {
                            aalsmeer: { carts: [], danishCount: 0, standardCount: 0 }
                        }
                    }
                };

                // Group carts by route
                const cartsByRoute = {
                    rijnsburg: [],
                    aalsmeer: [],
                    naaldwijk: []
                };

                allCarts.forEach(cart => {
                    if (cartsByRoute[cart.route]) {
                        cartsByRoute[cart.route].push(cart);
                    }
                });

                // Strategy: Each route handled separately
                // Truck 1: Route 1 (Rijnsburg) + Route 3 (Naaldwijk)
                // Truck 2: Route 2 (Aalsmeer)

                // Route 1: Rijnsburg ‚Üí Truck 1
                const route1Carts = cartsByRoute.rijnsburg;
                const route1Analysis = this.analyzeRouteCapacity(route1Carts, 'truck1');
                route1Carts.forEach(cart => {
                    this.assignCartToTruck(cart, 'truck1', 'rijnsburg');
                });

                // Route 2: Aalsmeer ‚Üí Truck 2
                const route2Carts = cartsByRoute.aalsmeer;
                const route2Analysis = this.analyzeRouteCapacity(route2Carts, 'truck2');
                route2Carts.forEach(cart => {
                    this.assignCartToTruck(cart, 'truck2', 'aalsmeer');
                });

                // Route 3: Naaldwijk ‚Üí Truck 1 (SEPARATE TRIP - don't combine with Route 1)
                const route3Carts = cartsByRoute.naaldwijk;
                // Route 3 is a SEPARATE trip - check independently (not combined with Route 1)
                const route3Analysis = this.analyzeRouteCapacity(route3Carts, 'truck1', false);
                route3Carts.forEach(cart => {
                    if (route3Analysis.fits) {
                        this.assignCartToTruck(cart, 'truck1', 'naaldwijk');
                    } else {
                        // Overflow - mark it but still assign for visualization
                        cart.overflow = true;
                        this.assignCartToTruck(cart, 'truck1', 'naaldwijk');
                    }
                });

                return {
                    truck1: this.truckAssignments.truck1,
                    truck2: this.truckAssignments.truck2,
                    allCarts: allCarts,
                    routeAnalysis: {
                        rijnsburg: route1Analysis,
                        aalsmeer: route2Analysis,
                        naaldwijk: route3Analysis
                    }
                };
            }
            
            /**
             * Analyze if a route's carts fit in a truck
             * IMPORTANT: Each route is a SEPARATE TRIP - don't combine routes!
             * @param {Array} routeCarts - Carts for this route
             * @param {String} truckId - Which truck to check
             * @param {Boolean} considerExisting - NOT USED - each route is independent
             */
            analyzeRouteCapacity(routeCarts, truckId, considerExisting = false) {
                // Count carts for THIS ROUTE ONLY (each route is a separate trip)
                let routeDanish = 0;
                let routeStandard = 0;
                routeCarts.forEach(cart => {
                    if (cart.type === 'danish') {
                        routeDanish++;
                    } else {
                        routeStandard++;
                    }
                });
                
                // Calculate truck capacity for THIS ROUTE (based on Danish carts in THIS route only)
                const maxCapacity = routeDanish > BUSINESS_RULES.danishThreshold 
                    ? BUSINESS_RULES.maxCartsWithDanish 
                    : BUSINESS_RULES.maxStandardCarts;
                
                // Check if THIS ROUTE fits using ACTUAL cart count (not equivalent)
                const actualCartCount = routeCarts.length;
                const fits = actualCartCount <= maxCapacity;
                const overflow = Math.max(0, actualCartCount - maxCapacity);
                
                // Calculate equivalent for display purposes only
                const routeEquivalentStandard = routeStandard + Math.ceil(routeDanish / BUSINESS_RULES.danishToStandardRatio);
                
                return {
                    // Route-specific info
                    routeCarts: routeCarts.length,
                    routeDanish: routeDanish,
                    routeStandard: routeStandard,
                    routeEquivalent: routeEquivalentStandard,
                    
                    // Capacity check for THIS ROUTE ONLY
                    fits: fits,
                    used: routeCarts.length, // Show ACTUAL cart count, not equivalent
                    max: maxCapacity,
                    overflow: overflow,
                    
                    // For backward compatibility
                    danishCount: routeDanish,
                    standardCount: routeStandard,
                    totalCarts: routeCarts.length
                };
            }

            assignCartToTruck(cart, truckId, routeName = null) {
                const truck = this.truckAssignments[truckId];
                truck.carts.push(cart);
                truck.routes.add(cart.route);
                
                if (cart.type === 'danish') {
                    truck.danishCount++;
                } else {
                    truck.standardCount++;
                }
                
                // Track route breakdown
                if (routeName && truck.routeBreakdown[routeName]) {
                    truck.routeBreakdown[routeName].carts.push(cart);
                    if (cart.type === 'danish') {
                        truck.routeBreakdown[routeName].danishCount++;
                    } else {
                        truck.routeBreakdown[routeName].standardCount++;
                    }
                }
            }

            canFitInTruck(cart, truckId) {
                const truck = this.truckAssignments[truckId];
                const currentDanish = truck.danishCount + (cart.type === 'danish' ? 1 : 0);
                const currentStandard = truck.standardCount + (cart.type === 'standard' ? 1 : 0);
                
                const maxCapacity = currentDanish > BUSINESS_RULES.danishThreshold 
                    ? BUSINESS_RULES.maxCartsWithDanish 
                    : BUSINESS_RULES.maxStandardCarts;
                
                const equivalentStandard = currentStandard + Math.ceil(currentDanish / BUSINESS_RULES.danishToStandardRatio);
                
                return equivalentStandard <= maxCapacity;
            }

            getTruckCapacity(truckId) {
                const truck = this.truckAssignments[truckId];
                
                // Get the route(s) on this truck to determine capacity
                const routes = Array.from(truck.routes);
                let maxCapacity = BUSINESS_RULES.maxStandardCarts;
                let totalDanish = 0;
                
                // Check each route to determine max capacity (if any route has >6 Danish, capacity is 16)
                routes.forEach(routeName => {
                    const routeBreakdown = truck.routeBreakdown[routeName];
                    if (routeBreakdown) {
                        totalDanish += routeBreakdown.danishCount || 0;
                    }
                });
                
                // If total Danish carts > threshold, capacity is reduced
                if (totalDanish > BUSINESS_RULES.danishThreshold) {
                    maxCapacity = BUSINESS_RULES.maxCartsWithDanish;
                }
                
                // Use ACTUAL cart count, not equivalent
                const actualCartCount = truck.carts.length;
                const fits = actualCartCount <= maxCapacity;
                const overflow = Math.max(0, actualCartCount - maxCapacity);
                
                return {
                    max: maxCapacity,
                    used: actualCartCount, // ACTUAL cart count
                    standard: truck.standardCount,
                    danish: truck.danishCount,
                    fits: fits,
                    overflow: overflow,
                    utilization: maxCapacity > 0 ? ((actualCartCount / maxCapacity) * 100).toFixed(1) : '0.0'
                };
            }
        }

        /**
         * Show error message when no data is available
         */
        function showError(message) {
            // Remove any existing error
            const existingError = document.getElementById('cart-loading-error-message');
            if (existingError) {
                existingError.remove();
            }
            
            const errorDiv = document.createElement('div');
            errorDiv.id = 'cart-loading-error-message';
            errorDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #fff3cd;
                border: 2px solid #ffc107;
                padding: 30px;
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 9999;
                max-width: 500px;
            `;
            
            errorDiv.innerHTML = `
                <h3 style="margin-top: 0; color: #856404;">‚ö†Ô∏è No Data Available</h3>
                <p style="color: #856404;">${message}</p>
                <button onclick="window.location.href='index.html'" 
                        style="margin-top: 20px; padding: 10px 20px; background: #ff6b00; color: white; border: none; border-radius: 5px; cursor: pointer; width: 100%;">
                    Go to Dashboard
                </button>
            `;
            
            document.body.appendChild(errorDiv);
        }
        
        // Make function globally accessible
        window.optimizeCartLoading = function optimizeCartLoading() {
            console.log('üöÄ optimizeCartLoading() called');
            
            // Ensure orderManager exists
            if (typeof orderManager === 'undefined') {
                console.error('‚ùå orderManager is not defined!');
                alert('Error: Order manager not initialized. Please refresh the page.');
                return;
            }
            
            // CRITICAL: Check if orders are available (from global state or orderManager)
            const hasOrders = orderManager && orderManager.orders && orderManager.orders.length > 0;
            const hasGlobalStateOrders = typeof window.appState !== 'undefined' && window.appState.hasOrders();
            
            // If no orders in orderManager but orders exist in global state, load them
            if (!hasOrders && hasGlobalStateOrders) {
                console.log('üì¶ Loading orders from global state...');
                const orders = window.appState.getOrders();
                if (!orderManager) {
                    console.error('‚ùå orderManager is still not defined after checking appState!');
                    alert('Error: Order manager not initialized. Please refresh the page.');
                    return;
                }
                orderManager.orders = orders;
                orderManager.filteredOrders = [...orders];
                console.log(`‚úÖ Loaded ${orders.length} orders from global state`);
            }
            
            // Final check - if still no orders, show error
            if (!orderManager || !orderManager.orders || orderManager.orders.length === 0) {
                // Show clear message - orders must be loaded first
                // Use i18n for proper language support
                const message = typeof i18n !== 'undefined' 
                    ? i18n.t('cartLoading.noOrdersMessage', 'No orders available. Go to Dashboard and click "Sync Orders from API" or "Load Demo Data" to load orders.')
                    : 'No orders available. Go to Dashboard and click "Sync Orders from API" or "Load Demo Data" to load orders.';
                
                alert(message);
                console.warn('‚ö†Ô∏è Cannot optimize: No orders loaded. Please load orders from Dashboard first.');
                
                // Clear any stale visualization
                clearCartOptimizationDisplay();
                return;
            }

            // Only proceed if we have fresh orders
            console.log('‚úÖ Running cart optimization with', orderManager.orders.length, 'orders');
            
            // CRITICAL: Use the SAME optimizer as dashboard to get consistent cart counts
            const optimizer = new RouteOptimizer(orderManager.orders);
            const routeAnalysis = optimizer.processOrders();
            
            cartLoadingOptimizer = new CartLoadingOptimizer(orderManager.orders);
            const result = cartLoadingOptimizer.optimizeAssignment();
            
            // Override route analysis with dashboard's route analysis for consistency
            // This ensures cart counts match dashboard exactly
            // Use ACTUAL cart count (totalCarts), not equivalent standard - NO HARDCODING!
            if (routeAnalysis) {
                result.routeAnalysis = {
                    rijnsburg: {
                        fits: routeAnalysis.rijnsburg?.fits !== undefined ? routeAnalysis.rijnsburg.fits : true,
                        used: routeAnalysis.rijnsburg?.totalCarts || 0, // ACTUAL cart count from dashboard
                        max: routeAnalysis.rijnsburg?.maxCapacity || 17,
                        overflow: routeAnalysis.rijnsburg?.overflow || 0,
                        totalCarts: routeAnalysis.rijnsburg?.totalCarts || 0,
                        danishCount: routeAnalysis.rijnsburg?.danishCarts || 0,
                        standardCount: routeAnalysis.rijnsburg?.standardCarts || 0
                    },
                    aalsmeer: {
                        // CRITICAL: Use dashboard's calculation - if 37 carts > 16 capacity = overflow!
                        fits: routeAnalysis.aalsmeer?.fits !== undefined ? routeAnalysis.aalsmeer.fits : ((routeAnalysis.aalsmeer?.totalCarts || 0) <= (routeAnalysis.aalsmeer?.maxCapacity || 17)),
                        used: routeAnalysis.aalsmeer?.totalCarts || 0, // ACTUAL cart count from dashboard
                        max: routeAnalysis.aalsmeer?.maxCapacity || 17,
                        overflow: routeAnalysis.aalsmeer?.overflow || 0,
                        totalCarts: routeAnalysis.aalsmeer?.totalCarts || 0,
                        danishCount: routeAnalysis.aalsmeer?.danishCarts || 0,
                        standardCount: routeAnalysis.aalsmeer?.standardCarts || 0
                    },
                    naaldwijk: {
                        fits: routeAnalysis.naaldwijk?.fits !== undefined ? routeAnalysis.naaldwijk.fits : true,
                        used: routeAnalysis.naaldwijk?.totalCarts || 0, // ACTUAL cart count from dashboard
                        max: routeAnalysis.naaldwijk?.maxCapacity || 17,
                        overflow: routeAnalysis.naaldwijk?.overflow || 0,
                        totalCarts: routeAnalysis.naaldwijk?.totalCarts || 0,
                        danishCount: routeAnalysis.naaldwijk?.danishCarts || 0,
                        standardCount: routeAnalysis.naaldwijk?.standardCarts || 0
                    }
                };
            }
            
            updateTruckVisualization(result);
            updateCartList(result.allCarts);
            updateSummaryStats(result);
            updateRouteTimeline(result);
            generateAlternatives(result);
            
            // Save route analysis to localStorage for Truck Management page
            if (result.routeAnalysis) {
                localStorage.setItem('zuidplas_route_analysis', JSON.stringify(result.routeAnalysis));
            }
        }
        
        function clearCartOptimizationDisplay() {
            // Reset all stats to 0
            document.getElementById('total-carts').textContent = '0';
            document.getElementById('carts-assigned').textContent = '0';
            document.getElementById('overflow-count').textContent = '0';
            document.getElementById('routes-covered').textContent = '0/3';
            
            // Clear truck visualization - use i18n for proper language
            const truckContainer = document.getElementById('truck-container');
            if (truckContainer) {
                const noOrdersMsg = typeof i18n !== 'undefined' 
                    ? i18n.t('cartLoading.noOrdersMessage', 'No orders loaded. Go to Dashboard to load orders.')
                    : 'No orders loaded. Go to Dashboard to load orders.';
                truckContainer.innerHTML = `<div style="text-align: center; padding: 40px; color: var(--text-secondary);" data-i18n="cartLoading.noOrdersMessage">${noOrdersMsg}</div>`;
                // Update i18n if available
                if (typeof i18n !== 'undefined') {
                    i18n.updatePage();
                }
            }
            
            // Clear cart list - use i18n for proper language
            const cartList = document.getElementById('cart-list-by-route');
            if (cartList) {
                const loadFirstMsg = typeof i18n !== 'undefined' 
                    ? i18n.t('cartLoading.loadOrdersFirst', 'Load orders from Dashboard first.')
                    : 'Load orders from Dashboard first.';
                cartList.innerHTML = `<div style="text-align: center; padding: 20px; color: var(--text-secondary);" data-i18n="cartLoading.loadOrdersFirst">${loadFirstMsg}</div>`;
                // Update i18n if available
                if (typeof i18n !== 'undefined') {
                    i18n.updatePage();
                }
            }
        }

        // Store current truck assignments for each route (can be single truck or combination like "truck1+truck2")
        // Load from localStorage to persist across navigation
        // Only cleared when new orders are synced (handled in index.html and orders.js)
        let routeTruckAssignments = {
            rijnsburg: null,  // No default - user must select
            aalsmeer: null,   // No default - user must select
            naaldwijk: null   // No default - user must select
        };
        
        // Load saved assignments from localStorage (persists across navigation)
        function loadTruckAssignments() {
            try {
                const saved = localStorage.getItem('zuidplas_route_truck_assignments');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Only restore if we have valid assignments
                    if (parsed && typeof parsed === 'object') {
                        routeTruckAssignments = {
                            rijnsburg: parsed.rijnsburg || null,
                            aalsmeer: parsed.aalsmeer || null,
                            naaldwijk: parsed.naaldwijk || null
                        };
                        console.log('‚úÖ Restored truck assignments from localStorage:', routeTruckAssignments);
                    }
                }
            } catch (e) {
                console.warn('Failed to load truck assignments:', e);
            }
        }
        
        // Load assignments on page load
        loadTruckAssignments();
        
        // Parse truck assignment string to get array of truck IDs
        function parseTruckAssignment(assignment) {
            if (!assignment) return ['truck1'];
            if (assignment.includes('+')) {
                return assignment.split('+').map(t => t.trim());
            }
            return [assignment];
        }
        
        // Get combined capacity for multiple trucks
        function getCombinedCapacity(truckIds, routeCarts) {
            let totalCapacity = 0;
            let totalDanish = 0;
            
            routeCarts.forEach(cart => {
                if (cart.type === 'danish') totalDanish++;
            });
            
            // Each truck has capacity based on Danish carts
            const maxCapacityPerTruck = totalDanish > BUSINESS_RULES.danishThreshold 
                ? BUSINESS_RULES.maxCartsWithDanish 
                : BUSINESS_RULES.maxStandardCarts;
            
            // Combined capacity = sum of all trucks
            totalCapacity = truckIds.length * maxCapacityPerTruck;
            
            return {
                max: totalCapacity,
                perTruck: maxCapacityPerTruck,
                truckCount: truckIds.length
            };
        }
        
        // Split carts between multiple trucks
        // CRITICAL: Only use as many trucks as needed - don't split if all carts fit in one truck
        function splitCartsBetweenTrucks(routeCarts, truckIds, combinedCapacity) {
            const perTruckCapacity = combinedCapacity.perTruck;
            const totalCarts = routeCarts.length;
            
            const assignments = {};
            truckIds.forEach(truckId => {
                assignments[truckId] = [];
            });
            
            // If all carts fit in one truck, put ALL carts in first truck only
            // Other trucks stay completely empty
            if (totalCarts <= perTruckCapacity) {
                assignments[truckIds[0]] = [...routeCarts];
                // All other trucks remain empty (already initialized as empty arrays)
                return assignments;
            }
            
            // Otherwise, distribute across trucks as needed (overflow scenario)
            let currentTruckIndex = 0;
            routeCarts.forEach((cart) => {
                const truckId = truckIds[currentTruckIndex];
                assignments[truckId].push(cart);
                
                // Move to next truck if current truck is full
                if (assignments[truckId].length >= perTruckCapacity && currentTruckIndex < truckIds.length - 1) {
                    currentTruckIndex++;
                }
            });
            
            return assignments;
        }
        
        // Route times for conflict detection
        const routeTimes = {
            rijnsburg: { time: '09:00', hour: 9 },
            aalsmeer: { time: '10:00', hour: 10 },
            naaldwijk: { time: '11:00', hour: 11 }
        };
        
        // Check if two routes have time conflict
        function hasTimeConflict(route1Key, route2Key) {
            const route1 = routeTimes[route1Key];
            const route2 = routeTimes[route2Key];
            if (!route1 || !route2) return false;
            
            // Routes conflict if they're within 2 hours of each other (truck needs time to return)
            const timeDiff = Math.abs(route1.hour - route2.hour);
            return timeDiff < 2;
        }
        
        // Get available truck combinations for a route
        function getAvailableTruckOptions(currentRouteKey) {
            const singleTrucks = [
                { id: 'truck1', name: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck1', 'Truck 1') : 'Truck 1' },
                { id: 'truck2', name: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck2', 'Truck 2') : 'Truck 2' },
                { id: 'neighbor', name: typeof i18n !== 'undefined' ? i18n.t('cartLoading.neighborTruck', 'Neighbor\'s Truck') : 'Neighbor\'s Truck' },
                { id: 'external', name: typeof i18n !== 'undefined' ? i18n.t('cartLoading.externalTruck', 'External Truck') : 'External Truck' }
            ];
            
            // Multi-truck combinations - expanded to include all possible combinations
            const combinations = [
                // Two truck combinations
                { id: 'truck1+truck2', name: 'Truck 1 + Truck 2' },
                { id: 'truck1+neighbor', name: 'Truck 1 + Neighbor\'s Truck' },
                { id: 'truck1+external', name: 'Truck 1 + External Truck' },
                { id: 'truck2+neighbor', name: 'Truck 2 + Neighbor\'s Truck' },
                { id: 'truck2+external', name: 'Truck 2 + External Truck' },
                { id: 'neighbor+external', name: 'Neighbor\'s Truck + External Truck' },
                { id: 'neighbor+neighbor', name: '2 Neighbor\'s Trucks' },
                { id: 'external+external', name: '2 External Trucks' },
                // Three truck combinations
                { id: 'truck1+truck2+neighbor', name: 'Truck 1 + Truck 2 + Neighbor\'s Truck' },
                { id: 'truck1+truck2+external', name: 'Truck 1 + Truck 2 + External Truck' },
                { id: 'truck1+neighbor+external', name: 'Truck 1 + Neighbor\'s Truck + External Truck' },
                { id: 'truck2+neighbor+external', name: 'Truck 2 + Neighbor\'s Truck + External Truck' },
                { id: 'neighbor+neighbor+external', name: '2 Neighbor\'s Trucks + External Truck' },
                { id: 'neighbor+external+external', name: 'Neighbor\'s Truck + 2 External Trucks' },
                // Four truck combinations (for very large routes)
                { id: 'truck1+truck2+neighbor+external', name: 'Truck 1 + Truck 2 + Neighbor\'s Truck + External Truck' },
                { id: 'truck1+neighbor+neighbor+external', name: 'Truck 1 + 2 Neighbor\'s Trucks + External Truck' },
                { id: 'truck1+neighbor+external+external', name: 'Truck 1 + Neighbor\'s Truck + 2 External Trucks' },
                { id: 'truck2+neighbor+neighbor+external', name: 'Truck 2 + 2 Neighbor\'s Trucks + External Truck' },
                { id: 'truck2+neighbor+external+external', name: 'Truck 2 + Neighbor\'s Truck + 2 External Trucks' },
                { id: 'neighbor+neighbor+external+external', name: '2 Neighbor\'s Trucks + 2 External Trucks' }
            ];
            
            const allOptions = [...singleTrucks, ...combinations];
            const available = [];
            
            allOptions.forEach(option => {
                const truckIds = parseTruckAssignment(option.id);
                let hasConflict = false;
                let conflictRoute = null;
                
                // Check each truck in the combination for conflicts
                truckIds.forEach(truckId => {
                    // Neighbor and External trucks are always available
                    if (truckId === 'neighbor' || truckId === 'external') return;
                    
                    Object.keys(routeTruckAssignments).forEach(routeKey => {
                        if (routeKey === currentRouteKey) return;
                        
                        // CRITICAL: Only check routes that actually have a truck assigned (not null)
                        const assignedTrucksStr = routeTruckAssignments[routeKey];
                        if (!assignedTrucksStr || assignedTrucksStr === null) return; // Skip routes with no assignment
                        
                        const assignedTrucks = parseTruckAssignment(assignedTrucksStr);
                        if (assignedTrucks.includes(truckId) && hasTimeConflict(currentRouteKey, routeKey)) {
                            hasConflict = true;
                            conflictRoute = routeKey;
                        }
                    });
                });
                
                if (!hasConflict) {
                    available.push({ ...option, available: true, reason: '' });
                } else {
                    const routeName = conflictRoute === 'rijnsburg' ? 'Rijnsburg' : 
                                     conflictRoute === 'aalsmeer' ? 'Aalsmeer' : 'Naaldwijk';
                    available.push({ 
                        ...option, 
                        available: false, 
                        reason: `Truck conflict with ${routeName}`
                    });
                }
            });
            
            return available;
        }

        function updateTruckVisualization(result) {
            const container = document.getElementById('truck-container');
            container.innerHTML = '';

            // Get route analysis if available
            const routeAnalysis = result.routeAnalysis || {};
            
            // Get route definitions
            const routes = [
                { key: 'rijnsburg', name: typeof i18n !== 'undefined' ? i18n.t('routes.rijnsburg', 'Rijnsburg') : 'Rijnsburg', time: '09:00', color: '#3b82f6', bgColor: '#eff6ff' },
                { key: 'aalsmeer', name: typeof i18n !== 'undefined' ? i18n.t('routes.aalsmeer', 'Aalsmeer') : 'Aalsmeer', time: '10:00', color: '#10b981', bgColor: '#f0fdf4' },
                { key: 'naaldwijk', name: typeof i18n !== 'undefined' ? i18n.t('routes.naaldwijk', 'Naaldwijk') : 'Naaldwijk', time: '11:00', color: '#f59e0b', bgColor: '#fffbeb' }
            ];

            // Create separate card for EACH route
            routes.forEach(route => {
                const routeInfo = routeAnalysis[route.key];
                if (!routeInfo) return;

                // Get carts for this route only
                const routeCarts = result.allCarts.filter(cart => cart.route === route.key);
                
                // Get assigned trucks (can be single or multiple)
                // CRITICAL: No default - if null, show "Select Truck" message
                const assignedTrucksStr = routeTruckAssignments[route.key] || null;
                
                // If no truck selected, show message to select truck first WITH cart information
                if (!assignedTrucksStr) {
                    const selectTruckMsg = typeof i18n !== 'undefined' ? i18n.t('cartLoading.selectTruckFirst', 'Please select a truck for this route') : 'Please select a truck for this route';
                    
                    // Calculate cart statistics for display
                    // CRITICAL: Use routeInfo.totalCarts (from optimizer) for consistency, not routeCarts.length
                    const totalCarts = routeInfo.totalCarts || routeCarts.length;
                    const standardCarts = routeInfo.standardCarts || routeCarts.filter(c => c.type !== 'danish').length;
                    const danishCarts = routeInfo.danishCarts || routeCarts.filter(c => c.type === 'danish').length;
                    const maxCapacity = routeInfo.maxCapacity || 17;
                    
                    const routeCard = document.createElement('div');
                    routeCard.className = 'route-card';
                    routeCard.style.borderLeft = `4px solid ${route.color}`;
                    routeCard.innerHTML = `
                        <div style="padding: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px;">
                                <div>
                                    <div style="font-size: 1.1rem; font-weight: 600; color: var(--text-primary); margin-bottom: 5px;">
                                        ${route.name} (${route.time})
                                    </div>
                                    <div style="color: var(--text-secondary); font-size: 0.9rem;">
                                        ${selectTruckMsg}
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-size: 1.3rem; font-weight: 700; color: ${route.color};">
                                        ${totalCarts}
                                    </div>
                                    <div style="font-size: 0.85rem; color: var(--text-secondary);">
                                        ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.totalCarts', 'carts') : 'carts'} ${totalCarts > maxCapacity ? `(${typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow'})` : ''}
                                    </div>
                                </div>
                            </div>
                            
                            ${totalCarts > 0 ? `
                            <div style="background: ${route.bgColor}; padding: 12px; border-radius: 8px; margin-bottom: 15px; font-size: 0.9rem;">
                                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                                    <div>
                                        <strong>${typeof i18n !== 'undefined' ? i18n.t('cartLoading.totalCarts', 'Total Carts') : 'Total Carts'}:</strong> ${totalCarts}
                                    </div>
                                    ${standardCarts > 0 ? `
                                    <div>
                                        <strong>${typeof i18n !== 'undefined' ? i18n.t('cartLoading.standardCart', 'Standard') : 'Standard'}:</strong> ${standardCarts}
                                    </div>
                                    ` : ''}
                                    ${danishCarts > 0 ? `
                                    <div>
                                        <strong>${typeof i18n !== 'undefined' ? i18n.t('cartLoading.danishCart', 'Danish') : 'Danish'}:</strong> ${danishCarts}
                                    </div>
                                    ` : ''}
                                    <div>
                                        <strong>${typeof i18n !== 'undefined' ? i18n.t('status.capacity', 'Capacity') : 'Capacity'}:</strong> ${maxCapacity} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.perTruck', 'per truck') : 'per truck'}
                                    </div>
                                </div>
                                ${totalCarts > maxCapacity ? `
                                <div style="margin-top: 8px; padding: 8px; background: #fee2e2; border-radius: 6px; color: #991b1b; font-weight: 600;">
                                    ‚ö†Ô∏è ${totalCarts - maxCapacity} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.cartsOverflow', 'carts overflow - consider multiple trucks') : 'carts overflow - consider multiple trucks'}
                                </div>
                                ` : totalCarts <= maxCapacity ? `
                                <div style="margin-top: 8px; padding: 8px; background: #d1fae5; border-radius: 6px; color: #065f46; font-weight: 600;">
                                    ‚úì ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.fitsInOneTruck', 'Fits in one truck') : 'Fits in one truck'}
                                </div>
                                ` : ''}
                            </div>
                            ` : ''}
                            
                            <div class="truck-selector">
                                <label for="truck-select-${route.key}">
                                    ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.selectTruck', 'Select Truck:') : 'Select Truck:'}
                                </label>
                                <select id="truck-select-${route.key}" onchange="updateRouteTruck('${route.key}', this.value)">
                                    ${(() => {
                                        const selectTruckText = typeof i18n !== 'undefined' ? i18n.t('cartLoading.selectTruckOption', '-- Select Truck --') : '-- Select Truck --';
                                        let options = [`<option value="" selected disabled>${selectTruckText}</option>`];
                                        const availableOptions = getAvailableTruckOptions(route.key);
                                        availableOptions.forEach(option => {
                                            const disabled = !option.available ? 'disabled' : '';
                                            const title = option.reason ? ` title="${option.reason}"` : '';
                                            options.push(`<option value="${option.id}" ${disabled}${title}>
                                                ${option.name}${!option.available ? ' (Unavailable)' : ''}
                                            </option>`);
                                        });
                                        return options.join('');
                                    })()}
                                </select>
                            </div>
                        </div>
                    `;
                    container.appendChild(routeCard);
                    
                    // Restore saved truck selection in dropdown
                    const selector = document.getElementById(`truck-select-${route.key}`);
                    if (selector && routeTruckAssignments[route.key]) {
                        selector.value = routeTruckAssignments[route.key];
                    }
                    
                    return; // Skip showing carts/visualization until truck is selected
                }
                
                const assignedTruckIds = parseTruckAssignment(assignedTrucksStr);
                
                // Calculate combined capacity for multiple trucks
                const combinedCapacity = getCombinedCapacity(assignedTruckIds, routeCarts);
                // CRITICAL: Use routeInfo.totalCarts (from optimizer) for consistency
                const totalCarts = routeInfo.totalCarts || routeCarts.length;
                const fits = totalCarts <= combinedCapacity.max;
                const overflow = Math.max(0, totalCarts - combinedCapacity.max);
                
                // Create route capacity object
                const routeCapacity = {
                    max: combinedCapacity.max,
                    used: totalCarts,
                    overflow: overflow,
                    fits: fits,
                    truckCount: assignedTruckIds.length,
                    perTruck: combinedCapacity.perTruck
                };
                
                // Update routeInfo to reflect combined capacity
                const updatedRouteInfo = {
                    ...routeInfo,
                    fits: fits,
                    maxCapacity: combinedCapacity.max,
                    overflow: overflow,
                    totalCarts: totalCarts
                };
                
                // Get display name for assigned trucks
                const truckNames = {
                    truck1: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck1', 'Truck 1') : 'Truck 1',
                    truck2: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck2', 'Truck 2') : 'Truck 2',
                    neighbor: typeof i18n !== 'undefined' ? i18n.t('cartLoading.neighborTruck', 'Neighbor\'s Truck') : 'Neighbor\'s Truck',
                    external: typeof i18n !== 'undefined' ? i18n.t('cartLoading.externalTruck', 'External Truck') : 'External Truck'
                };
                const assignedTruckName = assignedTruckIds.map(id => truckNames[id] || id).join(' + ');
                
                // Create route card
                const routeCard = createRouteCard(route, updatedRouteInfo, routeCarts, routeCapacity, assignedTrucksStr, assignedTruckName, assignedTruckIds);
                container.appendChild(routeCard);
                
                // Restore saved truck selection in dropdown (if not already selected)
                const selector = document.getElementById(`truck-selector-${route.key}`);
                if (selector && routeTruckAssignments[route.key] && selector.value !== routeTruckAssignments[route.key]) {
                    selector.value = routeTruckAssignments[route.key];
                }
            });
        }
        
        function createRouteCard(route, routeInfo, routeCarts, routeCapacity, assignedTrucksStr, assignedTruckName, assignedTruckIds) {
            const card = document.createElement('div');
            card.className = 'route-card';
            card.style.borderLeft = `4px solid ${route.color}`;
            
            // Use routeCapacity.fits (based on combined capacity) instead of routeInfo.fits
            const statusClass = routeCapacity.fits ? 'success' : 'danger';
            const statusIcon = routeCapacity.fits ? '‚úÖ' : '‚ö†Ô∏è';
            const statusText = routeCapacity.fits 
                ? (typeof i18n !== 'undefined' ? i18n.t('status.fits', 'Fits') : 'Fits')
                : (typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow');
            
            // Get unique clients for this route
            const clients = [...new Set(routeCarts.map(cart => cart.client || 'Unknown'))];
            const clientColorMap = {};
            clients.forEach((client, index) => {
                clientColorMap[client] = getClientColor(client, index);
            });
            
            // Split carts between trucks if multiple trucks selected
            const cartAssignments = splitCartsBetweenTrucks(routeCarts, assignedTruckIds, routeCapacity);
            
            // Create visualization slots - show carts split by truck
            const slots = [];
            const truckNames = {
                truck1: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck1', 'Truck 1') : 'Truck 1',
                truck2: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck2', 'Truck 2') : 'Truck 2',
                neighbor: typeof i18n !== 'undefined' ? i18n.t('cartLoading.neighborTruck', 'Neighbor\'s Truck') : 'Neighbor\'s Truck',
                external: typeof i18n !== 'undefined' ? i18n.t('cartLoading.externalTruck', 'External Truck') : 'External Truck'
            };
            
            // Show ALL selected trucks, even if empty (user wants to see empty trucks too)
            assignedTruckIds.forEach((truckId, truckIndex) => {
                const truckCarts = cartAssignments[truckId] || [];
                
                // Add truck separator label (except for first truck)
                if (truckIndex > 0) {
                    slots.push({
                        type: 'truck-separator',
                        truckName: truckNames[truckId] || truckId
                    });
                }
                
                // Add carts for this truck
                truckCarts.forEach(cart => {
                    const clientColor = clientColorMap[cart.client || 'Unknown'];
                    const cartType = cart.type || (cart.cartType || 'standard');
                    slots.push({
                        type: cartType,
                        client: cart.client || 'Unknown',
                        color: clientColor,
                        route: route.key,
                        truckId: truckId
                    });
                });
                
                // Fill empty slots for this truck (always fill to capacity, even if truck is empty)
                const perTruckCapacity = routeCapacity.perTruck;
                // Count current slots for this truck (excluding separator)
                let currentTruckSlotCount = slots.filter(s => s.truckId === truckId && s.type !== 'truck-separator').length;
                // Fill up to capacity
                while (currentTruckSlotCount < perTruckCapacity) {
                    slots.push({ type: 'empty', truckId: truckId });
                    currentTruckSlotCount++; // CRITICAL: Update counter to prevent infinite loop
                }
            });
            
            // Add overflow slots if any
            if (routeCapacity.overflow > 0) {
                for (let i = 0; i < routeCapacity.overflow; i++) {
                    slots.push({ type: 'overflow' });
                }
            }
            
            // Truck selector
            const truckSelectorId = `truck-selector-${route.key}`;
            
            card.innerHTML = `
                <div class="truck-header">
                    <div>
                        <h2 style="margin: 0; color: ${route.color};">${route.name} (${route.time})</h2>
                        <div style="margin-top: 8px;">
                            <span class="badge ${statusClass}">${statusIcon} ${statusText}</span>
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 1.2rem; font-weight: 700; color: ${route.color};">
                            ${routeInfo.totalCarts} / ${routeCapacity.max}
                        </div>
                        <div style="font-size: 0.9rem; color: var(--text-secondary);">
                            ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.totalCarts', 'carts') : 'carts'}
                        </div>
                    </div>
                </div>
                
                <div class="truck-selector">
                    <label for="${truckSelectorId}">
                        ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.selectTruck', 'Select Truck:') : 'Select Truck:'}
                    </label>
                    <select id="${truckSelectorId}" onchange="updateRouteTruck('${route.key}', this.value)">
                        ${(() => {
                            let options = [];
                            // If no truck selected, show "-- Select Truck --" as first option
                            if (!assignedTrucksStr) {
                                const selectTruckText = typeof i18n !== 'undefined' ? i18n.t('cartLoading.selectTruckOption', '-- Select Truck --') : '-- Select Truck --';
                                options.push(`<option value="" selected disabled>${selectTruckText}</option>`);
                            }
                            
                            const availableOptions = getAvailableTruckOptions(route.key);
                            availableOptions.forEach(option => {
                                const selected = assignedTrucksStr === option.id ? 'selected' : '';
                                const disabled = !option.available ? 'disabled' : '';
                                const title = option.reason ? ` title="${option.reason}"` : '';
                                options.push(`<option value="${option.id}" ${selected} ${disabled}${title}>
                                    ${option.name}${!option.available ? ' (Unavailable)' : ''}
                                </option>`);
                            });
                            return options.join('');
                        })()}
                    </select>
                    ${(() => {
                        const availableOptions = getAvailableTruckOptions(route.key);
                        const unavailableOptions = availableOptions.filter(t => !t.available);
                        if (unavailableOptions.length > 0) {
                            return `<div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 4px;">
                                ${unavailableOptions.map(t => t.reason).join(', ')}
                            </div>`;
                        }
                        return '';
                    })()}
                    ${routeCapacity.truckCount > 1 ? `
                    <div style="font-size: 0.85rem; color: var(--success); margin-top: 8px; font-weight: 600;">
                        ‚úì Using ${routeCapacity.truckCount} trucks (${routeCapacity.perTruck} carts each)
                    </div>
                    ` : ''}
                    
                    ${!routeCapacity.fits && routeCapacity.overflow > 0 ? `
                    <div style="margin-top: 15px; padding: 12px; background: #fef3c7; border-radius: 8px; border-left: 4px solid #f59e0b;">
                        <div style="font-weight: 600; color: #92400e; margin-bottom: 8px;">
                            ‚ö†Ô∏è Still ${routeCapacity.overflow} carts overflow
                        </div>
                        <div style="font-size: 0.9rem; color: #78350f; margin-bottom: 10px;">
                            Add more trucks to handle overflow:
                        </div>
                        <div id="add-truck-buttons-${route.key}" style="display: flex; gap: 8px; flex-wrap: wrap;">
                            ${(() => {
                                // Always show both buttons - allow adding multiple external and neighbor trucks
                                // Count how many of each are already added
                                const externalCount = assignedTruckIds.filter(id => id === 'external').length;
                                const neighborCount = assignedTruckIds.filter(id => id === 'neighbor').length;
                                
                                const externalText = typeof i18n !== 'undefined' ? i18n.t('cartLoading.addExternalTruck', 'Add External Truck') : 'Add External Truck';
                                const neighborText = typeof i18n !== 'undefined' ? i18n.t('cartLoading.addNeighborTruck', 'Add Neighbor\'s Truck') : 'Add Neighbor\'s Truck';
                                
                                // Always show both buttons - can add multiple
                                return `
                                    <button 
                                        type="button"
                                        class="btn btn-primary" 
                                        style="font-size: 0.9rem; padding: 8px 16px; cursor: pointer;"
                                        onclick="addTruckToRoute('${route.key}', 'external')">
                                        + ${externalText}${externalCount > 0 ? ` (${externalCount})` : ''}
                                    </button>
                                    <button 
                                        type="button"
                                        class="btn btn-primary" 
                                        style="font-size: 0.9rem; padding: 8px 16px; cursor: pointer;"
                                        onclick="addTruckToRoute('${route.key}', 'neighbor')">
                                        + ${neighborText}${neighborCount > 0 ? ` (${neighborCount})` : ''}
                                    </button>
                                `;
                            })()}
                        </div>
                    </div>
                    ` : ''}
                </div>
                
                <div class="truck-body">
                    <div class="truck-slots">
                        ${slots.map(slot => {
                            if (slot.type === 'truck-separator') {
                                return `<div class="route-separator-label" style="grid-column: 1 / -1; background: #f0f9ff; border: 2px solid ${route.color}; color: ${route.color}; padding: 8px; border-radius: 6px; margin: 8px 0; font-weight: 600; font-size: 0.9rem; text-align: center;">
                                    ‚îÄ‚îÄ ${slot.truckName} ‚îÄ‚îÄ
                                </div>`;
                            } else if (slot.type === 'standard') {
                                const clientInitial = slot.client ? slot.client.charAt(0).toUpperCase() : 'S';
                                const standardCartText = typeof i18n !== 'undefined' ? i18n.t('cartLoading.standardCart', 'Standard Cart') : 'Standard Cart';
                                const unknownText = typeof i18n !== 'undefined' ? i18n.t('common.unknown', 'Unknown') : 'Unknown';
                                const color = slot.color || route.color;
                                const hexToRgb = (hex) => {
                                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                                    return result ? {
                                        r: parseInt(result[1], 16),
                                        g: parseInt(result[2], 16),
                                        b: parseInt(result[3], 16)
                                    } : null;
                                };
                                const rgb = hexToRgb(color);
                                const darkerColor = rgb ? `rgb(${Math.max(0, rgb.r - 30)}, ${Math.max(0, rgb.g - 30)}, ${Math.max(0, rgb.b - 30)})` : color;
                                return `<div class="cart-slot filled-standard" 
                                         style="background: linear-gradient(135deg, ${color} 0%, ${darkerColor} 100%); border: 2px solid ${route.color}; border-left-width: 4px;" 
                                         title="${standardCartText} - ${slot.client || unknownText}">${clientInitial}</div>`;
                            } else if (slot.type === 'danish') {
                                const clientInitial = slot.client ? slot.client.charAt(0).toUpperCase() : 'D';
                                const danishCartText = typeof i18n !== 'undefined' ? i18n.t('cartLoading.danishCart', 'Danish Cart') : 'Danish Cart';
                                const unknownText = typeof i18n !== 'undefined' ? i18n.t('common.unknown', 'Unknown') : 'Unknown';
                                const color = slot.color || route.color;
                                const hexToRgb = (hex) => {
                                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                                    return result ? {
                                        r: parseInt(result[1], 16),
                                        g: parseInt(result[2], 16),
                                        b: parseInt(result[3], 16)
                                    } : null;
                                };
                                const rgb = hexToRgb(color);
                                const darkerColor = rgb ? `rgb(${Math.max(0, rgb.r - 30)}, ${Math.max(0, rgb.g - 30)}, ${Math.max(0, rgb.b - 30)})` : color;
                                return `<div class="cart-slot filled-danish" 
                                         style="background: linear-gradient(135deg, ${color} 0%, ${darkerColor} 100%); border: 2px solid ${route.color}; border-left-width: 4px;" 
                                         title="${danishCartText} - ${slot.client || unknownText}">${clientInitial}</div>`;
                            } else if (slot.type === 'overflow') {
                                const overflowText = typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow';
                                return `<div class="cart-slot overflow" style="border-color: ${route.color};" title="${overflowText}">!</div>`;
                            } else {
                                return '<div class="cart-slot empty" title="Empty"></div>';
                            }
                        }).join('')}
                    </div>
                </div>
                
                ${clients.length > 0 ? `
                <div class="client-legend">
                    <strong style="width: 100%; margin-bottom: 8px; display: block;">${typeof i18n !== 'undefined' ? i18n.t('cartLoading.clientColors', 'Client Colors') : 'Client Colors'}:</strong>
                    ${clients.map(client => {
                        const color = clientColorMap[client];
                        return `
                            <div class="client-legend-item">
                                <div class="client-color-box" style="background: ${color};"></div>
                                <span>${client}</span>
                            </div>
                        `;
                    }).join('')}
                </div>
                ` : ''}
                
                ${!routeCapacity.fits ? `
                <div class="info-box danger" style="margin-top: 15px;">
                    <strong>${typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow'}:</strong> ${routeCapacity.overflow} ${typeof i18n !== 'undefined' ? i18n.t('data.carts', 'carts') : 'carts'} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.dontFit', 'don\'t fit. Consider adding more trucks or external carrier.') : 'don\'t fit. Consider adding more trucks or external carrier.'}
                </div>
                ` : ''}
            `;
            
            return card;
        }
        
        // Prevent multiple simultaneous updates
        let isUpdating = false;
        
        function updateRouteTruck(routeKey, truckSelection) {
            // Prevent multiple simultaneous updates
            if (isUpdating) {
                console.log('Update already in progress, skipping...');
                return;
            }
            
            // Handle empty selection
            if (!truckSelection || truckSelection === '') {
                routeTruckAssignments[routeKey] = null;
                localStorage.setItem('zuidplas_route_truck_assignments', JSON.stringify(routeTruckAssignments));
                // Re-run optimization to update visualization
                if (cartLoadingOptimizer && orderManager && orderManager.orders && orderManager.orders.length > 0) {
                    isUpdating = true;
                    try {
                        const result = cartLoadingOptimizer.optimizeAssignment();
                        if (result.routeAnalysis) {
                            localStorage.setItem('zuidplas_route_analysis', JSON.stringify(result.routeAnalysis));
                        }
                        updateTruckVisualization(result);
                    } catch (error) {
                        console.error('Error updating visualization:', error);
                    } finally {
                        isUpdating = false;
                    }
                }
                return;
            }
            
            // Check if truck combination is available
            const availableOptions = getAvailableTruckOptions(routeKey);
            const selectedOption = availableOptions.find(t => t.id === truckSelection);
            
            if (!selectedOption || !selectedOption.available) {
                alert(typeof i18n !== 'undefined' 
                    ? i18n.t('cartLoading.truckUnavailable', 'This truck combination is unavailable due to time conflict with another route.')
                    : 'This truck combination is unavailable due to time conflict with another route.');
                // Reset to previous selection
                const selector = document.getElementById(`truck-selector-${routeKey}`);
                if (selector) {
                    selector.value = routeTruckAssignments[routeKey] || '';
                }
                return;
            }
            
            routeTruckAssignments[routeKey] = truckSelection;
            
            // Save to localStorage for Truck Management page
            localStorage.setItem('zuidplas_route_truck_assignments', JSON.stringify(routeTruckAssignments));
            
            // Also save route analysis for Truck Management to show cart counts
            if (cartLoadingOptimizer && orderManager && orderManager.orders && orderManager.orders.length > 0) {
                isUpdating = true;
                try {
                    const result = cartLoadingOptimizer.optimizeAssignment();
                    // Save route analysis
                    if (result.routeAnalysis) {
                        localStorage.setItem('zuidplas_route_analysis', JSON.stringify(result.routeAnalysis));
                    }
                    // Update visualization (will refresh all route cards with updated availability)
                    updateTruckVisualization(result);
                } catch (error) {
                    console.error('Error updating truck visualization:', error);
                    alert('Error updating visualization. Please refresh the page.');
                } finally {
                    isUpdating = false;
                }
            }
        }
        
        function addTruckToRoute(routeKey, newTruckId) {
            // Get current truck assignment
            const currentAssignment = routeTruckAssignments[routeKey] || 'truck1';
            const currentTrucks = parseTruckAssignment(currentAssignment);
            
            // Allow multiple external and neighbor trucks - don't check if already added
            // Only check for truck1 and truck2 (can't have multiple of same own truck)
            if ((newTruckId === 'truck1' || newTruckId === 'truck2') && currentTrucks.includes(newTruckId)) {
                alert(typeof i18n !== 'undefined' 
                    ? i18n.t('cartLoading.truckAlreadyAdded', 'This truck is already assigned to this route.')
                    : 'This truck is already assigned to this route.');
                return;
            }
            
            // Check if truck is available (not conflicting)
            const availableOptions = getAvailableTruckOptions(routeKey);
            const truckOption = availableOptions.find(t => t.id === newTruckId);
            
            if (!truckOption || !truckOption.available) {
                alert(typeof i18n !== 'undefined' 
                    ? i18n.t('cartLoading.truckUnavailable', 'This truck is unavailable due to time conflict with another route.')
                    : 'This truck is unavailable due to time conflict with another route.');
                return;
            }
            
            // Add new truck to assignment
            const newAssignment = currentTrucks.concat([newTruckId]).join('+');
            routeTruckAssignments[routeKey] = newAssignment;
            
            // Save to localStorage for Truck Management page
            localStorage.setItem('zuidplas_route_truck_assignments', JSON.stringify(routeTruckAssignments));
            
            // Also save route analysis
            if (cartLoadingOptimizer && orderManager && orderManager.orders && orderManager.orders.length > 0) {
                const result = cartLoadingOptimizer.optimizeAssignment();
                if (result.routeAnalysis) {
                    localStorage.setItem('zuidplas_route_analysis', JSON.stringify(result.routeAnalysis));
                }
            }
            
            // Update dropdown to show new combination
            const selector = document.getElementById(`truck-selector-${routeKey}`);
            if (selector) {
                // Create custom option if it doesn't exist
                const optionExists = Array.from(selector.options).some(opt => opt.value === newAssignment);
                if (!optionExists) {
                    const option = document.createElement('option');
                    option.value = newAssignment;
                    const truckNames = {
                        truck1: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck1', 'Truck 1') : 'Truck 1',
                        truck2: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck2', 'Truck 2') : 'Truck 2',
                        neighbor: typeof i18n !== 'undefined' ? i18n.t('cartLoading.neighborTruck', 'Neighbor\'s Truck') : 'Neighbor\'s Truck',
                        external: typeof i18n !== 'undefined' ? i18n.t('cartLoading.externalTruck', 'External Truck') : 'External Truck'
                    };
                    const allTruckIds = parseTruckAssignment(newAssignment);
                    option.textContent = allTruckIds.map(id => truckNames[id] || id).join(' + ');
                    selector.appendChild(option);
                }
                selector.value = newAssignment;
            }
            
            // Re-run optimization with new truck assignment
            if (cartLoadingOptimizer && orderManager && orderManager.orders && orderManager.orders.length > 0) {
                const result = cartLoadingOptimizer.optimizeAssignment();
                // Update visualization (will refresh all route cards with updated availability)
                updateTruckVisualization(result);
            }
        }
        
        // Make it global
        window.addTruckToRoute = addTruckToRoute;
        
        // Make it global
        window.updateRouteTruck = updateRouteTruck;

        // Generate unique color for each client
        function getClientColor(clientName, clientIndex) {
            const colors = [
                '#3b82f6', '#8b5cf6', '#10b981', '#f59e0b', '#ef4444',
                '#06b6d4', '#ec4899', '#84cc16', '#f97316', '#6366f1',
                '#14b8a6', '#a855f7', '#22c55e', '#eab308', '#f43f5e'
            ];
            return colors[clientIndex % colors.length];
        }

        function createTruckCard(truckName, truckData, capacity, expectedRoutes, routeAnalysis = {}) {
            const card = document.createElement('div');
            card.className = 'truck-card';
            
            const routes = Array.from(truckData.routes);
            
            // Calculate route-by-route status
            let routeStatuses = [];
            let hasOverflow = false;
            
            expectedRoutes.forEach(routeName => {
                const routeInfo = routeAnalysis[routeName];
                if (routeInfo) {
                    // CRITICAL: Use route's fits status (from dashboard calculation)
                    // If route has overflow, truck shows overflow
                    const routeFits = routeInfo.fits !== undefined ? routeInfo.fits : (routeInfo.totalCarts <= routeInfo.max);
                    if (!routeFits) hasOverflow = true;
                    
                    // Get route display name
                    const routeDisplayNames = {
                        rijnsburg: typeof i18n !== 'undefined' ? i18n.t('routes.rijnsburg', 'Rijnsburg') : 'Rijnsburg',
                        aalsmeer: typeof i18n !== 'undefined' ? i18n.t('routes.aalsmeer', 'Aalsmeer') : 'Aalsmeer',
                        naaldwijk: typeof i18n !== 'undefined' ? i18n.t('routes.naaldwijk', 'Naaldwijk') : 'Naaldwijk'
                    };
                    
                    routeStatuses.push({
                        name: routeName,
                        displayName: routeDisplayNames[routeName] || routeName,
                        fits: routeFits,
                        routeCarts: routeInfo.totalCarts, // This route's cart count
                        used: routeInfo.used, // This route's equivalent carts
                        max: routeInfo.max, // This route's max capacity
                        overflow: routeInfo.overflow,
                        totalCarts: routeInfo.totalCarts,
                        danishCount: routeInfo.danishCount,
                        standardCount: routeInfo.standardCount
                    });
                }
            });
            
            const statusClass = hasOverflow ? 'danger' : 'success';
            const statusIcon = hasOverflow ? '‚ùå' : '‚úÖ';
            const statusText = hasOverflow ? (typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow') : (typeof i18n !== 'undefined' ? i18n.t('status.fits', 'Fits') : 'Fits');
            
            // Get all unique clients from carts
            const clients = [...new Set(truckData.carts.map(cart => cart.client || 'Unknown'))];
            const clientColorMap = {};
            clients.forEach((client, index) => {
                clientColorMap[client] = getClientColor(client, index);
            });
            
            // Group carts by route for clear separation
            const cartsByRoute = {};
            expectedRoutes.forEach(routeName => {
                cartsByRoute[routeName] = truckData.carts.filter(cart => cart.route === routeName);
            });
            
            // Create route-separated cart slots
            const routeSlots = [];
            
            expectedRoutes.forEach((routeName, routeIndex) => {
                const routeCarts = cartsByRoute[routeName] || [];
                const routeDisplayNames = {
                    rijnsburg: typeof i18n !== 'undefined' ? i18n.t('routes.rijnsburg', 'Rijnsburg') : 'Rijnsburg',
                    aalsmeer: typeof i18n !== 'undefined' ? i18n.t('routes.aalsmeer', 'Aalsmeer') : 'Aalsmeer',
                    naaldwijk: typeof i18n !== 'undefined' ? i18n.t('routes.naaldwijk', 'Naaldwijk') : 'Naaldwijk'
                };
                const routeTime = routeName === 'rijnsburg' ? '09:00' : routeName === 'aalsmeer' ? '10:00' : '11:00';
                const routeLabel = `${routeDisplayNames[routeName]} (${routeTime})`;
                
                // Add route separator label (except for first route)
                if (routeIndex > 0) {
                    routeSlots.push({
                        type: 'route-separator',
                        route: routeName,
                        label: routeLabel
                    });
                }
                
                // Process carts for this route
                routeCarts.forEach(cart => {
                    const clientColor = clientColorMap[cart.client || 'Unknown'];
                    const cartType = cart.type || (cart.cartType || 'standard');
                    routeSlots.push({ 
                        type: cartType, 
                        client: cart.client || 'Unknown',
                        color: clientColor,
                        route: cart.route
                    });
                });
                
                // Add empty slots for this route if needed (only for visualization clarity)
                const routeInfo = routeAnalysis[routeName];
                const routeMaxCapacity = routeInfo ? routeInfo.max : capacity.max;
                const routeCartsCount = routeCarts.length;
                const routeEmptySlots = Math.max(0, routeMaxCapacity - routeCartsCount);
                
                // Only add a few empty slots as visual separator, not all
                if (routeEmptySlots > 0 && routeIndex < expectedRoutes.length - 1) {
                    // Add 1-2 empty slots as visual gap between routes
                    for (let i = 0; i < Math.min(2, routeEmptySlots); i++) {
                        routeSlots.push({ type: 'empty', route: routeName });
                    }
                }
            });

            // Build route breakdown HTML with color-coded sections and cost impact
            let routeBreakdownHTML = '';
            if (routeStatuses.length > 0) {
                routeBreakdownHTML = '<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border);">';
                routeStatuses.forEach(routeStatus => {
                    const routeStatusClass = routeStatus.fits ? 'success' : 'danger';
                    const routeStatusIcon = routeStatus.fits ? '‚úÖ' : '‚ö†Ô∏è';
                    
                    // Calculate cost impact
                    const routeCost = calculateRouteCost(routeStatus);
                    const costImpactHTML = routeCost > 0 
                        ? `<span class="cost-impact negative">+‚Ç¨${routeCost} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.extraCost', 'extra cost') : 'extra cost'}</span>`
                        : '';
                    
                    // Get route section class for color coding
                    const routeSectionClass = routeStatus.name;
                    
                    routeBreakdownHTML += `
                        <div class="route-section ${routeSectionClass}">
                            <div class="route-section-header">
                                <strong>${routeStatus.displayName}</strong>
                                <span class="badge ${routeStatusClass}" style="margin-left: 8px;">${routeStatusIcon} ${routeStatus.fits ? (typeof i18n !== 'undefined' ? i18n.t('status.fits', 'Fits') : 'Fits') : (typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow')}</span>
                                ${costImpactHTML}
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.9rem;">
                                <div><strong>${routeStatus.totalCarts}</strong> ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.totalCarts', 'carts') : 'carts'}</div>
                                <div style="color: var(--text-secondary);">
                                    ${routeStatus.totalCarts} / ${routeStatus.max} ${typeof i18n !== 'undefined' ? i18n.t('status.capacity', 'capacity') : 'capacity'}
                                </div>
                                ${!routeStatus.fits ? `<div style="color: var(--danger); font-weight: 600;">+${routeStatus.overflow} ${typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'overflow') : 'overflow'}</div>` : ''}
                            </div>
                        </div>
                    `;
                });
                routeBreakdownHTML += '</div>';
            }
            
            // Add loading sequence for this truck
            const loadingSequences = calculateLoadingSequence(truckData, routeAnalysis);
            let loadingSequenceHTML = '';
            Object.keys(loadingSequences).forEach(routeName => {
                const sequence = loadingSequences[routeName];
                if (sequence.length === 0) return;
                
                const routeDisplayNames = {
                    rijnsburg: typeof i18n !== 'undefined' ? i18n.t('routes.rijnsburg', 'Rijnsburg') : 'Rijnsburg',
                    aalsmeer: typeof i18n !== 'undefined' ? i18n.t('routes.aalsmeer', 'Aalsmeer') : 'Aalsmeer',
                    naaldwijk: typeof i18n !== 'undefined' ? i18n.t('routes.naaldwijk', 'Naaldwijk') : 'Naaldwijk'
                };
                
                const sequenceId = `loading-seq-${routeName}-${Date.now()}`;
                const showMoreId = `show-more-${routeName}-${Date.now()}`;
                const fullListId = `full-list-${routeName}-${Date.now()}`;
                
                loadingSequenceHTML += `
                    <div class="loading-sequence">
                        <div class="loading-sequence-title">
                            üì¶ ${routeDisplayNames[routeName]} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.loadingSequence', 'Loading Sequence') : 'Loading Sequence'}
                        </div>
                        <div class="loading-sequence-help" style="background: #f0f9ff; padding: 12px; border-radius: 8px; margin: 10px 0; border-left: 4px solid #3b82f6;">
                            <strong style="color: #1e40af;">üìã ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.loadingSequenceHelp', 'How to Load:') : 'How to Load:'}</strong><br>
                            <span style="font-size: 0.9rem; color: #1e3a8a;">
                            ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.lastDeliveryFirst', 'Last delivery first (goes on top)') : 'Last delivery first (goes on top)'}, 
                            ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.firstDeliveryLast', 'first delivery last (goes at bottom)') : 'first delivery last (goes at bottom)'}.<br>
                            <em>${typeof i18n !== 'undefined' ? i18n.t('cartLoading.loadingSequenceExplanation', 'Why? So when unloading, first delivery is on top and easy to access!') : 'Why? So when unloading, first delivery is on top and easy to access!'}</em>
                            </span>
                        </div>
                        <div class="loading-steps" id="${sequenceId}">
                            ${sequence.slice(0, 10).map(item => `
                                <div class="loading-step" title="${item.client} - Step ${item.step}">
                                    <span class="loading-step-number">${item.step}</span>
                                    <span>${item.client.charAt(0).toUpperCase()}</span>
                                </div>
                            `).join('')}
                            ${sequence.length > 10 ? `
                                <button type="button" class="loading-more-btn" onclick="showFullLoadingSequence('${fullListId}', '${showMoreId}', ${sequence.length - 10})">
                                    +${sequence.length - 10} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.more', 'more') : 'more'}
                                </button>
                            ` : ''}
                        </div>
                        ${sequence.length > 10 ? `
                            <div class="loading-full-list" id="${fullListId}" style="display: none;">
                                ${sequence.map(item => `
                                    <div class="loading-full-item">
                                        <span class="loading-step-number">${item.step}</span>
                                        <span><strong>${item.client}</strong></span>
                                        <span style="color: var(--text-secondary); font-size: 0.75rem;">(${item.type === 'danish' ? (typeof i18n !== 'undefined' ? i18n.t('cartLoading.danishCart', 'Danish Cart') : 'Danish Cart') : (typeof i18n !== 'undefined' ? i18n.t('cartLoading.standardCart', 'Standard Cart') : 'Standard Cart')})</span>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            if (loadingSequenceHTML) {
                routeBreakdownHTML += loadingSequenceHTML;
            }
            
            card.innerHTML = `
                <div class="truck-header">
                    <div>
                        <h2 style="margin: 0;">${truckName}</h2>
                        <div style="margin-top: 8px;">
                            <span class="badge ${statusClass}">${statusIcon} ${statusText}</span>
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 0.9rem; color: var(--text-secondary);">
                            ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.routesOnTruck', 'Routes on this truck') : 'Routes on this truck'}: ${routes.length}
                        </div>
                    </div>
                </div>
                ${routeBreakdownHTML}

                <div class="truck-body">
                    <div class="truck-slots">
                        ${routeSlots.map(slot => {
                            if (slot.type === 'standard') {
                                const clientInitial = slot.client ? slot.client.charAt(0).toUpperCase() : 'S';
                                const standardCartText = typeof i18n !== 'undefined' ? i18n.t('cartLoading.standardCart', 'Standard Cart') : 'Standard Cart';
                                const unknownText = typeof i18n !== 'undefined' ? i18n.t('common.unknown', 'Unknown') : 'Unknown';
                                const color = slot.color || '#3b82f6';
                                // Calculate darker shade for gradient
                                const hexToRgb = (hex) => {
                                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                                    return result ? {
                                        r: parseInt(result[1], 16),
                                        g: parseInt(result[2], 16),
                                        b: parseInt(result[3], 16)
                                    } : null;
                                };
                                const rgb = hexToRgb(color);
                                const darkerColor = rgb ? `rgb(${Math.max(0, rgb.r - 30)}, ${Math.max(0, rgb.g - 30)}, ${Math.max(0, rgb.b - 30)})` : color;
                                return `<div class="cart-slot filled-standard" 
                                         style="background: linear-gradient(135deg, ${color} 0%, ${darkerColor} 100%); border-color: ${color};" 
                                         title="${standardCartText} - ${slot.client || unknownText}">${clientInitial}</div>`;
                            } else if (slot.type === 'danish') {
                                const clientInitial = slot.client ? slot.client.charAt(0).toUpperCase() : 'D';
                                const danishCartText = typeof i18n !== 'undefined' ? i18n.t('cartLoading.danishCart', 'Danish Cart') : 'Danish Cart';
                                const unknownText = typeof i18n !== 'undefined' ? i18n.t('common.unknown', 'Unknown') : 'Unknown';
                                const color = slot.color || '#8b5cf6';
                                const hexToRgb = (hex) => {
                                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                                    return result ? {
                                        r: parseInt(result[1], 16),
                                        g: parseInt(result[2], 16),
                                        b: parseInt(result[3], 16)
                                    } : null;
                                };
                                const rgb = hexToRgb(color);
                                const darkerColor = rgb ? `rgb(${Math.max(0, rgb.r - 30)}, ${Math.max(0, rgb.g - 30)}, ${Math.max(0, rgb.b - 30)})` : color;
                                return `<div class="cart-slot filled-danish" 
                                         style="background: linear-gradient(135deg, ${color} 0%, ${darkerColor} 100%); border-color: ${color};" 
                                         title="${danishCartText} - ${slot.client || unknownText}">${clientInitial}</div>`;
                            } else if (slot.type === 'overflow') {
                                const overflowText = typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow';
                                return `<div class="cart-slot overflow" title="${overflowText}">!</div>`;
                            } else {
                                return '<div class="cart-slot empty" title="Empty"></div>';
                            }
                        }).join('')}
                    </div>
                </div>
                
                ${clients.length > 0 ? `
                <div class="client-legend">
                    <strong style="width: 100%; margin-bottom: 8px; display: block;">${typeof i18n !== 'undefined' ? i18n.t('cartLoading.clientColors', 'Client Colors') : 'Client Colors'}:</strong>
                    ${clients.map(client => {
                        const color = clientColorMap[client];
                        return `
                            <div class="client-legend-item">
                                <div class="client-color-box" style="background: ${color};"></div>
                                <span>${client}</span>
                            </div>
                        `;
                    }).join('')}
                </div>
                ` : ''}

                <div class="capacity-indicator">
                    <div class="capacity-bar">
                        <div class="capacity-fill ${capacity.utilization > 90 ? 'danger' : capacity.utilization > 75 ? 'warning' : ''}" 
                             style="width: ${capacity.utilization}%"></div>
                    </div>
                    <div style="font-size: 0.9rem; color: var(--text-secondary);">
                        ${capacity.standard} ${capacity.standard === 1 
                            ? (typeof i18n !== 'undefined' ? i18n.t('cartLoading.standardCart', 'Standard Cart') : 'Standard Cart')
                            : (typeof i18n !== 'undefined' ? i18n.t('cartLoading.standardCarts', 'Standard Carts') : 'Standard Carts')} + 
                        ${capacity.danish} ${capacity.danish === 1 
                            ? (typeof i18n !== 'undefined' ? i18n.t('cartLoading.danishCart', 'Danish Cart') : 'Danish Cart')
                            : (typeof i18n !== 'undefined' ? i18n.t('cartLoading.danishCarts', 'Danish Carts') : 'Danish Carts')}
                    </div>
                </div>

                <div class="route-assignment">
                    <strong>Routes:</strong>
                    ${routes.map(route => {
                        const routeName = route === 'rijnsburg' ? 'Rijnsburg (09:00)' :
                                         route === 'aalsmeer' ? 'Aalsmeer (10:00)' :
                                         route === 'naaldwijk' ? 'Naaldwijk (11:00)' : route;
                        const routeClass = `route-${route}`;
                        return `<span class="route-badge ${routeClass}">${routeName}</span>`;
                    }).join('')}
                    ${routes.length === 0 ? '<span style="color: var(--text-secondary);">No routes assigned</span>' : ''}
                </div>

                ${capacity.overflow > 0 ? `
                <div class="info-box danger" style="margin-top: 15px;">
                    <strong>${typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow'}:</strong> ${capacity.overflow} ${typeof i18n !== 'undefined' ? i18n.t('data.carts', 'carts') : 'carts'} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.dontFit', 'don\'t fit. Consider external carrier or neighbor\'s truck.') : 'don\'t fit. Consider external carrier or neighbor\'s truck.'}
                </div>
                ` : ''}
            `;

            return card;
        }

        function updateCartList(allCarts) {
            const container = document.getElementById('cart-list-by-route');
            container.innerHTML = '';

            const cartsByRoute = {
                rijnsburg: [],
                aalsmeer: [],
                naaldwijk: []
            };

            allCarts.forEach(cart => {
                if (cartsByRoute[cart.route]) {
                    cartsByRoute[cart.route].push(cart);
                }
            });

            // Get truck names mapping
            const truckNames = {
                truck1: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck1', 'Truck 1') : 'Truck 1',
                truck2: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck2', 'Truck 2') : 'Truck 2',
                neighbor: typeof i18n !== 'undefined' ? i18n.t('cartLoading.neighborTruck', 'Neighbor\'s Truck') : 'Neighbor\'s Truck',
                external: typeof i18n !== 'undefined' ? i18n.t('cartLoading.externalTruck', 'External Truck') : 'External Truck'
            };

            Object.keys(ROUTES).forEach(routeKey => {
                const route = ROUTES[routeKey];
                const carts = cartsByRoute[routeKey] || [];
                
                // Get the actual selected truck assignment for this route
                const assignedTrucksStr = routeTruckAssignments[routeKey] || null;
                let truckDisplayName = typeof i18n !== 'undefined' ? i18n.t('cartLoading.notAssigned', 'Not Assigned') : 'Not Assigned';
                
                if (assignedTrucksStr) {
                    const assignedTruckIds = parseTruckAssignment(assignedTrucksStr);
                    // If only one truck, show its name. If multiple, show "Truck 1 + Truck 2" format
                    if (assignedTruckIds.length === 1) {
                        truckDisplayName = truckNames[assignedTruckIds[0]] || assignedTruckIds[0];
                    } else {
                        // Multiple trucks - show combined name
                        truckDisplayName = assignedTruckIds.map(id => truckNames[id] || id).join(' + ');
                    }
                }
                
                const routeCard = document.createElement('div');
                routeCard.className = 'card';
                routeCard.style.marginBottom = '20px';
                
                routeCard.innerHTML = `
                    <h3>Route ${route.id}: ${route.name} (${route.departureTime})</h3>
                    <div class="cart-list">
                        ${carts.length > 0 ? carts.map(cart => {
                            const cartTypeText = cart.type === 'danish' 
                                ? (typeof i18n !== 'undefined' ? i18n.t('cartLoading.danishCart', 'Danish Cart') : 'Danish Cart')
                                : (typeof i18n !== 'undefined' ? i18n.t('cartLoading.standardCart', 'Standard Cart') : 'Standard Cart');
                            return `
                                <div class="cart-item ${cart.type}">
                                    <div>
                                        <strong>${cart.client}</strong>
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 4px;">
                                            ${cartTypeText}
                                        </div>
                                    </div>
                                    <div>
                                        <span class="badge ${cart.type === 'danish' ? 'primary' : 'info'}">
                                            ${cart.type === 'danish' ? 'D' : 'S'}
                                        </span>
                                    </div>
                                </div>
                            `;
                        }).join('') : '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">No carts for this route</div>'}
                    </div>
                `;
                
                container.appendChild(routeCard);
            });
        }

        function updateSummaryStats(result) {
            // CRITICAL: Use CACHED cart count from Dashboard, not allCarts.length!
            let totalCartsFromCache = 0;
            if (window.CartCalculation && window.CartCalculation.getGlobalOrdersAndCarts) {
                const globalData = window.CartCalculation.getGlobalOrdersAndCarts(); // NO forceRefresh - only reads cache!
                totalCartsFromCache = globalData.cartResult.total || 0;
                console.log(`‚úÖ updateSummaryStats: Using cached cart count: ${totalCartsFromCache} carts`);
            } else {
                // Fallback to result.allCarts.length if cache not available
                totalCartsFromCache = result.allCarts ? result.allCarts.length : 0;
                console.warn(`‚ö†Ô∏è updateSummaryStats: Cache not available, using allCarts.length: ${totalCartsFromCache}`);
            }
            
            const allCarts = result.allCarts;
            const truck1Capacity = cartLoadingOptimizer.getTruckCapacity('truck1');
            const truck2Capacity = cartLoadingOptimizer.getTruckCapacity('truck2');
            const totalOverflow = truck1Capacity.overflow + truck2Capacity.overflow;
            const routesCovered = new Set([...result.truck1.routes, ...result.truck2.routes]).size;

            // Use cached cart count (from Dashboard) instead of allCarts.length
            document.getElementById('total-carts').textContent = totalCartsFromCache;
            document.getElementById('carts-assigned').textContent = result.truck1.carts.length + result.truck2.carts.length;
            document.getElementById('overflow-count').textContent = totalOverflow;
            document.getElementById('routes-covered').textContent = `${routesCovered}/3`;
        }

        // Feature 1: Route Timeline Visualization
        function updateRouteTimeline(result) {
            const timelineContainer = document.querySelector('#route-timeline .timeline-container');
            const timelineDiv = document.getElementById('route-timeline');
            
            if (!timelineContainer) {
                if (timelineDiv) timelineDiv.style.display = 'none';
                return;
            }
            
            // CRITICAL: Get cart counts from SINGLE SOURCE OF TRUTH
            let cartResult = null;
            if (window.CartCalculation && window.CartCalculation.getGlobalOrdersAndCarts) {
                const globalData = window.CartCalculation.getGlobalOrdersAndCarts();
                cartResult = globalData.cartResult;
                console.log('‚úÖ Route Timeline: Using cart counts from SINGLE SOURCE');
            }
            
            if (!cartResult) {
                if (timelineDiv) timelineDiv.style.display = 'none';
                return;
            }
            
            timelineDiv.style.display = 'block';
            
            const routes = [
                { key: 'rijnsburg', time: '09:00', name: typeof i18n !== 'undefined' ? i18n.t('routes.rijnsburg', 'Rijnsburg') : 'Rijnsburg', class: 'route1', routeName: 'Rijnsburg' },
                { key: 'aalsmeer', time: '10:00', name: typeof i18n !== 'undefined' ? i18n.t('routes.aalsmeer', 'Aalsmeer') : 'Aalsmeer', class: 'route2', routeName: 'Aalsmeer' },
                { key: 'naaldwijk', time: '11:00', name: typeof i18n !== 'undefined' ? i18n.t('routes.naaldwijk', 'Naaldwijk') : 'Naaldwijk', class: 'route3', routeName: 'Naaldwijk' }
            ];
            
            // Determine which truck handles which route
            const truck1Routes = result.truck1 ? Array.from(result.truck1.routes) : [];
            const truck2Routes = result.truck2 ? Array.from(result.truck2.routes) : [];
            
            timelineContainer.innerHTML = '<div class="timeline-connector"></div>';
            
            routes.forEach(route => {
                // Get cart count from SINGLE SOURCE (cartResult)
                const carts = cartResult.byRoute[route.routeName] || 0;
                const maxCapacity = 17;
                const fits = carts <= maxCapacity;
                
                // Determine truck assignment
                const isTruck1 = truck1Routes.includes(route.key);
                const truckName = isTruck1 
                    ? (typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck1', 'Truck 1') : 'Truck 1')
                    : (truck2Routes.includes(route.key) 
                        ? (typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck2', 'Truck 2') : 'Truck 2')
                        : (typeof i18n !== 'undefined' ? i18n.t('cartLoading.notAssigned', 'Not Assigned') : 'Not Assigned'));
                
                const statusIcon = fits ? '‚úÖ' : '‚ö†Ô∏è';
                const statusText = fits 
                    ? (typeof i18n !== 'undefined' ? i18n.t('status.fits', 'Fits') : 'Fits')
                    : (typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow');
                
                const point = document.createElement('div');
                point.className = 'timeline-point';
                point.innerHTML = `
                    <div class="timeline-time ${route.class}">${route.time}</div>
                    <div class="timeline-route-info">
                        <strong>${route.name}</strong>
                        <div class="timeline-truck">${truckName}</div>
                        <div style="margin-top: 5px;">
                            <span>${statusIcon} ${statusText}</span>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 4px;">
                                ${carts} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.totalCarts', 'carts') : 'carts'}
                            </div>
                        </div>
                    </div>
                `;
                timelineContainer.appendChild(point);
            });
        }

        // Feature 2 & 3: Color-Coded Route Sections & Cost Impact
        function calculateRouteCost(routeInfo) {
            if (!routeInfo || routeInfo.fits) return 0;
            
            // Cost constants (matching optimizer.js)
            const OWN_TRUCK_COST = 150;
            const EXTERNAL_CARRIER_PER_CART = 25;
            
            // If overflow, calculate external carrier cost
            return routeInfo.overflow * EXTERNAL_CARRIER_PER_CART;
        }

        // Feature 4: Generate Alternative Assignments
        function generateAlternatives(result) {
            const alternativesToggle = document.getElementById('alternatives-toggle');
            const alternativesContainer = document.getElementById('alternatives-container');
            
            if (!result.routeAnalysis) {
                if (alternativesToggle) alternativesToggle.style.display = 'none';
                return;
            }
            
            alternativesToggle.style.display = 'block';
            
            // Generate alternative scenarios
            const alternatives = [];
            const route1 = result.routeAnalysis.rijnsburg;
            const route2 = result.routeAnalysis.aalsmeer;
            const route3 = result.routeAnalysis.naaldwijk;
            
            // Alternative 1: Current (default)
            alternatives.push({
                id: 'current',
                name: typeof i18n !== 'undefined' ? i18n.t('cartLoading.currentAssignment', 'Current Assignment') : 'Current Assignment',
                description: typeof i18n !== 'undefined' ? i18n.t('cartLoading.currentDesc', 'Truck 1: Route 1 + Route 3, Truck 2: Route 2') : 'Truck 1: Route 1 + Route 3, Truck 2: Route 2',
                cost: calculateTotalCost(result.routeAnalysis),
                recommended: true,
                routes: {
                    truck1: ['rijnsburg', 'naaldwijk'],
                    truck2: ['aalsmeer']
                }
            });
            
            // Alternative 2: Swap Route 3 to Truck 2 (if Route 2 fits)
            if (route2 && route2.fits && route3 && route3.totalCarts <= 17) {
                alternatives.push({
                    id: 'swap-route3',
                    name: typeof i18n !== 'undefined' ? i18n.t('cartLoading.alternative1', 'Alternative: Route 3 on Truck 2') : 'Alternative: Route 3 on Truck 2',
                    description: typeof i18n !== 'undefined' ? i18n.t('cartLoading.alt1Desc', 'Truck 1: Route 1 only, Truck 2: Route 2 + Route 3') : 'Truck 1: Route 1 only, Truck 2: Route 2 + Route 3',
                    cost: calculateTotalCost(result.routeAnalysis, { route3ToTruck2: true }),
                    recommended: false,
                    routes: {
                        truck1: ['rijnsburg'],
                        truck2: ['aalsmeer', 'naaldwijk']
                    }
                });
            }
            
            // Store alternatives for toggle function
            window.currentAlternatives = alternatives;
        }

        function calculateTotalCost(routeAnalysis, options = {}) {
            const OWN_TRUCK_COST = 150;
            const EXTERNAL_CARRIER_PER_CART = 25;
            
            let cost = 0;
            
            if (options.route3ToTruck2) {
                // Alternative: Route 3 on Truck 2
                cost += OWN_TRUCK_COST; // Truck 1: Route 1
                cost += OWN_TRUCK_COST; // Truck 2: Route 2 + Route 3
                
                // Check overflow
                const route1Overflow = routeAnalysis.rijnsburg ? (routeAnalysis.rijnsburg.overflow || 0) : 0;
                const route2Overflow = routeAnalysis.aalsmeer ? (routeAnalysis.aalsmeer.overflow || 0) : 0;
                const route3Overflow = routeAnalysis.naaldwijk ? (routeAnalysis.naaldwijk.overflow || 0) : 0;
                cost += (route1Overflow + route2Overflow + route3Overflow) * EXTERNAL_CARRIER_PER_CART;
            } else {
                // Default: Route 3 on Truck 1
                cost += OWN_TRUCK_COST; // Truck 1: Route 1 + Route 3
                cost += OWN_TRUCK_COST; // Truck 2: Route 2
                
                // Check overflow
                const route1Overflow = routeAnalysis.rijnsburg ? (routeAnalysis.rijnsburg.overflow || 0) : 0;
                const route2Overflow = routeAnalysis.aalsmeer ? (routeAnalysis.aalsmeer.overflow || 0) : 0;
                const route3Overflow = routeAnalysis.naaldwijk ? (routeAnalysis.naaldwijk.overflow || 0) : 0;
                cost += (route1Overflow + route2Overflow + route3Overflow) * EXTERNAL_CARRIER_PER_CART;
            }
            
            return cost;
        }

        function toggleAlternatives() {
            const container = document.getElementById('alternatives-container');
            const button = document.querySelector('#alternatives-toggle button');
            
            if (!container || !window.currentAlternatives) return;
            
            if (container.style.display === 'none' || !container.style.display) {
                container.style.display = 'grid';
                if (button) {
                    button.textContent = typeof i18n !== 'undefined' 
                        ? i18n.t('cartLoading.hideAlternatives', 'Hide Alternatives')
                        : 'Hide Alternatives';
                }
                
                container.innerHTML = '';
                window.currentAlternatives.forEach(alt => {
                    const card = document.createElement('div');
                    card.className = `alternative-card ${alt.recommended ? 'recommended' : ''}`;
                    card.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div>
                                <h3 style="margin: 0; font-size: 1rem;">${alt.name}</h3>
                                ${alt.recommended ? `<span class="badge success" style="margin-top: 5px;">${typeof i18n !== 'undefined' ? i18n.t('cartLoading.recommended', 'Recommended') : 'Recommended'}</span>` : ''}
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 1.2rem; font-weight: 700; color: var(--primary);">‚Ç¨${alt.cost}</div>
                            </div>
                        </div>
                        <p style="font-size: 0.9rem; color: var(--text-secondary); margin: 10px 0;">${alt.description}</p>
                    `;
                    container.appendChild(card);
                });
            } else {
                container.style.display = 'none';
                if (button) {
                    button.textContent = typeof i18n !== 'undefined' 
                        ? i18n.t('cartLoading.showAlternatives', 'Show Alternative Assignments')
                        : 'Show Alternative Assignments';
                }
            }
        }

        // Feature 5: Loading Sequence Optimization
        function calculateLoadingSequence(truckData, routeAnalysis) {
            const sequences = {};
            const routes = Array.from(truckData.routes);
            
            routes.forEach(routeName => {
                const routeCarts = truckData.carts.filter(cart => cart.route === routeName);
                const routeInfo = routeAnalysis[routeName];
                
                if (routeCarts.length === 0) return;
                
                // Sort carts: Last delivery first (LIFO - Last In First Out)
                // Group by client, then sort by delivery location/priority
                const sortedCarts = [...routeCarts].sort((a, b) => {
                    // Danish carts might need special handling
                    if (a.type === 'danish' && b.type !== 'danish') return 1;
                    if (a.type !== 'danish' && b.type === 'danish') return -1;
                    return 0;
                });
                
                sequences[routeName] = sortedCarts.map((cart, index) => ({
                    step: index + 1,
                    client: cart.client || 'Unknown',
                    type: cart.type || 'standard',
                    route: routeName
                }));
            });
            
            return sequences;
        }

        // Show full loading sequence when "+X more" is clicked
        function showFullLoadingSequence(fullListId, showMoreId, remainingCount) {
            const fullList = document.getElementById(fullListId);
            const showMoreBtn = document.querySelector(`button[onclick*="${fullListId}"]`);
            
            if (!fullList) return;
            
            if (fullList.style.display === 'none' || !fullList.style.display) {
                fullList.style.display = 'block';
                if (showMoreBtn) {
                    showMoreBtn.textContent = typeof i18n !== 'undefined' 
                        ? i18n.t('cartLoading.hideFullList', 'Hide Full List')
                        : 'Hide Full List';
                }
            } else {
                fullList.style.display = 'none';
                if (showMoreBtn) {
                    showMoreBtn.textContent = `+${remainingCount} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.more', 'more') : 'more'}`;
                }
            }
        }

        // Check on page load - auto-load orders from global state
        document.addEventListener('DOMContentLoaded', () => {
            // Wait for i18n and appState to be fully initialized
            function checkOrdersAndDisplay() {
                if (typeof i18n === 'undefined' || typeof window.appState === 'undefined') {
                    setTimeout(checkOrdersAndDisplay, 100);
                    return;
                }
                
                // Ensure language is set correctly
                const savedLang = localStorage.getItem('zuidplas_language') || 
                                  localStorage.getItem('zuidplas_user_language') || 
                                  'nl';
                if (i18n.currentLang !== savedLang) {
                    i18n.setLanguage(savedLang);
                }
                
                // CRITICAL: Use SINGLE SOURCE OF TRUTH for orders and cart calculation
                // This ensures ALL pages show the SAME numbers!
                console.log('üîÑ Cart Optimization: Loading orders from SINGLE SOURCE...');
                let orders = [];
                let cartResult = null;
                
                // CRITICAL: Get data from single source (Dashboard's cache)
                // forceRefresh = FALSE (only Dashboard can force refresh!)
                if (window.CartCalculation && window.CartCalculation.getGlobalOrdersAndCarts) {
                    console.log('üõí Cart Optimization: Using SINGLE SOURCE OF TRUTH (getGlobalOrdersAndCarts)...');
                    const globalData = window.CartCalculation.getGlobalOrdersAndCarts(false);
                    orders = globalData.orders;
                    cartResult = globalData.cartResult;
                    
                    // CRITICAL: Check if cartResult is valid
                    if (!cartResult || cartResult.total === 0) {
                        console.error('‚ùå No cart calculation found!');
                        console.error('‚ùå Please go to Dashboard and click "Sync" or "Refresh Data" first!');
                        showError('No data available. Please sync data from Dashboard first.');
                        return;
                    }
                    
                    // CRITICAL: Use window.AppData for consistent counts
                    if (window.AppData && window.AppData.uniqueOrderIds) {
                        const uniqueCount = window.AppData.uniqueOrderIds.size;
                        console.log(`‚úÖ Cart Optimization: Loaded ${uniqueCount} unique orders (from ${orders.length} orderrows)`);
                        console.log(`‚úÖ Cart Optimization: Cart result - ${cartResult.total} carts`);
                        // Ensure cartResult has correct count
                        if (cartResult) {
                            cartResult.matchedOrdersCount = uniqueCount;
                        }
                    } else {
                        console.log(`‚úÖ Cart Optimization: Loaded ${orders.length} orders from SINGLE SOURCE`);
                        console.log(`‚úÖ Cart Optimization: Cart result - ${cartResult.total} carts`);
                    }
                } else {
                    console.error('‚ùå getGlobalOrdersAndCarts() not available!');
                    showError('Cart calculation system not available. Please refresh the page.');
                    return;
                }
                
                // CRITICAL: Check if cache exists and is valid
                const cacheExists = window.__zuidplas_cart_cache && window.__zuidplas_cart_cache.cartResult;
                
                if (!cacheExists) {
                    console.error('‚ùå ERROR: No cache found!');
                    showError('No data available. Please sync data from Dashboard first.');
                    return;
                }
                
                // Get cache info
                console.log('üìã Cache information:');
                console.log(`   Date: ${window.__zuidplas_cart_cache.date}`);
                console.log(`   Timestamp: ${window.__zuidplas_cart_cache.timestamp}`);
                console.log(`   Matched orders: ${window.__zuidplas_cart_cache.cartResult.matchedOrdersCount || 'N/A'}`);
                console.log(`   Total carts: ${window.__zuidplas_cart_cache.cartResult.total || 'N/A'}`);
                
                if (!cartResult || !cartResult.matchedOrdersCount) {
                    console.error('‚ùå ERROR: Invalid cache data!');
                    showError('No data available. Please sync data from Dashboard first.');
                    return;
                }
                
                console.log('');
                console.log('‚úÖ CART LOADING PAGE using Dashboard cache:');
                console.log(`   Matched orders: ${cartResult.matchedOrdersCount} (NOT ${orders.length} orderrows!)`);
                console.log(`   Total carts: ${cartResult.total}`);
                console.log(`   Standard: ${cartResult.standard || 0}, Danish: ${cartResult.danish || 0}`);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                
                // CRITICAL: Use matched orders from cartResult (same as Dashboard)
                const matchedOrders = cartResult.matchedOrders || orders;
                
                if (!matchedOrders || matchedOrders.length === 0) {
                    // Clear display - no orders loaded
                    clearCartOptimizationDisplay();
                    console.error('‚ùå No matched orders in cache!');
                    showError('No orders available. Please sync data from Dashboard first.');
                    return;
                }
                
                // Orders are available - load them into orderManager
                console.log(`üì¶ Found ${matchedOrders.length} matched orders in cache, loading...`);
                orderManager.orders = matchedOrders;
                orderManager.filteredOrders = [...matchedOrders];
                
                // CRITICAL: Update UI with CACHED cart count immediately!
                console.log(`‚úÖ Updating UI with cached cart count: ${cartResult.total} carts`);
                const totalCartsEl = document.getElementById('total-carts');
                if (totalCartsEl) {
                    totalCartsEl.textContent = cartResult.total;
                }
                
                // UPDATE UI - CRITICAL: Use matchedOrdersCount!
                const totalOrdersEl = document.getElementById('cart-total-orders');
                if (totalOrdersEl) {
                    totalOrdersEl.textContent = cartResult.matchedOrdersCount;
                }
                const cartsAssignedEl = document.getElementById('carts-assigned');
                if (cartsAssignedEl) {
                    cartsAssignedEl.textContent = cartResult.total;
                }
                const standardEl = document.getElementById('cart-standard');
                if (standardEl) {
                    standardEl.textContent = cartResult.standard || 0;
                }
                const danishEl = document.getElementById('cart-danish');
                if (danishEl) {
                    danishEl.textContent = cartResult.danish || 0;
                }
                
                // CRITICAL: Update cart counts using CartDisplayManager
                // CartDisplayManager will use getGlobalOrdersAndCarts internally
                if (window.CartDisplayManager) {
                    const cartManager = new CartDisplayManager();
                    cartManager.updateDOM();
                    console.log('‚úÖ Cart counts updated using CartDisplayManager');
                } else {
                    console.warn('‚ö†Ô∏è CartDisplayManager not available');
                }
                    
                    // Ensure truck assignments are loaded before optimizing
                    loadTruckAssignments();
                    
                    // Auto-optimize
                    console.log('üîß Auto-optimizing cart loading...');
                    optimizeCartLoading();
                }
            }
            
            checkOrdersAndDisplay();
            
            // Listen for orders updates from other pages
            window.addEventListener('ordersUpdated', (event) => {
                console.log(`üì¢ Orders updated (${event.detail.count} orders), reloading...`);
                const orders = event.detail.orders || window.appState.getOrders();
                
                orderManager.orders = orders;
                orderManager.filteredOrders = [...orders];
                
                // CRITICAL: Update cart counts using CartDisplayManager
                if (window.CartDisplayManager) {
                    const cartManager = new CartDisplayManager(orders);
                    cartManager.updateDOM();
                    console.log('‚úÖ Cart counts updated using CartDisplayManager');
                }
                
                optimizeCartLoading();
            });
        });
        
        // Toggle sidebar collapse (desktop)
        function toggleSidebarCollapse() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('collapsed');
            localStorage.setItem('sidebarCollapsed', sidebar.classList.contains('collapsed'));
        }
        
        // Toggle sidebar on mobile
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('open');
        }
        
        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function(event) {
            const sidebar = document.getElementById('sidebar');
            const menuBtn = document.querySelector('.mobile-menu-btn');
            
            if (window.innerWidth <= 768 && 
                sidebar.classList.contains('open') && 
                !sidebar.contains(event.target) && 
                !menuBtn.contains(event.target)) {
                sidebar.classList.remove('open');
            }
        });
        
        // Restore sidebar state on load
        document.addEventListener('DOMContentLoaded', () => {
            const sidebar = document.getElementById('sidebar');
            const isCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
            if (isCollapsed && window.innerWidth > 768) {
                sidebar.classList.add('collapsed');
            }
        });
        
        // Language switcher
        window.setLanguage = function(lang) {
            if (typeof i18n !== 'undefined') {
                i18n.setLanguage(lang);
                updateLanguageButtons();
            }
        };
        
        function updateLanguageButtons() {
            if (typeof i18n === 'undefined') return;
            const currentLang = i18n.getLanguage();
            document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(`lang-btn-${currentLang}`);
            if (activeBtn) activeBtn.classList.add('active');
        }
    
        // Logout function - clears session and redirects to login
        function handleLogout() {
            if (confirm(typeof i18n !== 'undefined' ? i18n.t('common.confirmLogout', 'Are you sure you want to logout?') : 'Are you sure you want to logout?')) {
                // Clear all session data
                localStorage.removeItem('zuidplas_logged_in');
                localStorage.removeItem('florinet_token');
                localStorage.removeItem('florinet_token_expiry');
                localStorage.removeItem('florinet_username');
                localStorage.removeItem('florinet_password');
                localStorage.removeItem('zuidplas_demo_mode');
                sessionStorage.clear();
                
                // Redirect to login
                window.location.href = 'login.html';
            }
        }
        
        // Make logout function global
        window.handleLogout = handleLogout;

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // DEBUG STATE CHECKER
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function debugCheckState() {
            const globalCount = window.appState?.getOrderCount() || 0;
            
            // Check BOTH old and new localStorage keys
            const oldData = localStorage.getItem('cachedOrders');
            const newData = localStorage.getItem('zuidplas_orders');
            const oldCount = oldData ? JSON.parse(oldData).length : 0;
            const newCount = newData ? JSON.parse(newData).length : 0;
            
            const managerCount = orderManager?.orders?.length || 0;
            const lastSync = localStorage.getItem('lastSyncDate') || 'Never';
            const currentDate = window.appState?.currentDate || '-';
            
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üêõ DEBUG STATE CHECK (CART OPTIMIZATION)');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log(`Global State (memory): ${globalCount} orders`);
            console.log(`OLD LocalStorage (cachedOrders): ${oldCount} orders`);
            console.log(`NEW LocalStorage (zuidplas_orders): ${newCount} orders`);
            console.log(`OrderManager: ${managerCount} orders`);
            console.log(`Last Sync: ${lastSync}`);
            console.log(`Current Date: ${currentDate}`);
            console.log('window.appState:', window.appState);
            console.log('orderManager.orders:', orderManager?.orders?.slice(0, 2));
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            alert(`üêõ CART OPT STATE\n\nMemory: ${globalCount} orders\nOLD storage: ${oldCount}\nNEW storage: ${newCount}\nManager: ${managerCount}\nLast sync: ${lastSync}\nDate: ${currentDate}`);
        }
        
        // Update debug panel every 2 seconds
        function updateDebugPanel() {
            const globalCount = window.appState?.getOrderCount() || 0;
            
            // Check BOTH old and new localStorage keys
            const oldData = localStorage.getItem('cachedOrders');
            const newData = localStorage.getItem('zuidplas_orders');
            const localCount = newData ? JSON.parse(newData).length : (oldData ? JSON.parse(oldData).length : 0);
            
            const managerCount = orderManager?.orders?.length || 0;
            const lastSync = localStorage.getItem('lastSyncDate') || 'Never';
            const currentDate = window.appState?.currentDate || '-';
            
            const globalEl = document.getElementById('debug-global-orders');
            const localEl = document.getElementById('debug-local-orders');
            const managerEl = document.getElementById('debug-manager-orders');
            const syncEl = document.getElementById('debug-last-sync');
            const dateEl = document.getElementById('debug-current-date');
            
            if (globalEl) globalEl.textContent = globalCount;
            if (localEl) localEl.textContent = localCount;
            if (managerEl) managerEl.textContent = managerCount;
            if (syncEl) syncEl.textContent = lastSync === 'Never' ? 'Never' : new Date(lastSync).toLocaleTimeString();
            if (dateEl) dateEl.textContent = currentDate;
        }
        
        // Make functions global
        window.debugCheckState = debugCheckState;
        window.updateDebugPanel = updateDebugPanel;
        
        // Listen for orders updated event and update debug panel immediately
        window.addEventListener('ordersUpdated', (event) => {
            console.log('üì¢ Debug panel: Orders updated event received:', event.detail.count);
            updateDebugPanel();
        });
        
        // Update debug panel periodically
        setInterval(updateDebugPanel, 2000);
        
        // Initial update
        setTimeout(updateDebugPanel, 1000);

    </script>
</body>