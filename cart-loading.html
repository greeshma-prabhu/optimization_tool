<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cart Loading Optimizer - Zuidplas Logistics</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/layout.css">
    <style>
        .truck-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 18px;
            margin: 20px 0;
        }
        
        @media (max-width: 1200px) {
            .truck-container {
                grid-template-columns: 1fr;
            }
        }
        
        .route-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .truck-selector {
            margin: 15px 0;
            padding: 12px;
            background: #f9fafb;
            border-radius: 8px;
        }
        
        .truck-selector label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-primary);
        }
        
        .truck-selector select {
            width: 100%;
            padding: 10px;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-size: 1rem;
            background: white;
            cursor: pointer;
        }
        
        .truck-selector select:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .truck-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .truck-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border);
        }
        
        .truck-slots {
            display: grid;
            grid-template-columns: repeat(17, minmax(10px, 1fr));
            gap: 3px;
            align-items: start;
            margin: 12px 0;
        }
        
        .cart-slot {
            aspect-ratio: 1;
            min-width: 10px;
            min-height: 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.5rem;
            font-weight: 600;
            position: relative;
            transition: all 0.2s;
        }

        .cart-detail-trigger {
            cursor: pointer;
        }

        .cart-client-dot {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 7px;
            height: 7px;
            border-radius: 50%;
            color: #fff;
            font-size: 5px;
            font-weight: 700;
            margin: 0 1px;
        }
        
        .cart-slot.filled-standard {
            color: white;
            border-width: 1px;
            font-weight: 600;
        }
        
        .cart-slot.filled-danish {
            color: white;
            border-width: 2px;
            font-weight: 600;
        }
        
        .client-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 16px;
            padding: 16px;
            background: #f9fafb;
            border-radius: 8px;
        }
        
        .client-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
        }
        
        .client-color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        
        .cart-visualization {
            margin-top: 20px;
            padding: 20px;
            background: #f9fafb;
            border-radius: 8px;
        }
        
        .cart-visual-item {
            display: inline-block;
            margin: 4px;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            color: white;
            border: 2px solid rgba(0,0,0,0.1);
        }
        
        .cart-slot.empty {
            background: #f9fafb;
            color: var(--text-secondary);
            border-style: dashed;
        }
        
        .cart-slot.overflow {
            background: #fee2e2;
            border-color: #ef4444;
            color: #ef4444;
        }

        .cart-detail-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.45);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .cart-detail-modal.active {
            display: flex;
        }

        .cart-detail-content {
            background: #ffffff;
            border-radius: 12px;
            padding: 24px;
            width: min(900px, 92vw);
            max-height: 90vh;
            overflow: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .cart-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            margin-bottom: 16px;
        }

        .cart-detail-header h3 {
            margin: 0;
        }

        .cart-detail-close {
            border: none;
            background: #f3f4f6;
            border-radius: 8px;
            padding: 6px 10px;
            cursor: pointer;
            font-weight: 600;
        }

        .cart-layer {
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 12px;
            background: #fafafa;
        }

        .cart-layer-title {
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            color: var(--text-primary);
        }

        .cart-layer-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(14px, 1fr));
            gap: 3px;
            overflow-x: auto;
        }

        .cart-layer-slot {
            height: 14px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.5rem;
            color: #fff;
            font-weight: 600;
        }

        .cart-layer-slot.empty {
            background: #e5e7eb;
            border-style: dashed;
            color: #6b7280;
        }

        .cart-detail-summary {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 16px;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .cart-detail-legend {
            margin-top: 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .cart-detail-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
        }

        .cart-detail-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .route-assignment {
            background: #f0f9ff;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .route-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            margin: 5px 5px 5px 0;
        }
        
        .route-rijnsburg { background: #dbeafe; color: #1e40af; }
        .route-aalsmeer { background: #dcfce7; color: #166534; }
        .route-naaldwijk { background: #fef3c7; color: #92400e; }
        
        .cart-list {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
        }
        
        .cart-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin-bottom: 8px;
            background: #f9fafb;
            border-radius: 8px;
            border-left: 4px solid;
        }
        
        .cart-item.standard { border-left-color: #3b82f6; }
        .cart-item.danish { border-left-color: #8b5cf6; }
        
        .capacity-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .capacity-bar {
            flex: 1;
            height: 20px;
            background: #e5e7eb;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .capacity-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981 0%, #059669 100%);
            transition: width 0.3s;
        }
        
        .capacity-fill.warning {
            background: linear-gradient(90deg, #f59e0b 0%, #d97706 100%);
        }
        
        .capacity-fill.danger {
            background: linear-gradient(90deg, #ef4444 0%, #dc2626 100%);
        }
        
        /* Route Timeline Visualization */
        .route-timeline {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin: 30px 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .timeline-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            margin-top: 30px;
        }
        
        .timeline-connector {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3b82f6 0%, #10b981 50%, #f59e0b 100%);
            z-index: 0;
        }
        
        .timeline-point {
            position: relative;
            z-index: 1;
            text-align: center;
            flex: 1;
        }
        
        .timeline-time {
            background: white;
            border: 3px solid;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.1rem;
            margin: 0 auto 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .timeline-time.route1 { border-color: #3b82f6; color: #3b82f6; }
        .timeline-time.route2 { border-color: #10b981; color: #10b981; }
        .timeline-time.route3 { border-color: #f59e0b; color: #f59e0b; }
        
        .timeline-route-info {
            background: #f9fafb;
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .timeline-truck {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 5px;
        }
        
        /* Color-Coded Route Sections */
        .route-section {
            margin: 15px 0;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid;
        }
        
        .route-section.rijnsburg {
            background: #eff6ff;
            border-left-color: #3b82f6;
        }
        
        .route-section.aalsmeer {
            background: #f0fdf4;
            border-left-color: #10b981;
        }
        
        .route-section.naaldwijk {
            background: #fffbeb;
            border-left-color: #f59e0b;
        }
        
        .route-section-header {
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Cost Impact Display */
        .cost-impact {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-left: 8px;
        }
        
        .cost-impact.positive {
            background: #dcfce7;
            color: #166534;
        }
        
        .cost-impact.negative {
            background: #fee2e2;
            color: #991b1b;
        }
        
        /* Alternative Assignments */
        .alternatives-toggle {
            margin: 20px 0;
            text-align: center;
        }
        
        .alternatives-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .alternative-card {
            background: #f9fafb;
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 15px;
        }
        
        .alternative-card.recommended {
            border-color: var(--primary);
            background: #eff6ff;
        }
        
        /* Loading Sequence */
        .loading-sequence {
            margin-top: 15px;
            padding: 12px;
            background: #f9fafb;
            border-radius: 8px;
        }
        
        .loading-sequence-title {
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .loading-sequence-help {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
            font-style: italic;
        }
        
        .loading-steps {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .loading-step {
            background: white;
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid var(--border);
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: default;
        }
        
        .loading-step-number {
            background: var(--primary);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .loading-more-btn {
            background: var(--primary);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            border: none;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .loading-more-btn:hover {
            background: #ea580c;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(249, 115, 22, 0.3);
        }
        
        .loading-full-list {
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border: 1px solid var(--border);
            max-height: 200px;
            overflow-y: auto;
        }
        
        .loading-full-item {
            padding: 6px 8px;
            border-bottom: 1px solid #f3f4f6;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .loading-full-item:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body>
    <!-- Top Header -->
    <header class="top-header">
        <div class="header-left">
            <div class="header-logo">
                <div class="logo-blocks">
                    <div class="logo-block d">D</div>
                    <div class="logo-block flower">
                        <div class="logo-flower-icon"></div>
                    </div>
                    <div class="logo-block z">Z</div>
                </div>
                <div class="logo-text-large">
                    <div class="logo-main-text">DE ZUIDPLAS</div>
                </div>
            </div>
        </div>
        <div class="header-right">
            <div class="user-menu">
                <div class="user-avatar">A</div>
                <span style="font-size: 14px; color: #374151;">Admin User</span>
                <div class="user-badge">Admin</div>
            </div>
            <div class="language-selector">
                <select id="language-select" onchange="changeLanguage(this.value)">
                    <option value="nl">üá≥üá± Nederlands</option>
                    <option value="en">üá¨üáß English</option>
                </select>
            </div>
            <button class="logout-btn-header" onclick="handleLogout()" data-i18n="common.logout">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                    <polyline points="16 17 21 12 16 7"></polyline>
                    <line x1="21" y1="12" x2="9" y2="12"></line>
                </svg>
                <span>Uitloggen</span>
            </button>
        </div>
    </header>

    <!-- Top Navigation Bar -->
    <nav class="top-nav">
        <div class="nav-items">
            <a href="index.html" class="nav-item" data-page="index">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="7" height="7"></rect>
                    <rect x="14" y="3" width="7" height="7"></rect>
                    <rect x="14" y="14" width="7" height="7"></rect>
                    <rect x="3" y="14" width="7" height="7"></rect>
                </svg>
                <span data-i18n="nav.dashboard">Dashboard</span>
            </a>
            
            <a href="orders.html" class="nav-item " data-page="orders">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                </svg>
                <span data-i18n="nav.orders">Orders</span>
            </a>
            
            <a href="optimization.html" class="nav-item " data-page="optimization">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polyline>
                </svg>
                <span data-i18n="nav.optimization">Optimization</span>
            </a>
            
            <a href="cart-loading.html" class="nav-item active" data-page="cart-loading">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="2" y="7" width="20" height="14" rx="2"></rect>
                    <path d="M16 7V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v2"></path>
                    <line x1="12" y1="12" x2="12" y2="16"></line>
                    <line x1="8" y1="12" x2="8" y2="16"></line>
                    <line x1="16" y1="12" x2="16" y2="16"></line>
                </svg>
                <span data-i18n="nav.cartOptimization">Cart Optimization</span>
            </a>
            
            <a href="trucks.html" class="nav-item " data-page="trucks">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="1" y="3" width="15" height="13"></rect>
                    <polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon>
                    <circle cx="5.5" cy="18.5" r="2.5"></circle>
                    <circle cx="18.5" cy="18.5" r="2.5"></circle>
                </svg>
                <span data-i18n="nav.trucks">Trucks</span>
            </a>
            
            <a href="costs.html" class="nav-item " data-page="costs">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="12" y1="1" x2="12" y2="23"></line>
                    <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>
                </svg>
                <span data-i18n="nav.costs">Costs</span>
            </a>
        </div>
    </nav>
<!-- Main Content -->
    <main class="main-content" style="margin-left: 0;">
        <div class="page-header">
            <h1 class="page-title" data-i18n="cartLoading.title">Cart Optimization</h1>
            <p class="page-subtitle" data-i18n="cartLoading.subtitle">Place all carts on 2 trucks - Cover all 3 routes efficiently</p>
            <button class="btn btn-primary" onclick="optimizeCartLoading()" style="margin-top: 20px;" data-i18n="cartLoading.optimizeButton">üîÑ Optimize Cart Loading</button>
        </div>

        <!-- Summary Stats -->
        <div class="stats-grid">
            <div class="stat-card primary">
                <div class="icon">üì¶</div>
                <div class="label" data-i18n="cartLoading.totalCarts">Total Carts</div>
                <div class="value" id="total-carts">0</div>
            </div>
            <div class="stat-card success">
                <div class="icon">‚úÖ</div>
                <div class="label" data-i18n="cartLoading.cartsAssigned">Carts Assigned</div>
                <div class="value" id="carts-assigned">0</div>
            </div>
            <div class="stat-card warning">
                <div class="icon">‚ö†Ô∏è</div>
                <div class="label" data-i18n="cartLoading.overflow">Overflow</div>
                <div class="value" id="overflow-count">0</div>
            </div>
            <div class="stat-card info">
                <div class="icon">üéØ</div>
                <div class="label" data-i18n="cartLoading.routesCovered">Routes Covered</div>
                <div class="value" id="routes-covered">0/6</div>
            </div>
        </div>

        <!-- Route Timeline Visualization -->
        <div class="route-timeline" id="route-timeline" style="display: none;">
            <h2 data-i18n="cartLoading.routeTimeline">Route Timeline</h2>
            <div class="timeline-container">
                <div class="timeline-connector"></div>
                <!-- Populated by JavaScript -->
            </div>
        </div>

        <!-- Alternative Assignments Toggle -->
        <div class="alternatives-toggle" id="alternatives-toggle" style="display: none;">
            <button class="btn btn-secondary" onclick="toggleAlternatives()" data-i18n="cartLoading.showAlternatives">üîÑ Show Alternative Assignments</button>
            <div class="alternatives-container" id="alternatives-container" style="display: none;">
                <!-- Populated by JavaScript -->
            </div>
        </div>

        <!-- Truck Loading Visualization -->
        <div class="truck-container" id="truck-container">
            <!-- Populated by JavaScript -->
        </div>

        <!-- Cart List by Route -->
        <div class="card">
            <h2 data-i18n="cartLoading.cartsByRoute">Carts by Route</h2>
            <div id="cart-list-by-route">
                <!-- Populated by JavaScript -->
            </div>
        </div>
    </main>

    <div id="cart-detail-modal" class="cart-detail-modal" aria-hidden="true">
        <div class="cart-detail-content">
            <div class="cart-detail-header">
                <h3 id="cart-detail-title">Cart Details</h3>
                <button class="cart-detail-close" type="button" onclick="closeCartDetail()">Close</button>
            </div>
            <div id="cart-detail-body"></div>
        </div>
    </div>

    <!-- LANGUAGE SCRIPTS - MUST BE FIRST -->
    <script src="js/i18n.js"></script>
    <script src="js/i18n-init.js"></script>
    <script src="js/language.js"></script>
    <script>
        const languageSelect = document.getElementById('language-select');
        if (languageSelect && window.Language) {
            languageSelect.value = window.Language.getCurrentLanguage();
        }
        function changeLanguage(lang) {
            if (window.Language) {
                window.Language.setLanguage(lang);
            }
            location.reload();
        }
    </script>
    
    <!-- GLOBAL STATE MANAGER - BEFORE PAGE SCRIPTS -->
    <script src="js/app-state.js"></script>
    
    <!-- PAGE-SPECIFIC SCRIPTS -->
    <script src="js/data.js"></script>
    <script src="js/auth.js"></script>
    <script src="js/api.js"></script>
    <script src="js/route-mapping.js"></script> <!-- CLIENT-TO-ROUTE MAPPING -->
    <script src="js/cart-calculation.js"></script> <!-- CRITICAL: Cart calculation -->
    <script src="js/cart-display-manager.js"></script> <!-- Unified cart display -->
    <script src="js/carts.js"></script>
    <script src="js/ordermanager-shim.js"></script>
    <script src="js/orders.js"></script>
    <script src="js/optimizer.js"></script>
    <script src="js/navigation.js"></script>
    <script>
        let cartLoadingOptimizer = null;

        class CartLoadingOptimizer {
            constructor(orders) {
                this.orders = orders || [];
                this.cartManager = cartManager;
                this.truckAssignments = {
                    truck1: { carts: [], routes: [], danishCount: 0, standardCount: 0 },
                    truck2: { carts: [], routes: [], danishCount: 0, standardCount: 0 }
                };
            }

            /**
             * Get all carts that need to be loaded
             * MUST MATCH DASHBOARD LOGIC EXACTLY!
             * Uses the CORRECT cart-calculation.js method
             */
            getAllCarts() {
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('üì¶ CART CALCULATION (using CACHED result from Dashboard)');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                
                // CRITICAL: Use CACHED result from Dashboard, NEVER calculate independently!
                let cartResult = null;
                if (window.CartCalculation && window.CartCalculation.getGlobalOrdersAndCarts) {
                    const globalData = window.CartCalculation.getGlobalOrdersAndCarts(); // NO forceRefresh - only reads cache!
                    cartResult = globalData.cartResult;
                    
                    console.log('‚úÖ Using CACHED result from Dashboard:');
                    console.log(`   Total carts: ${cartResult.total}`);
                    console.log(`   Aalsmeer: ${cartResult.byRoute.Aalsmeer || 0} carts`);
                    console.log(`   Naaldwijk: ${cartResult.byRoute.Naaldwijk || 0} carts`);
                    console.log(`   Rijnsburg: ${cartResult.byRoute.Rijnsburg || 0} carts`);
                    console.log(`   Trucks: ${cartResult.trucks}`);
                    console.log(`   ‚úÖ This is the SAME result as Dashboard - SINGLE SOURCE OF TRUTH!`);
                    
                    if (!cartResult || cartResult.total === 0) {
                        console.warn('‚ö†Ô∏è WARNING: Got 0 carts from cache - Dashboard may not have calculated yet!');
                        console.warn('‚ö†Ô∏è Please load Dashboard and click "Sync" or "Refresh Data" to calculate carts!');
                        return [];
                    }
                    
                    // Convert breakdown to cart objects for the UI
                    const allCarts = [];
                    let cartIdCounter = 1;
                    
                    // Group orders by customer for cart assignment
                    const ordersByCustomer = {};
                    this.orders.forEach(order => {
                        const customerName = order.customer_name || order.customer || order.customerName || 'Unknown';
                        if (!ordersByCustomer[customerName]) {
                            ordersByCustomer[customerName] = [];
                        }
                        ordersByCustomer[customerName].push(order);
                    });

                    // Build per-route unique customer lists so we don't repeat one name for all carts
                    const routeCustomers = {
                        rijnsburg_morning: [],
                        aalsmeer_morning: [],
                        naaldwijk_morning: [],
                        rijnsburg_evening: [],
                        aalsmeer_evening: [],
                        naaldwijk_evening: []
                    };
                    this.orders.forEach(order => {
                        const customerName = order.customer_name || order.customer || order.customerName || 'Unknown';
                        let orderRoute = order.route;
                        const orderPeriod = order.period || 'morning';
                        if (!orderRoute && this.cartManager && this.cartManager.determineRoute) {
                            try {
                                orderRoute = this.cartManager.determineRoute(order);
                            } catch (e) {
                                orderRoute = null;
                            }
                        }
                        if (orderRoute) {
                            const key = `${String(orderRoute).toLowerCase()}_${orderPeriod}`;
                            if (routeCustomers[key] && !routeCustomers[key].includes(customerName)) {
                                routeCustomers[key].push(customerName);
                            }
                        }
                    });
                    const routeCustomerIndex = {
                        rijnsburg_morning: 0,
                        aalsmeer_morning: 0,
                        naaldwijk_morning: 0,
                        rijnsburg_evening: 0,
                        aalsmeer_evening: 0,
                        naaldwijk_evening: 0
                    };
                    const routeCartIndex = {
                        rijnsburg_morning: 0,
                        aalsmeer_morning: 0,
                        naaldwijk_morning: 0,
                        rijnsburg_evening: 0,
                        aalsmeer_evening: 0,
                        naaldwijk_evening: 0
                    };
                    
                    // Create cart objects based on the breakdown
                    const breakdowns = [];
                    if (cartResult.morning?.breakdown) breakdowns.push(...cartResult.morning.breakdown);
                    if (cartResult.evening?.breakdown) breakdowns.push(...cartResult.evening.breakdown);
                    if (breakdowns.length === 0 && cartResult.breakdown && Array.isArray(cartResult.breakdown)) {
                        breakdowns.push(...cartResult.breakdown);
                    }

                    // Precompute cart counts per routeKey
                    const routeCartCount = {};
                    breakdowns.forEach(routeData => {
                        const route = routeData.route ? routeData.route.toLowerCase() : routeData.routeKey.replace('_morning', '').replace('_evening', '');
                        const period = routeData.period || (routeData.routeKey && routeData.routeKey.includes('_evening') ? 'evening' : 'morning');
                        const routeKey = routeData.routeKey || `${route}_${period}`;
                        const cartsCount = routeData.fustBreakdown?.reduce((sum, f) => sum + (f.carts || 0), 0) || 0;
                        routeCartCount[routeKey] = (routeCartCount[routeKey] || 0) + cartsCount;
                    });

                    // Build client buckets per cart for each routeKey
                    const routeClientBuckets = {};
                    Object.keys(routeCartCount).forEach(routeKey => {
                        const count = routeCartCount[routeKey] || 0;
                        routeClientBuckets[routeKey] = Array.from({ length: count }, () => []);
                    });

                    Object.keys(ordersByCustomer).forEach(customer => {
                        const sampleOrder = ordersByCustomer[customer][0];
                        const orderRoute = (sampleOrder.route || (this.cartManager && this.cartManager.determineRoute ? this.cartManager.determineRoute(sampleOrder) : '') || '').toLowerCase();
                        const orderPeriod = sampleOrder.period || 'morning';
                        const routeKey = `${orderRoute}_${orderPeriod}`;
                        const bucketCount = routeClientBuckets[routeKey]?.length || 0;
                        if (bucketCount === 0) return;
                        const weight = ordersByCustomer[customer].length || 1;
                        for (let i = 0; i < weight; i++) {
                            const idx = (routeCustomerIndex[routeKey] || 0) % bucketCount;
                            routeCustomerIndex[routeKey] = (routeCustomerIndex[routeKey] || 0) + 1;
                            const bucket = routeClientBuckets[routeKey][idx];
                            if (bucket && !bucket.includes(customer)) {
                                bucket.push(customer);
                            }
                        }
                    });

                    breakdowns.forEach(routeData => {
                        const route = routeData.route ? routeData.route.toLowerCase() : routeData.routeKey.replace('_morning', '').replace('_evening', '');
                        const period = routeData.period || (routeData.routeKey && routeData.routeKey.includes('_evening') ? 'evening' : 'morning');
                        const routeKey = routeData.routeKey || `${route}_${period}`;

                        if (routeData.fustBreakdown && Array.isArray(routeData.fustBreakdown)) {
                            routeData.fustBreakdown.forEach(fustData => {
                                const fustTypeCode = String(fustData.fustType || '').split(' ')[0];
                                const isDanish = String(fustData.fustType || '').toLowerCase().includes('danish');
                                const capacity = window.RouteMapping && window.RouteMapping.getCartCapacity
                                    ? window.RouteMapping.getCartCapacity(fustTypeCode, isDanish)
                                    : 17;
                                const totalFust = typeof fustData.totalFust === 'number'
                                    ? fustData.totalFust
                                    : (fustData.carts * capacity);
                                for (let i = 0; i < fustData.carts; i++) {
                                    let customerName = 'Unknown';
                                    const customersForRoute = routeCustomers[routeKey] || [];
                                    if (customersForRoute.length > 0) {
                                        const idx = routeCustomerIndex[routeKey] % customersForRoute.length;
                                        customerName = customersForRoute[idx];
                                        routeCustomerIndex[routeKey] += 1;
                                    } else {
                                        customerName = Object.keys(ordersByCustomer).find(cust => {
                                            const order = ordersByCustomer[cust][0];
                                            if (order && this.cartManager && this.cartManager.determineRoute) {
                                                const orderRoute = this.cartManager.determineRoute(order).toLowerCase();
                                                const orderPeriod = order.period || 'morning';
                                                return orderRoute === route && orderPeriod === period;
                                            }
                                            return false;
                                        }) || 'Unknown';
                                    }

                                    const cartIndex = routeCartIndex[routeKey] || 0;
                                    let cartClients = routeClientBuckets[routeKey]?.[cartIndex] || [];
                                    if ((!cartClients || cartClients.length <= 1) && customersForRoute.length > 1) {
                                        const primary = customersForRoute[cartIndex % customersForRoute.length];
                                        const secondary = customersForRoute[(cartIndex + 1) % customersForRoute.length];
                                        cartClients = primary === secondary ? [primary] : [primary, secondary];
                                    }
                                    routeCartIndex[routeKey] = cartIndex + 1;
                                    const remaining = totalFust - (capacity * i);
                                    const usedSlots = Math.max(0, Math.min(capacity, Math.ceil(remaining)));

                                    allCarts.push({
                                        id: `cart-${cartIdCounter++}`,
                                        client: customerName,
                                        customer: customerName,
                                        clients: cartClients,
                                        route: route,
                                        routeKey: routeKey,
                                        period: period,
                                        type: isDanish ? 'danish' : 'standard',
                                        orders: ordersByCustomer[customerName] || [],
                                        cartNumber: i + 1,
                                        totalCarts: fustData.carts,
                                        fustType: fustData.fustType,
                                        fustTypeCode: fustTypeCode,
                                        capacity: capacity,
                                        usedSlots: usedSlots
                                    });
                                }
                            });
                        }
                    });
                    
                    console.log(`   Standard: ${allCarts.filter(c => c.type === 'standard').length}`);
                    console.log(`   Danish: ${allCarts.filter(c => c.type === 'danish').length}`);
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    
                    return allCarts;
                } else {
                    console.error('‚ùå CartCalculation not available! Using fallback...');
                    // Fallback to old method if needed
                    return [];
                }
            }

            /**
             * Optimize cart assignment to trucks - ROUTE-BY-ROUTE
             * Each route is handled separately, showing breakdown per route
             */
            optimizeAssignment() {
                const allCarts = this.getAllCarts();
                
                // Reset assignments - track routes separately
                this.truckAssignments = {
                    truck1: { 
                        carts: [], 
                        routes: new Set(), 
                        danishCount: 0, 
                        standardCount: 0,
                        routeBreakdown: {
                            rijnsburg: { carts: [], danishCount: 0, standardCount: 0 },
                            naaldwijk: { carts: [], danishCount: 0, standardCount: 0 }
                        }
                    },
                    truck2: { 
                        carts: [], 
                        routes: new Set(), 
                        danishCount: 0, 
                        standardCount: 0,
                        routeBreakdown: {
                            aalsmeer: { carts: [], danishCount: 0, standardCount: 0 }
                        }
                    }
                };

                // Group carts by route
                const cartsByRoute = {
                    rijnsburg: [],
                    aalsmeer: [],
                    naaldwijk: []
                };

                allCarts.forEach(cart => {
                    if (cartsByRoute[cart.route]) {
                        cartsByRoute[cart.route].push(cart);
                    }
                });

                // Strategy: Each route handled separately
                // Truck 1: Route 1 (Rijnsburg) + Route 3 (Naaldwijk)
                // Truck 2: Route 2 (Aalsmeer)

                // Route 1: Rijnsburg ‚Üí Truck 1
                const route1Carts = cartsByRoute.rijnsburg;
                const route1Analysis = this.analyzeRouteCapacity(route1Carts, 'truck1');
                route1Carts.forEach(cart => {
                    this.assignCartToTruck(cart, 'truck1', 'rijnsburg');
                });

                // Route 2: Aalsmeer ‚Üí Truck 2
                const route2Carts = cartsByRoute.aalsmeer;
                const route2Analysis = this.analyzeRouteCapacity(route2Carts, 'truck2');
                route2Carts.forEach(cart => {
                    this.assignCartToTruck(cart, 'truck2', 'aalsmeer');
                });

                // Route 3: Naaldwijk ‚Üí Truck 1 (SEPARATE TRIP - don't combine with Route 1)
                const route3Carts = cartsByRoute.naaldwijk;
                // Route 3 is a SEPARATE trip - check independently (not combined with Route 1)
                const route3Analysis = this.analyzeRouteCapacity(route3Carts, 'truck1', false);
                route3Carts.forEach(cart => {
                    if (route3Analysis.fits) {
                        this.assignCartToTruck(cart, 'truck1', 'naaldwijk');
                    } else {
                        // Overflow - mark it but still assign for visualization
                        cart.overflow = true;
                        this.assignCartToTruck(cart, 'truck1', 'naaldwijk');
                    }
                });

                return {
                    truck1: this.truckAssignments.truck1,
                    truck2: this.truckAssignments.truck2,
                    allCarts: allCarts,
                    routeAnalysis: {
                        rijnsburg: route1Analysis,
                        aalsmeer: route2Analysis,
                        naaldwijk: route3Analysis
                    }
                };
            }
            
            /**
             * Analyze if a route's carts fit in a truck
             * IMPORTANT: Each route is a SEPARATE TRIP - don't combine routes!
             * @param {Array} routeCarts - Carts for this route
             * @param {String} truckId - Which truck to check
             * @param {Boolean} considerExisting - NOT USED - each route is independent
             */
            analyzeRouteCapacity(routeCarts, truckId, considerExisting = false) {
                // Count carts for THIS ROUTE ONLY (each route is a separate trip)
                let routeDanish = 0;
                let routeStandard = 0;
                routeCarts.forEach(cart => {
                    if (cart.type === 'danish') {
                        routeDanish++;
                    } else {
                        routeStandard++;
                    }
                });
                
                // Calculate truck capacity for THIS ROUTE (based on Danish carts in THIS route only)
                const maxCapacity = routeDanish > BUSINESS_RULES.danishThreshold 
                    ? BUSINESS_RULES.maxCartsWithDanish 
                    : BUSINESS_RULES.maxStandardCarts;
                
                // Check if THIS ROUTE fits using ACTUAL cart count (not equivalent)
                const actualCartCount = routeCarts.length;
                const fits = actualCartCount <= maxCapacity;
                const overflow = Math.max(0, actualCartCount - maxCapacity);
                
                // Calculate equivalent for display purposes only
                const routeEquivalentStandard = routeStandard + Math.ceil(routeDanish / BUSINESS_RULES.danishToStandardRatio);
                
                return {
                    // Route-specific info
                    routeCarts: routeCarts.length,
                    routeDanish: routeDanish,
                    routeStandard: routeStandard,
                    routeEquivalent: routeEquivalentStandard,
                    
                    // Capacity check for THIS ROUTE ONLY
                    fits: fits,
                    used: routeCarts.length, // Show ACTUAL cart count, not equivalent
                    max: maxCapacity,
                    overflow: overflow,
                    
                    // For backward compatibility
                    danishCount: routeDanish,
                    standardCount: routeStandard,
                    totalCarts: routeCarts.length
                };
            }

            assignCartToTruck(cart, truckId, routeName = null) {
                const truck = this.truckAssignments[truckId];
                truck.carts.push(cart);
                truck.routes.add(cart.route);
                
                if (cart.type === 'danish') {
                    truck.danishCount++;
                } else {
                    truck.standardCount++;
                }
                
                // Track route breakdown
                if (routeName && truck.routeBreakdown[routeName]) {
                    truck.routeBreakdown[routeName].carts.push(cart);
                    if (cart.type === 'danish') {
                        truck.routeBreakdown[routeName].danishCount++;
                    } else {
                        truck.routeBreakdown[routeName].standardCount++;
                    }
                }
            }

            canFitInTruck(cart, truckId) {
                const truck = this.truckAssignments[truckId];
                const currentDanish = truck.danishCount + (cart.type === 'danish' ? 1 : 0);
                const currentStandard = truck.standardCount + (cart.type === 'standard' ? 1 : 0);
                
                const maxCapacity = currentDanish > BUSINESS_RULES.danishThreshold 
                    ? BUSINESS_RULES.maxCartsWithDanish 
                    : BUSINESS_RULES.maxStandardCarts;
                
                const equivalentStandard = currentStandard + Math.ceil(currentDanish / BUSINESS_RULES.danishToStandardRatio);
                
                return equivalentStandard <= maxCapacity;
            }

            getTruckCapacity(truckId) {
                const truck = this.truckAssignments[truckId];
                
                // Get the route(s) on this truck to determine capacity
                const routes = Array.from(truck.routes);
                let maxCapacity = BUSINESS_RULES.maxStandardCarts;
                let totalDanish = 0;
                
                // Check each route to determine max capacity (if any route has >6 Danish, capacity is 16)
                routes.forEach(routeName => {
                    const routeBreakdown = truck.routeBreakdown[routeName];
                    if (routeBreakdown) {
                        totalDanish += routeBreakdown.danishCount || 0;
                    }
                });
                
                // If total Danish carts > threshold, capacity is reduced
                if (totalDanish > BUSINESS_RULES.danishThreshold) {
                    maxCapacity = BUSINESS_RULES.maxCartsWithDanish;
                }
                
                // Use ACTUAL cart count, not equivalent
                const actualCartCount = truck.carts.length;
                const fits = actualCartCount <= maxCapacity;
                const overflow = Math.max(0, actualCartCount - maxCapacity);
                
                return {
                    max: maxCapacity,
                    used: actualCartCount, // ACTUAL cart count
                    standard: truck.standardCount,
                    danish: truck.danishCount,
                    fits: fits,
                    overflow: overflow,
                    utilization: maxCapacity > 0 ? ((actualCartCount / maxCapacity) * 100).toFixed(1) : '0.0'
                };
            }
        }

        /**
         * Show error message when no data is available
         */
        function showError(message) {
            // Remove any existing error
            const existingError = document.getElementById('cart-loading-error-message');
            if (existingError) {
                existingError.remove();
            }
            
            const errorDiv = document.createElement('div');
            errorDiv.id = 'cart-loading-error-message';
            errorDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #fff3cd;
                border: 2px solid #ffc107;
                padding: 30px;
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 9999;
                max-width: 500px;
            `;
            
            errorDiv.innerHTML = `
                <h3 style="margin-top: 0; color: #856404;">‚ö†Ô∏è No Data Available</h3>
                <p style="color: #856404;">${message}</p>
                <button onclick="window.location.href='index.html'" 
                        style="margin-top: 20px; padding: 10px 20px; background: #ff6b00; color: white; border: none; border-radius: 5px; cursor: pointer; width: 100%;">
                    Go to Dashboard
                </button>
            `;
            
            document.body.appendChild(errorDiv);
        }
        
        // Make function globally accessible
        window.optimizeCartLoading = function optimizeCartLoading() {
            console.log('üöÄ optimizeCartLoading() called');
            
            // Ensure orderManager exists
            if (typeof orderManager === 'undefined') {
                console.error('‚ùå orderManager is not defined!');
                alert('Error: Order manager not initialized. Please refresh the page.');
                return;
            }
            
            // CRITICAL: Check if orders are available (from global state or orderManager)
            const hasOrders = orderManager && orderManager.orders && orderManager.orders.length > 0;
            const hasGlobalStateOrders = typeof window.appState !== 'undefined' && window.appState.hasOrders();
            
            // If no orders in orderManager but orders exist in global state, load them
            if (!hasOrders && hasGlobalStateOrders) {
                console.log('üì¶ Loading orders from global state...');
                const orders = window.appState.getOrders();
                if (!orderManager) {
                    console.error('‚ùå orderManager is still not defined after checking appState!');
                    alert('Error: Order manager not initialized. Please refresh the page.');
                    return;
                }
                orderManager.orders = orders;
                orderManager.filteredOrders = [...orders];
                console.log(`‚úÖ Loaded ${orders.length} orders from global state`);
            }
            
            // Final check - if still no orders, show error
            if (!orderManager || !orderManager.orders || orderManager.orders.length === 0) {
                // Show clear message - orders must be loaded first
                // Use i18n for proper language support
                const message = typeof i18n !== 'undefined' 
                    ? i18n.t('cartLoading.noOrdersMessage', 'No orders available. Go to Dashboard and click "Sync Orders from API" or "Load Demo Data" to load orders.')
                    : 'No orders available. Go to Dashboard and click "Sync Orders from API" or "Load Demo Data" to load orders.';
                
                alert(message);
                console.warn('‚ö†Ô∏è Cannot optimize: No orders loaded. Please load orders from Dashboard first.');
                
                // Clear any stale visualization
                clearCartOptimizationDisplay();
                return;
            }

            // Only proceed if we have fresh orders
            console.log('‚úÖ Running cart optimization with', orderManager.orders.length, 'orders');
            
            // CRITICAL: Use the SAME optimizer as dashboard to get consistent cart counts
            const optimizer = new RouteOptimizer(orderManager.orders);
            const routeAnalysis = optimizer.processOrders();
            
            cartLoadingOptimizer = new CartLoadingOptimizer(orderManager.orders);
            const result = cartLoadingOptimizer.optimizeAssignment();
            
            const globalData = window.CartCalculation && window.CartCalculation.getGlobalOrdersAndCarts
                ? window.CartCalculation.getGlobalOrdersAndCarts(false)
                : null;
            const cartResult = globalData?.cartResult;

            if (cartResult && cartResult.morning && cartResult.evening) {
                const getRouteStats = (period, routeKey, routeName) => {
                    const periodData = cartResult[period];
                    const breakdownEntry = periodData.breakdown?.find(b => b.routeKey === routeKey) || {};
                    const totalCarts = periodData.byRoute?.[routeName] || 0;
                    return {
                        totalCarts,
                        standardCarts: breakdownEntry.standardCarts || 0,
                        danishCarts: breakdownEntry.danishCarts || 0
                    };
                };

                const buildRouteAnalysis = (period, routeKey, routeName) => {
                    const stats = getRouteStats(period, routeKey, routeName);
                    const maxCapacity = 17;
                    const overflow = Math.max(0, stats.totalCarts - maxCapacity);
                    return {
                        fits: stats.totalCarts <= maxCapacity,
                        used: stats.totalCarts,
                        max: maxCapacity,
                        overflow: overflow,
                        totalCarts: stats.totalCarts,
                        danishCount: stats.danishCarts,
                        standardCount: stats.standardCarts
                    };
                };

                result.routeAnalysis = {
                    rijnsburg_morning: buildRouteAnalysis('morning', 'rijnsburg_morning', 'Rijnsburg'),
                    aalsmeer_morning: buildRouteAnalysis('morning', 'aalsmeer_morning', 'Aalsmeer'),
                    naaldwijk_morning: buildRouteAnalysis('morning', 'naaldwijk_morning', 'Naaldwijk'),
                    rijnsburg_evening: buildRouteAnalysis('evening', 'rijnsburg_evening', 'Rijnsburg'),
                    aalsmeer_evening: buildRouteAnalysis('evening', 'aalsmeer_evening', 'Aalsmeer'),
                    naaldwijk_evening: buildRouteAnalysis('evening', 'naaldwijk_evening', 'Naaldwijk')
                };
                // Backward compatibility for code that expects morning keys
                result.routeAnalysis.rijnsburg = result.routeAnalysis.rijnsburg_morning;
                result.routeAnalysis.aalsmeer = result.routeAnalysis.aalsmeer_morning;
                result.routeAnalysis.naaldwijk = result.routeAnalysis.naaldwijk_morning;
            } else if (routeAnalysis) {
                result.routeAnalysis = {
                    rijnsburg: {
                        fits: routeAnalysis.rijnsburg?.fits !== undefined ? routeAnalysis.rijnsburg.fits : true,
                        used: routeAnalysis.rijnsburg?.totalCarts || 0,
                        max: routeAnalysis.rijnsburg?.maxCapacity || 17,
                        overflow: routeAnalysis.rijnsburg?.overflow || 0,
                        totalCarts: routeAnalysis.rijnsburg?.totalCarts || 0,
                        danishCount: routeAnalysis.rijnsburg?.danishCarts || 0,
                        standardCount: routeAnalysis.rijnsburg?.standardCarts || 0
                    },
                    aalsmeer: {
                        fits: routeAnalysis.aalsmeer?.fits !== undefined ? routeAnalysis.aalsmeer.fits : ((routeAnalysis.aalsmeer?.totalCarts || 0) <= (routeAnalysis.aalsmeer?.maxCapacity || 17)),
                        used: routeAnalysis.aalsmeer?.totalCarts || 0,
                        max: routeAnalysis.aalsmeer?.maxCapacity || 17,
                        overflow: routeAnalysis.aalsmeer?.overflow || 0,
                        totalCarts: routeAnalysis.aalsmeer?.totalCarts || 0,
                        danishCount: routeAnalysis.aalsmeer?.danishCarts || 0,
                        standardCount: routeAnalysis.aalsmeer?.standardCarts || 0
                    },
                    naaldwijk: {
                        fits: routeAnalysis.naaldwijk?.fits !== undefined ? routeAnalysis.naaldwijk.fits : true,
                        used: routeAnalysis.naaldwijk?.totalCarts || 0,
                        max: routeAnalysis.naaldwijk?.maxCapacity || 17,
                        overflow: routeAnalysis.naaldwijk?.overflow || 0,
                        totalCarts: routeAnalysis.naaldwijk?.totalCarts || 0,
                        danishCount: routeAnalysis.naaldwijk?.danishCarts || 0,
                        standardCount: routeAnalysis.naaldwijk?.standardCarts || 0
                    }
                };
            }
            
            updateTruckVisualization(result);
            updateCartList(result.allCarts);
            updateSummaryStats(result);
            updateRouteTimeline(result);
            generateAlternatives(result);
            
            // Save route analysis to localStorage for Truck Management page
            if (result.routeAnalysis) {
                localStorage.setItem('zuidplas_route_analysis', JSON.stringify(result.routeAnalysis));
            }
        }
        
        function clearCartOptimizationDisplay() {
            // Reset all stats to 0
            document.getElementById('total-carts').textContent = '0';
            document.getElementById('carts-assigned').textContent = '0';
            document.getElementById('overflow-count').textContent = '0';
            document.getElementById('routes-covered').textContent = '0/6';
            
            // Clear truck visualization - use i18n for proper language
            const truckContainer = document.getElementById('truck-container');
            if (truckContainer) {
                const noOrdersMsg = typeof i18n !== 'undefined' 
                    ? i18n.t('cartLoading.noOrdersMessage', 'No orders loaded. Go to Dashboard to load orders.')
                    : 'No orders loaded. Go to Dashboard to load orders.';
                truckContainer.innerHTML = `<div style="text-align: center; padding: 40px; color: var(--text-secondary);" data-i18n="cartLoading.noOrdersMessage">${noOrdersMsg}</div>`;
                // Update i18n if available
                if (typeof i18n !== 'undefined') {
                    i18n.updatePage();
                }
            }
            
            // Clear cart list - use i18n for proper language
            const cartList = document.getElementById('cart-list-by-route');
            if (cartList) {
                const loadFirstMsg = typeof i18n !== 'undefined' 
                    ? i18n.t('cartLoading.loadOrdersFirst', 'Load orders from Dashboard first.')
                    : 'Load orders from Dashboard first.';
                cartList.innerHTML = `<div style="text-align: center; padding: 20px; color: var(--text-secondary);" data-i18n="cartLoading.loadOrdersFirst">${loadFirstMsg}</div>`;
                // Update i18n if available
                if (typeof i18n !== 'undefined') {
                    i18n.updatePage();
                }
            }
        }

        // Store current truck assignments for each route (can be single truck or combination like "truck1+truck2")
        // Load from localStorage to persist across navigation
        // Only cleared when new orders are synced (handled in index.html and orders.js)
        let routeTruckAssignments = {
            rijnsburg_morning: null,
            aalsmeer_morning: null,
            naaldwijk_morning: null,
            rijnsburg_evening: null,
            aalsmeer_evening: null,
            naaldwijk_evening: null
        };
        
        // Load saved assignments from localStorage (persists across navigation)
        function loadTruckAssignments() {
            try {
                const saved = localStorage.getItem('zuidplas_route_truck_assignments');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Only restore if we have valid assignments
                    if (parsed && typeof parsed === 'object') {
                        routeTruckAssignments = {
                            rijnsburg_morning: parsed.rijnsburg_morning || parsed.rijnsburg || null,
                            aalsmeer_morning: parsed.aalsmeer_morning || parsed.aalsmeer || null,
                            naaldwijk_morning: parsed.naaldwijk_morning || parsed.naaldwijk || null,
                            rijnsburg_evening: parsed.rijnsburg_evening || null,
                            aalsmeer_evening: parsed.aalsmeer_evening || null,
                            naaldwijk_evening: parsed.naaldwijk_evening || null
                        };
                        console.log('‚úÖ Restored truck assignments from localStorage:', routeTruckAssignments);
                    }
                }
            } catch (e) {
                console.warn('Failed to load truck assignments:', e);
            }
        }
        
        // Load assignments on page load
        loadTruckAssignments();
        
        // Parse truck assignment string to get array of truck IDs
        function parseTruckAssignment(assignment) {
            if (!assignment) return [];
            if (assignment.includes('+')) {
                return assignment.split('+').map(t => t.trim());
            }
            return [assignment];
        }
        
        // Get combined capacity for multiple trucks
        function getCombinedCapacity(truckIds, routeCarts) {
            let totalCapacity = 0;
            let totalDanish = 0;
            
            routeCarts.forEach(cart => {
                if (cart.type === 'danish') totalDanish++;
            });
            
            // Each truck has capacity based on Danish carts
            const maxCapacityPerTruck = totalDanish > BUSINESS_RULES.danishThreshold 
                ? BUSINESS_RULES.maxCartsWithDanish 
                : BUSINESS_RULES.maxStandardCarts;
            
            // Combined capacity = sum of all trucks
            totalCapacity = truckIds.length * maxCapacityPerTruck;
            
            return {
                max: totalCapacity,
                perTruck: maxCapacityPerTruck,
                truckCount: truckIds.length
            };
        }
        
        // Split carts between multiple trucks
        // CRITICAL: Only use as many trucks as needed - don't split if all carts fit in one truck
        function splitCartsBetweenTrucks(routeCarts, truckIds, combinedCapacity) {
            const perTruckCapacity = combinedCapacity.perTruck;
            const totalCarts = routeCarts.length;
            
            const assignments = {};
            truckIds.forEach(truckId => {
                assignments[truckId] = [];
            });
            
            // If all carts fit in one truck, put ALL carts in first truck only
            // Other trucks stay completely empty
            if (totalCarts <= perTruckCapacity) {
                assignments[truckIds[0]] = [...routeCarts];
                // All other trucks remain empty (already initialized as empty arrays)
                return assignments;
            }
            
            // Otherwise, distribute across trucks as needed (overflow scenario)
            let currentTruckIndex = 0;
            routeCarts.forEach((cart) => {
                const truckId = truckIds[currentTruckIndex];
                assignments[truckId].push(cart);
                
                // Move to next truck if current truck is full
                if (assignments[truckId].length >= perTruckCapacity && currentTruckIndex < truckIds.length - 1) {
                    currentTruckIndex++;
                }
            });
            
            return assignments;
        }
        
        // Route times for conflict detection
        const routeTimes = {
            rijnsburg: { time: '09:00', hour: 9 },
            aalsmeer: { time: '10:00', hour: 10 },
            naaldwijk: { time: '11:00', hour: 11 },
            rijnsburg_morning: { time: '09:00', hour: 9 },
            aalsmeer_morning: { time: '10:00', hour: 10 },
            naaldwijk_morning: { time: '11:00', hour: 11 },
            rijnsburg_evening: { time: '17:00', hour: 17 },
            aalsmeer_evening: { time: '18:00', hour: 18 },
            naaldwijk_evening: { time: '19:00', hour: 19 }
        };
        
        // Check if two routes have time conflict
        function hasTimeConflict(route1Key, route2Key) {
            const route1 = routeTimes[route1Key];
            const route2 = routeTimes[route2Key];
            if (!route1 || !route2) return false;
            
            // Routes conflict if they're within 2 hours of each other (truck needs time to return)
            const timeDiff = Math.abs(route1.hour - route2.hour);
            return timeDiff < 2;
        }
        
        // Get available truck combinations for a route
        function getAvailableTruckOptions(currentRouteKey) {
            const singleTrucks = [
                { id: 'truck1', name: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck1', 'Truck 1') : 'Truck 1' },
                { id: 'truck2', name: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck2', 'Truck 2') : 'Truck 2' },
                { id: 'neighbor', name: typeof i18n !== 'undefined' ? i18n.t('cartLoading.neighborTruck', 'Neighbor\'s Truck') : 'Neighbor\'s Truck' },
                { id: 'external', name: typeof i18n !== 'undefined' ? i18n.t('cartLoading.externalTruck', 'External Truck') : 'External Truck' }
            ];
            
            // Multi-truck combinations - expanded to include all possible combinations
            const combinations = [
                // Two truck combinations
                { id: 'truck1+truck2', name: 'Truck 1 + Truck 2' },
                { id: 'truck1+neighbor', name: 'Truck 1 + Neighbor\'s Truck' },
                { id: 'truck1+external', name: 'Truck 1 + External Truck' },
                { id: 'truck2+neighbor', name: 'Truck 2 + Neighbor\'s Truck' },
                { id: 'truck2+external', name: 'Truck 2 + External Truck' },
                { id: 'neighbor+external', name: 'Neighbor\'s Truck + External Truck' },
                { id: 'neighbor+neighbor', name: '2 Neighbor\'s Trucks' },
                { id: 'external+external', name: '2 External Trucks' },
                // Three truck combinations
                { id: 'truck1+truck2+neighbor', name: 'Truck 1 + Truck 2 + Neighbor\'s Truck' },
                { id: 'truck1+truck2+external', name: 'Truck 1 + Truck 2 + External Truck' },
                { id: 'truck1+neighbor+external', name: 'Truck 1 + Neighbor\'s Truck + External Truck' },
                { id: 'truck2+neighbor+external', name: 'Truck 2 + Neighbor\'s Truck + External Truck' },
                { id: 'neighbor+neighbor+external', name: '2 Neighbor\'s Trucks + External Truck' },
                { id: 'neighbor+external+external', name: 'Neighbor\'s Truck + 2 External Trucks' },
                // Four truck combinations (for very large routes)
                { id: 'truck1+truck2+neighbor+external', name: 'Truck 1 + Truck 2 + Neighbor\'s Truck + External Truck' },
                { id: 'truck1+neighbor+neighbor+external', name: 'Truck 1 + 2 Neighbor\'s Trucks + External Truck' },
                { id: 'truck1+neighbor+external+external', name: 'Truck 1 + Neighbor\'s Truck + 2 External Trucks' },
                { id: 'truck2+neighbor+neighbor+external', name: 'Truck 2 + 2 Neighbor\'s Trucks + External Truck' },
                { id: 'truck2+neighbor+external+external', name: 'Truck 2 + Neighbor\'s Truck + 2 External Trucks' },
                { id: 'neighbor+neighbor+external+external', name: '2 Neighbor\'s Trucks + 2 External Trucks' }
            ];
            
            const allOptions = [...singleTrucks, ...combinations];
            const available = [];
            
            allOptions.forEach(option => {
                const truckIds = parseTruckAssignment(option.id);
                let hasConflict = false;
                let conflictRoute = null;
                
                // Check each truck in the combination for conflicts
                truckIds.forEach(truckId => {
                    // Neighbor and External trucks are always available
                    if (truckId === 'neighbor' || truckId === 'external') return;
                    
                    Object.keys(routeTruckAssignments).forEach(routeKey => {
                        if (routeKey === currentRouteKey) return;
                        
                        // CRITICAL: Only check routes that actually have a truck assigned (not null)
                        const assignedTrucksStr = routeTruckAssignments[routeKey];
                        if (!assignedTrucksStr || assignedTrucksStr === null) return; // Skip routes with no assignment
                        
                        const assignedTrucks = parseTruckAssignment(assignedTrucksStr);
                        if (assignedTrucks.includes(truckId) && hasTimeConflict(currentRouteKey, routeKey)) {
                            hasConflict = true;
                            conflictRoute = routeKey;
                        }
                    });
                });
                
                if (!hasConflict) {
                    available.push({ ...option, available: true, reason: '' });
                } else {
                    const routeName = conflictRoute === 'rijnsburg' ? 'Rijnsburg' : 
                                     conflictRoute === 'aalsmeer' ? 'Aalsmeer' : 'Naaldwijk';
                    available.push({ 
                        ...option, 
                        available: false, 
                        reason: `Truck conflict with ${routeName}`
                    });
                }
            });
            
            return available;
        }

        // Smart truck options for UI (single trucks with availability rules)
        function langText(key, fallback) {
            if (window.Language && typeof window.Language.t === 'function') {
                return window.Language.t(key);
            }
            return fallback;
        }

        const routeConflictMap = {
            aalsmeer_morning: 'rijnsburg_morning',
            naaldwijk_morning: 'aalsmeer_morning',
            aalsmeer_evening: 'rijnsburg_evening',
            naaldwijk_evening: 'aalsmeer_evening'
        };

        function getSmartTruckOptions(routeKey) {
            const baseTrucks = [
                { id: 'truck1', name: langText('truck1', typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck1', 'Truck 1') : 'Truck 1') },
                { id: 'truck2', name: langText('truck2', typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck2', 'Truck 2') : 'Truck 2') },
                { id: 'neighbor', name: langText('neighbor', typeof i18n !== 'undefined' ? i18n.t('cartLoading.neighborTruck', 'Neighbor\'s Truck') : 'Neighbor\'s Truck') },
                { id: 'external', name: langText('external', typeof i18n !== 'undefined' ? i18n.t('cartLoading.externalTruck', 'External Truck') : 'External Truck') }
            ];

            const usedByRouteText = langText('used_by_route', 'Gebruikt door Route');
            const routeNames = {
                rijnsburg: langText('rijnsburg', 'Rijnsburg'),
                aalsmeer: langText('aalsmeer', 'Aalsmeer'),
                naaldwijk: langText('naaldwijk', 'Naaldwijk')
            };

            const blocked = new Set();
            let reason = null;

            const blockingRoute = routeConflictMap[routeKey];
            if (blockingRoute) {
                const blockingTrucks = parseTruckAssignment(routeTruckAssignments[blockingRoute] || '');
                blockingTrucks.forEach(id => blocked.add(id));
                const baseRoute = blockingRoute.includes('rijnsburg') ? routeNames.rijnsburg :
                                  blockingRoute.includes('aalsmeer') ? routeNames.aalsmeer :
                                  routeNames.naaldwijk;
                const routeNumber = blockingRoute.includes('rijnsburg') ? '1' :
                                    blockingRoute.includes('aalsmeer') ? '2' : '3';
                reason = `${usedByRouteText} ${routeNumber} (${baseRoute})`;
            }

            return baseTrucks.map(truck => ({
                ...truck,
                available: !blocked.has(truck.id),
                reason: blocked.has(truck.id) ? reason : null
            }));
        }

        function getSelectedTruckIds(routeKey) {
            return parseTruckAssignment(routeTruckAssignments[routeKey] || '');
        }

        function sanitizeRouteSelection(routeKey) {
            const selected = getSelectedTruckIds(routeKey);
            if (selected.length === 0) return selected;
            const options = getSmartTruckOptions(routeKey);
            const allowed = selected.filter(id => {
                const opt = options.find(t => t.id === id);
                return opt && opt.available;
            });
            if (allowed.length !== selected.length) {
                routeTruckAssignments[routeKey] = allowed.length > 0 ? allowed.join('+') : null;
                localStorage.setItem('zuidplas_route_truck_assignments', JSON.stringify(routeTruckAssignments));
            }
            return allowed;
        }

        function renderSmartTruckSelector(routeKey) {
            const availableTrucks = getSmartTruckOptions(routeKey);
            const selectedTrucks = sanitizeRouteSelection(routeKey);

            return `
                <div class="truck-selector-container">
                    <label style="display:block; font-weight: 600; margin-bottom: 6px;">${langText('select_truck', typeof i18n !== 'undefined' ? i18n.t('cartLoading.selectTruck', 'Select Truck:') : 'Select Truck:')}</label>
                    <div class="truck-options">
                        ${availableTrucks.map(truck => `
                            <label class="truck-option ${!truck.available ? 'disabled' : ''}">
                                <input
                                    type="checkbox"
                                    value="${truck.id}"
                                    ${selectedTrucks.includes(truck.id) ? 'checked' : ''}
                                    ${!truck.available ? 'disabled' : ''}
                                    onchange="handleSmartTruckChange('${routeKey}', this)"
                                />
                                <span class="truck-name">${truck.name}</span>
                                ${!truck.available ? `<span class="truck-unavailable">(${truck.reason})</span>` : ''}
                            </label>
                        `).join('')}
                    </div>
                    <div class="selected-trucks-summary">
                        <strong>${langText('selected', 'Geselecteerd')}:</strong>
                        ${selectedTrucks.length > 0
                            ? selectedTrucks.map(id => availableTrucks.find(t => t.id === id)?.name || id).join(' + ')
                            : langText('no_trucks_selected', typeof i18n !== 'undefined' ? i18n.t('cartLoading.noTruckSelected', 'Geen vrachtwagens geselecteerd') : 'Geen vrachtwagens geselecteerd')
                        }
                    </div>
                </div>
            `;
        }

        function handleSmartTruckChange(routeKey, checkbox) {
            let selectedTrucks = sanitizeRouteSelection(routeKey);
            const truckId = checkbox.value;

            if (checkbox.checked) {
                if (!selectedTrucks.includes(truckId)) {
                    selectedTrucks.push(truckId);
                }
            } else {
                selectedTrucks = selectedTrucks.filter(id => id !== truckId);
            }

            const options = getSmartTruckOptions(routeKey);
            const unavailable = selectedTrucks.find(id => {
                const opt = options.find(t => t.id === id);
                return !opt || !opt.available;
            });

            if (unavailable) {
                checkbox.checked = false;
                alert(langText('time_conflict_error', typeof i18n !== 'undefined'
                    ? i18n.t('cartLoading.truckUnavailable', 'This truck is unavailable due to time conflict with another route.')
                    : 'This truck is unavailable due to time conflict with another route.'));
                return;
            }

            // Prevent selections that would invalidate already-selected overlapping routes
            const conflictingRoute = Object.entries(routeConflictMap)
                .find(([blocked, blocker]) => blocker === routeKey);
            if (conflictingRoute) {
                const [blockedRoute] = conflictingRoute;
                const blockedSelection = parseTruckAssignment(routeTruckAssignments[blockedRoute] || '');
                const conflict = selectedTrucks.find(id => blockedSelection.includes(id));
                if (conflict) {
                    checkbox.checked = false;
                    alert(langText('time_conflict_error', typeof i18n !== 'undefined'
                        ? i18n.t('cartLoading.truckUnavailable', 'This truck is unavailable due to time conflict with another route.')
                        : 'This truck is unavailable due to time conflict with another route.'));
                    return;
                }
            }

            const selection = selectedTrucks.length > 0 ? selectedTrucks.join('+') : '';
            updateRouteTruck(routeKey, selection);
        }

        function updateTruckVisualization(result) {
            const container = document.getElementById('truck-container');
            const scrollTop = window.scrollY;
            container.innerHTML = '';
            window.__cartDetailMap = (result.allCarts || []).reduce((acc, cart) => {
                if (cart && cart.id) acc[cart.id] = cart;
                return acc;
            }, {});

            // Get route analysis if available
            const routeAnalysis = result.routeAnalysis || {};
            
            // Get route definitions
            const routes = [
                { key: 'rijnsburg_morning', name: typeof i18n !== 'undefined' ? i18n.t('routes.rijnsburg', 'Rijnsburg') : 'Rijnsburg', time: '09:00', color: '#3b82f6', bgColor: '#eff6ff', period: 'morning' },
                { key: 'aalsmeer_morning', name: typeof i18n !== 'undefined' ? i18n.t('routes.aalsmeer', 'Aalsmeer') : 'Aalsmeer', time: '10:00', color: '#10b981', bgColor: '#f0fdf4', period: 'morning' },
                { key: 'naaldwijk_morning', name: typeof i18n !== 'undefined' ? i18n.t('routes.naaldwijk', 'Naaldwijk') : 'Naaldwijk', time: '11:00', color: '#f59e0b', bgColor: '#fffbeb', period: 'morning' },
                { key: 'rijnsburg_evening', name: typeof i18n !== 'undefined' ? i18n.t('routes.rijnsburg', 'Rijnsburg') : 'Rijnsburg', time: '17:00', color: '#3b82f6', bgColor: '#eff6ff', period: 'evening' },
                { key: 'aalsmeer_evening', name: typeof i18n !== 'undefined' ? i18n.t('routes.aalsmeer', 'Aalsmeer') : 'Aalsmeer', time: '18:00', color: '#10b981', bgColor: '#f0fdf4', period: 'evening' },
                { key: 'naaldwijk_evening', name: typeof i18n !== 'undefined' ? i18n.t('routes.naaldwijk', 'Naaldwijk') : 'Naaldwijk', time: '19:00', color: '#f59e0b', bgColor: '#fffbeb', period: 'evening' }
            ];

            // Create separate card for EACH route
            routes.forEach(route => {
                // Get carts for this route only
                const routeCarts = result.allCarts.filter(cart => cart.routeKey === route.key);
                const routeInfo = routeAnalysis[route.key] || {
                    totalCarts: routeCarts.length,
                    standardCarts: routeCarts.filter(c => c.type !== 'danish').length,
                    danishCarts: routeCarts.filter(c => c.type === 'danish').length,
                    maxCapacity: 17,
                    overflow: Math.max(0, routeCarts.length - 17),
                    fits: routeCarts.length <= 17
                };
                
                // Get assigned trucks (can be single or multiple)
                // CRITICAL: No default - if null, show "Select Truck" message
                const assignedTrucksStr = routeTruckAssignments[route.key] || null;
                
                // If no truck selected, show message to select truck first WITH cart information
                if (!assignedTrucksStr) {
                    const selectTruckMsg = typeof i18n !== 'undefined' ? i18n.t('cartLoading.selectTruckFirst', 'Please select a truck for this route') : 'Please select a truck for this route';
                    
                    // Calculate cart statistics for display
                    // CRITICAL: Use routeInfo.totalCarts (from optimizer) for consistency, not routeCarts.length
                    const totalCarts = routeInfo.totalCarts || routeCarts.length;
                    const standardCarts = routeInfo.standardCarts || routeCarts.filter(c => c.type !== 'danish').length;
                    const danishCarts = routeInfo.danishCarts || routeCarts.filter(c => c.type === 'danish').length;
                    const maxCapacity = routeInfo.maxCapacity || 17;
                    
                    const routeCard = document.createElement('div');
                    routeCard.className = 'route-card';
                    routeCard.style.borderLeft = `4px solid ${route.color}`;
                    routeCard.innerHTML = `
                        <div style="padding: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px;">
                                <div>
                                    <div style="font-size: 1.1rem; font-weight: 600; color: var(--text-primary); margin-bottom: 5px;">
                                        ${route.name} (${route.time})
                                    </div>
                                    <div style="color: var(--text-secondary); font-size: 0.9rem;">
                                        ${selectTruckMsg}
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-size: 1.3rem; font-weight: 700; color: ${route.color};">
                                        ${totalCarts}
                                    </div>
                                    <div style="font-size: 0.85rem; color: var(--text-secondary);">
                                        ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.totalCarts', 'carts') : 'carts'} ${totalCarts > maxCapacity ? `(${typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow'})` : ''}
                                    </div>
                                </div>
                            </div>
                            
                            ${totalCarts > 0 ? `
                            <div style="background: ${route.bgColor}; padding: 12px; border-radius: 8px; margin-bottom: 15px; font-size: 0.9rem;">
                                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                                    <div>
                                        <strong>${typeof i18n !== 'undefined' ? i18n.t('cartLoading.totalCarts', 'Total Carts') : 'Total Carts'}:</strong> ${totalCarts}
                                    </div>
                                    ${standardCarts > 0 ? `
                                    <div>
                                        <strong>${typeof i18n !== 'undefined' ? i18n.t('cartLoading.standardCart', 'Standard') : 'Standard'}:</strong> ${standardCarts}
                                    </div>
                                    ` : ''}
                                    ${danishCarts > 0 ? `
                                    <div>
                                        <strong>${typeof i18n !== 'undefined' ? i18n.t('cartLoading.danishCart', 'Danish') : 'Danish'}:</strong> ${danishCarts}
                                    </div>
                                    ` : ''}
                                    <div>
                                        <strong>${typeof i18n !== 'undefined' ? i18n.t('status.capacity', 'Capacity') : 'Capacity'}:</strong> ${maxCapacity} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.perTruck', 'per truck') : 'per truck'}
                                    </div>
                                </div>
                                ${totalCarts > maxCapacity ? `
                                <div style="margin-top: 8px; padding: 8px; background: #fee2e2; border-radius: 6px; color: #991b1b; font-weight: 600;">
                                    ‚ö†Ô∏è ${totalCarts - maxCapacity} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.cartsOverflow', 'carts overflow - consider multiple trucks') : 'carts overflow - consider multiple trucks'}
                                </div>
                                ` : totalCarts <= maxCapacity ? `
                                <div style="margin-top: 8px; padding: 8px; background: #d1fae5; border-radius: 6px; color: #065f46; font-weight: 600;">
                                    ‚úì ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.fitsInOneTruck', 'Fits in one truck') : 'Fits in one truck'}
                                </div>
                                ` : ''}
                            </div>
                            ` : ''}
                            
                            ${renderSmartTruckSelector(route.key)}
                        </div>
                    `;
                    container.appendChild(routeCard);
                    
                    return; // Skip showing carts/visualization until truck is selected
                }
                
                const assignedTruckIds = parseTruckAssignment(assignedTrucksStr);
                
                // Calculate combined capacity for multiple trucks
                const combinedCapacity = getCombinedCapacity(assignedTruckIds, routeCarts);
                // CRITICAL: Use routeInfo.totalCarts (from optimizer) for consistency
                const totalCarts = routeInfo.totalCarts || routeCarts.length;
                const fits = totalCarts <= combinedCapacity.max;
                const overflow = Math.max(0, totalCarts - combinedCapacity.max);
                
                // Create route capacity object
                const routeCapacity = {
                    max: combinedCapacity.max,
                    used: totalCarts,
                    overflow: overflow,
                    fits: fits,
                    truckCount: assignedTruckIds.length,
                    perTruck: combinedCapacity.perTruck
                };
                
                // Update routeInfo to reflect combined capacity
                const updatedRouteInfo = {
                    ...routeInfo,
                    fits: fits,
                    maxCapacity: combinedCapacity.max,
                    overflow: overflow,
                    totalCarts: totalCarts
                };
                
                // Get display name for assigned trucks
                const truckNames = {
                    truck1: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck1', 'Truck 1') : 'Truck 1',
                    truck2: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck2', 'Truck 2') : 'Truck 2',
                    neighbor: typeof i18n !== 'undefined' ? i18n.t('cartLoading.neighborTruck', 'Neighbor\'s Truck') : 'Neighbor\'s Truck',
                    external: typeof i18n !== 'undefined' ? i18n.t('cartLoading.externalTruck', 'External Truck') : 'External Truck'
                };
                const assignedTruckName = assignedTruckIds.map(id => truckNames[id] || id).join(' + ');
                
                // Create route card
                const routeCard = createRouteCard(route, updatedRouteInfo, routeCarts, routeCapacity, assignedTrucksStr, assignedTruckName, assignedTruckIds);
                container.appendChild(routeCard);
                
            });
            
            // Preserve scroll position so truck selectors don't "jump" away
            requestAnimationFrame(() => {
                window.scrollTo({ top: scrollTop, behavior: 'auto' });
            });
        }
        
        function createRouteCard(route, routeInfo, routeCarts, routeCapacity, assignedTrucksStr, assignedTruckName, assignedTruckIds) {
            const card = document.createElement('div');
            card.className = 'route-card';
            card.style.borderLeft = `4px solid ${route.color}`;
            
            // Use routeCapacity.fits (based on combined capacity) instead of routeInfo.fits
            const statusClass = routeCapacity.fits ? 'success' : 'danger';
            const statusIcon = routeCapacity.fits ? '‚úÖ' : '‚ö†Ô∏è';
            const statusText = routeCapacity.fits 
                ? (typeof i18n !== 'undefined' ? i18n.t('status.fits', 'Fits') : 'Fits')
                : (typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow');
            
            // Get unique clients for this route
            const clients = [...new Set(routeCarts.flatMap(cart => {
                if (Array.isArray(cart.clients) && cart.clients.length > 0) {
                    return cart.clients;
                }
                return [cart.client || 'Unknown'];
            }))];
            const clientColorMap = {};
            clients.forEach((client, index) => {
                clientColorMap[client] = getClientColor(client, index);
            });
            
            // Split carts between trucks if multiple trucks selected
            const cartAssignments = splitCartsBetweenTrucks(routeCarts, assignedTruckIds, routeCapacity);
            
            // Create visualization slots - show carts split by truck
            const slots = [];
            const truckNames = {
                truck1: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck1', 'Truck 1') : 'Truck 1',
                truck2: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck2', 'Truck 2') : 'Truck 2',
                neighbor: typeof i18n !== 'undefined' ? i18n.t('cartLoading.neighborTruck', 'Neighbor\'s Truck') : 'Neighbor\'s Truck',
                external: typeof i18n !== 'undefined' ? i18n.t('cartLoading.externalTruck', 'External Truck') : 'External Truck'
            };
            
            // Show ALL selected trucks, even if empty (user wants to see empty trucks too)
            assignedTruckIds.forEach((truckId, truckIndex) => {
                const truckCarts = cartAssignments[truckId] || [];
                
                // Add truck separator label (except for first truck)
                if (truckIndex > 0) {
                    slots.push({
                        type: 'truck-separator',
                        truckName: truckNames[truckId] || truckId
                    });
                }
                
                // Add carts for this truck
                truckCarts.forEach(cart => {
                    const cartClients = Array.isArray(cart.clients) && cart.clients.length > 0
                        ? cart.clients
                        : [cart.client || 'Unknown'];
                    const cartColors = cartClients.map(c => clientColorMap[c || 'Unknown'] || clientColorMap['Unknown']);
                    const clientColor = clientColorMap[cart.client || cartClients[0] || 'Unknown'];
                    const cartType = cart.type || (cart.cartType || 'standard');
                    slots.push({
                        type: cartType,
                        client: cart.client || cartClients[0] || 'Unknown',
                        clients: cartClients,
                        colors: cartColors,
                        color: clientColor,
                        cartId: cart.id,
                        cartRef: cart,
                        route: route.key,
                        truckId: truckId
                    });
                });
                
                // Fill empty slots for this truck (always fill to capacity, even if truck is empty)
                const perTruckCapacity = routeCapacity.perTruck;
                // Count current slots for this truck (excluding separator)
                let currentTruckSlotCount = slots.filter(s => s.truckId === truckId && s.type !== 'truck-separator').length;
                // Fill up to capacity
                while (currentTruckSlotCount < perTruckCapacity) {
                    slots.push({ type: 'empty', truckId: truckId });
                    currentTruckSlotCount++; // CRITICAL: Update counter to prevent infinite loop
                }
            });
            
            // Add overflow slots if any
            if (routeCapacity.overflow > 0) {
                for (let i = 0; i < routeCapacity.overflow; i++) {
                    slots.push({ type: 'overflow' });
                }
            }
            
            card.innerHTML = `
                <div class="truck-header">
                    <div>
                        <h2 style="margin: 0; color: ${route.color};">${route.name} (${route.time})</h2>
                        <div style="margin-top: 8px;">
                            <span class="badge ${statusClass}">${statusIcon} ${statusText}</span>
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 1.2rem; font-weight: 700; color: ${route.color};">
                            ${routeInfo.totalCarts} / ${routeCapacity.max}
                        </div>
                        <div style="font-size: 0.9rem; color: var(--text-secondary);">
                            ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.totalCarts', 'carts') : 'carts'}
                        </div>
                    </div>
                </div>
                
                ${renderSmartTruckSelector(route.key)}
                ${routeCapacity.truckCount > 1 ? `
                <div style="font-size: 0.85rem; color: var(--success); margin-top: 8px; font-weight: 600;">
                    ‚úì Using ${routeCapacity.truckCount} trucks (${routeCapacity.perTruck} carts each)
                </div>
                ` : ''}
                    
                    ${!routeCapacity.fits && routeCapacity.overflow > 0 ? `
                    <div style="margin-top: 15px; padding: 12px; background: #fef3c7; border-radius: 8px; border-left: 4px solid #f59e0b;">
                        <div style="font-weight: 600; color: #92400e; margin-bottom: 8px;">
                            ‚ö†Ô∏è Still ${routeCapacity.overflow} carts overflow
                        </div>
                        <div style="font-size: 0.9rem; color: #78350f; margin-bottom: 10px;">
                            Add more trucks to handle overflow:
                        </div>
                        <div id="add-truck-buttons-${route.key}" style="display: flex; gap: 8px; flex-wrap: wrap;">
                            ${(() => {
                                // Always show both buttons - allow adding multiple external and neighbor trucks
                                // Count how many of each are already added
                                const externalCount = assignedTruckIds.filter(id => id === 'external').length;
                                const neighborCount = assignedTruckIds.filter(id => id === 'neighbor').length;
                                
                                const externalText = typeof i18n !== 'undefined' ? i18n.t('cartLoading.addExternalTruck', 'Add External Truck') : 'Add External Truck';
                                const neighborText = typeof i18n !== 'undefined' ? i18n.t('cartLoading.addNeighborTruck', 'Add Neighbor\'s Truck') : 'Add Neighbor\'s Truck';
                                
                                // Always show both buttons - can add multiple
                                return `
                                    <button 
                                        type="button"
                                        class="btn btn-primary" 
                                        style="font-size: 0.9rem; padding: 8px 16px; cursor: pointer;"
                                        onclick="addTruckToRoute('${route.key}', 'external')">
                                        + ${externalText}${externalCount > 0 ? ` (${externalCount})` : ''}
                                    </button>
                                    <button 
                                        type="button"
                                        class="btn btn-primary" 
                                        style="font-size: 0.9rem; padding: 8px 16px; cursor: pointer;"
                                        onclick="addTruckToRoute('${route.key}', 'neighbor')">
                                        + ${neighborText}${neighborCount > 0 ? ` (${neighborCount})` : ''}
                                    </button>
                                `;
                            })()}
                        </div>
                    </div>
                    ` : ''}
                </div>
                
                <div class="truck-body">
                    <div class="truck-slots">
                        ${slots.map(slot => {
                            if (slot.type === 'truck-separator') {
                                return `<div class="route-separator-label" style="grid-column: 1 / -1; background: #f0f9ff; border: 2px solid ${route.color}; color: ${route.color}; padding: 8px; border-radius: 6px; margin: 8px 0; font-weight: 600; font-size: 0.9rem; text-align: center;">
                                    ‚îÄ‚îÄ ${slot.truckName} ‚îÄ‚îÄ
                                </div>`;
                            } else if (slot.type === 'standard') {
                                const standardCartText = typeof i18n !== 'undefined' ? i18n.t('cartLoading.standardCart', 'Standard Cart') : 'Standard Cart';
                                const unknownText = typeof i18n !== 'undefined' ? i18n.t('common.unknown', 'Unknown') : 'Unknown';
                                const clients = Array.isArray(slot.clients) && slot.clients.length > 0 ? slot.clients : [slot.client || unknownText];
                                const colors = Array.isArray(slot.colors) && slot.colors.length > 0 ? slot.colors : [slot.color || route.color];
                                const color = colors[0] || route.color;
                                const hexToRgb = (hex) => {
                                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                                    return result ? {
                                        r: parseInt(result[1], 16),
                                        g: parseInt(result[2], 16),
                                        b: parseInt(result[3], 16)
                                    } : null;
                                };
                                const rgb = hexToRgb(color);
                                const darkerColor = rgb ? `rgb(${Math.max(0, rgb.r - 30)}, ${Math.max(0, rgb.g - 30)}, ${Math.max(0, rgb.b - 30)})` : color;
                                const clientIcons = clients.map((client, idx) => {
                                    const initial = client ? client.charAt(0).toUpperCase() : 'S';
                                    const iconColor = colors[idx] || route.color;
                                    return `<span class="cart-client-dot" style="background:${iconColor}" title="${client}">${initial}</span>`;
                                }).join('');
                                return `<div class="cart-slot filled-standard cart-detail-trigger" 
                                         data-cart-id="${slot.cartId || ''}"
                                         style="background: linear-gradient(135deg, ${color} 0%, ${darkerColor} 100%); border: 2px solid ${route.color}; border-left-width: 4px;" 
                                         title="${standardCartText} - ${clients.join(', ')}">${clientIcons}</div>`;
                            } else if (slot.type === 'danish') {
                                const danishCartText = typeof i18n !== 'undefined' ? i18n.t('cartLoading.danishCart', 'Danish Cart') : 'Danish Cart';
                                const unknownText = typeof i18n !== 'undefined' ? i18n.t('common.unknown', 'Unknown') : 'Unknown';
                                const clients = Array.isArray(slot.clients) && slot.clients.length > 0 ? slot.clients : [slot.client || unknownText];
                                const colors = Array.isArray(slot.colors) && slot.colors.length > 0 ? slot.colors : [slot.color || route.color];
                                const color = colors[0] || route.color;
                                const hexToRgb = (hex) => {
                                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                                    return result ? {
                                        r: parseInt(result[1], 16),
                                        g: parseInt(result[2], 16),
                                        b: parseInt(result[3], 16)
                                    } : null;
                                };
                                const rgb = hexToRgb(color);
                                const darkerColor = rgb ? `rgb(${Math.max(0, rgb.r - 30)}, ${Math.max(0, rgb.g - 30)}, ${Math.max(0, rgb.b - 30)})` : color;
                                const clientIcons = clients.map((client, idx) => {
                                    const initial = client ? client.charAt(0).toUpperCase() : 'D';
                                    const iconColor = colors[idx] || route.color;
                                    return `<span class="cart-client-dot" style="background:${iconColor}" title="${client}">${initial}</span>`;
                                }).join('');
                                return `<div class="cart-slot filled-danish cart-detail-trigger" 
                                         data-cart-id="${slot.cartId || ''}"
                                         style="background: linear-gradient(135deg, ${color} 0%, ${darkerColor} 100%); border: 2px solid ${route.color}; border-left-width: 4px;" 
                                         title="${danishCartText} - ${clients.join(', ')}">${clientIcons}</div>`;
                            } else if (slot.type === 'overflow') {
                                const overflowText = typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow';
                                return `<div class="cart-slot overflow" style="border-color: ${route.color};" title="${overflowText}">!</div>`;
                            } else {
                                return '<div class="cart-slot empty" title="Empty"></div>';
                            }
                        }).join('')}
                    </div>
                </div>
                
                ${clients.length > 0 ? `
                <div class="client-legend">
                    <strong style="width: 100%; margin-bottom: 8px; display: block;">${typeof i18n !== 'undefined' ? i18n.t('cartLoading.clientColors', 'Client Colors') : 'Client Colors'}:</strong>
                    ${clients.map(client => {
                        const color = clientColorMap[client];
                        return `
                            <div class="client-legend-item">
                                <div class="client-color-box" style="background: ${color};"></div>
                                <span>${client}</span>
                            </div>
                        `;
                    }).join('')}
                </div>
                ` : ''}
                
                ${!routeCapacity.fits ? `
                <div class="info-box danger" style="margin-top: 15px;">
                    <strong>${typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow'}:</strong> ${routeCapacity.overflow} ${typeof i18n !== 'undefined' ? i18n.t('data.carts', 'carts') : 'carts'} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.dontFit', 'don\'t fit. Consider adding more trucks or external carrier.') : 'don\'t fit. Consider adding more trucks or external carrier.'}
                </div>
                ` : ''}
            `;
            
            return card;
        }
        
        // Prevent multiple simultaneous updates
        let isUpdating = false;
        
        function updateRouteTruck(routeKey, truckSelection) {
            // Prevent multiple simultaneous updates
            if (isUpdating) {
                console.log('Update already in progress, skipping...');
                return;
            }
            
            const previousSelection = routeTruckAssignments[routeKey] || null;
            
            // Handle empty selection
            if (!truckSelection || truckSelection === '') {
                routeTruckAssignments[routeKey] = null;
                localStorage.setItem('zuidplas_route_truck_assignments', JSON.stringify(routeTruckAssignments));
                // Re-run optimization to update visualization
                if (cartLoadingOptimizer && orderManager && orderManager.orders && orderManager.orders.length > 0) {
                    isUpdating = true;
                    try {
                        const result = cartLoadingOptimizer.optimizeAssignment();
                        if (result.routeAnalysis) {
                            localStorage.setItem('zuidplas_route_analysis', JSON.stringify(result.routeAnalysis));
                        }
                        updateTruckVisualization(result);
                    } catch (error) {
                        console.error('Error updating visualization:', error);
                    } finally {
                        isUpdating = false;
                    }
                }
                return;
            }
            
            // Check each selected truck for availability
            const selectedIds = parseTruckAssignment(truckSelection);
            const availableOptions = getSmartTruckOptions(routeKey);
            const unavailable = selectedIds.find(id => {
                const option = availableOptions.find(t => t.id === id);
                return !option || !option.available;
            });
            
            if (unavailable) {
                alert(langText('time_conflict_error', typeof i18n !== 'undefined'
                    ? i18n.t('cartLoading.truckUnavailable', 'This truck combination is unavailable due to time conflict with another route.')
                    : 'This truck combination is unavailable due to time conflict with another route.'));
                routeTruckAssignments[routeKey] = previousSelection;
                // Refresh UI back to previous state
                if (cartLoadingOptimizer && orderManager && orderManager.orders && orderManager.orders.length > 0) {
                    try {
                        const result = cartLoadingOptimizer.optimizeAssignment();
                        if (result.routeAnalysis) {
                            localStorage.setItem('zuidplas_route_analysis', JSON.stringify(result.routeAnalysis));
                        }
                        updateTruckVisualization(result);
                    } catch (error) {
                        console.error('Error updating visualization:', error);
                    }
                }
                return;
            }
            
            routeTruckAssignments[routeKey] = truckSelection;
            
            // Save to localStorage for Truck Management page
            localStorage.setItem('zuidplas_route_truck_assignments', JSON.stringify(routeTruckAssignments));
            
            // Also save route analysis for Truck Management to show cart counts
            if (cartLoadingOptimizer && orderManager && orderManager.orders && orderManager.orders.length > 0) {
                isUpdating = true;
                try {
                    const result = cartLoadingOptimizer.optimizeAssignment();
                    // Save route analysis
                    if (result.routeAnalysis) {
                        localStorage.setItem('zuidplas_route_analysis', JSON.stringify(result.routeAnalysis));
                    }
                    // Update visualization (will refresh all route cards with updated availability)
                    updateTruckVisualization(result);
                } catch (error) {
                    console.error('Error updating truck visualization:', error);
                    alert('Error updating visualization. Please refresh the page.');
                } finally {
                    isUpdating = false;
                }
            }
        }
        
        function addTruckToRoute(routeKey, newTruckId) {
            // Get current truck assignment
            const currentAssignment = routeTruckAssignments[routeKey] || 'truck1';
            const currentTrucks = parseTruckAssignment(currentAssignment);
            
            // Allow multiple external and neighbor trucks - don't check if already added
            // Only check for truck1 and truck2 (can't have multiple of same own truck)
            if ((newTruckId === 'truck1' || newTruckId === 'truck2') && currentTrucks.includes(newTruckId)) {
                alert(typeof i18n !== 'undefined' 
                    ? i18n.t('cartLoading.truckAlreadyAdded', 'This truck is already assigned to this route.')
                    : 'This truck is already assigned to this route.');
                return;
            }
            
            // Check if truck is available (not conflicting)
            const availableOptions = getSmartTruckOptions(routeKey);
            const truckOption = availableOptions.find(t => t.id === newTruckId);
            
            if (!truckOption || !truckOption.available) {
                alert(typeof i18n !== 'undefined' 
                    ? i18n.t('cartLoading.truckUnavailable', 'This truck is unavailable due to time conflict with another route.')
                    : 'This truck is unavailable due to time conflict with another route.');
                return;
            }
            
            // Add new truck to assignment
            const newAssignment = currentTrucks.concat([newTruckId]).join('+');
            updateRouteTruck(routeKey, newAssignment);
        }
        
        // Make it global
        window.addTruckToRoute = addTruckToRoute;
        
        // Make it global
        window.updateRouteTruck = updateRouteTruck;

        // Generate unique color for each client
        function getClientColor(clientName, clientIndex) {
            const colors = [
                '#3b82f6', '#8b5cf6', '#10b981', '#f59e0b', '#ef4444',
                '#06b6d4', '#ec4899', '#84cc16', '#f97316', '#6366f1',
                '#14b8a6', '#a855f7', '#22c55e', '#eab308', '#f43f5e'
            ];
            return colors[clientIndex % colors.length];
        }

        function createTruckCard(truckName, truckData, capacity, expectedRoutes, routeAnalysis = {}) {
            const card = document.createElement('div');
            card.className = 'truck-card';
            
            const routes = Array.from(truckData.routes);
            
            // Calculate route-by-route status
            let routeStatuses = [];
            let hasOverflow = false;
            
            expectedRoutes.forEach(routeName => {
                const routeInfo = routeAnalysis[routeName];
                if (routeInfo) {
                    // CRITICAL: Use route's fits status (from dashboard calculation)
                    // If route has overflow, truck shows overflow
                    const routeFits = routeInfo.fits !== undefined ? routeInfo.fits : (routeInfo.totalCarts <= routeInfo.max);
                    if (!routeFits) hasOverflow = true;
                    
                    // Get route display name
                    const routeDisplayNames = {
                        rijnsburg: typeof i18n !== 'undefined' ? i18n.t('routes.rijnsburg', 'Rijnsburg') : 'Rijnsburg',
                        aalsmeer: typeof i18n !== 'undefined' ? i18n.t('routes.aalsmeer', 'Aalsmeer') : 'Aalsmeer',
                        naaldwijk: typeof i18n !== 'undefined' ? i18n.t('routes.naaldwijk', 'Naaldwijk') : 'Naaldwijk'
                    };
                    
                    routeStatuses.push({
                        name: routeName,
                        displayName: routeDisplayNames[routeName] || routeName,
                        fits: routeFits,
                        routeCarts: routeInfo.totalCarts, // This route's cart count
                        used: routeInfo.used, // This route's equivalent carts
                        max: routeInfo.max, // This route's max capacity
                        overflow: routeInfo.overflow,
                        totalCarts: routeInfo.totalCarts,
                        danishCount: routeInfo.danishCount,
                        standardCount: routeInfo.standardCount
                    });
                }
            });
            
            const statusClass = hasOverflow ? 'danger' : 'success';
            const statusIcon = hasOverflow ? '‚ùå' : '‚úÖ';
            const statusText = hasOverflow ? (typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow') : (typeof i18n !== 'undefined' ? i18n.t('status.fits', 'Fits') : 'Fits');
            
            // Get all unique clients from carts
            const clients = [...new Set(truckData.carts.map(cart => cart.client || 'Unknown'))];
            const clientColorMap = {};
            clients.forEach((client, index) => {
                clientColorMap[client] = getClientColor(client, index);
            });
            
            // Group carts by route for clear separation
            const cartsByRoute = {};
            expectedRoutes.forEach(routeName => {
                cartsByRoute[routeName] = truckData.carts.filter(cart => cart.route === routeName);
            });
            
            // Create route-separated cart slots
            const routeSlots = [];
            
            expectedRoutes.forEach((routeName, routeIndex) => {
                const routeCarts = cartsByRoute[routeName] || [];
                const routeDisplayNames = {
                    rijnsburg: typeof i18n !== 'undefined' ? i18n.t('routes.rijnsburg', 'Rijnsburg') : 'Rijnsburg',
                    aalsmeer: typeof i18n !== 'undefined' ? i18n.t('routes.aalsmeer', 'Aalsmeer') : 'Aalsmeer',
                    naaldwijk: typeof i18n !== 'undefined' ? i18n.t('routes.naaldwijk', 'Naaldwijk') : 'Naaldwijk'
                };
                const routeTime = routeName === 'rijnsburg' ? '09:00' : routeName === 'aalsmeer' ? '10:00' : '11:00';
                const routeLabel = `${routeDisplayNames[routeName]} (${routeTime})`;
                
                // Add route separator label (except for first route)
                if (routeIndex > 0) {
                    routeSlots.push({
                        type: 'route-separator',
                        route: routeName,
                        label: routeLabel
                    });
                }
                
                // Process carts for this route
                routeCarts.forEach(cart => {
                    const clientColor = clientColorMap[cart.client || 'Unknown'];
                    const cartType = cart.type || (cart.cartType || 'standard');
                    routeSlots.push({ 
                        type: cartType, 
                        client: cart.client || 'Unknown',
                        color: clientColor,
                        route: cart.route
                    });
                });
                
                // Add empty slots for this route if needed (only for visualization clarity)
                const routeInfo = routeAnalysis[routeName];
                const routeMaxCapacity = routeInfo ? routeInfo.max : capacity.max;
                const routeCartsCount = routeCarts.length;
                const routeEmptySlots = Math.max(0, routeMaxCapacity - routeCartsCount);
                
                // Only add a few empty slots as visual separator, not all
                if (routeEmptySlots > 0 && routeIndex < expectedRoutes.length - 1) {
                    // Add 1-2 empty slots as visual gap between routes
                    for (let i = 0; i < Math.min(2, routeEmptySlots); i++) {
                        routeSlots.push({ type: 'empty', route: routeName });
                    }
                }
            });

            // Build route breakdown HTML with color-coded sections and cost impact
            let routeBreakdownHTML = '';
            if (routeStatuses.length > 0) {
                routeBreakdownHTML = '<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border);">';
                routeStatuses.forEach(routeStatus => {
                    const routeStatusClass = routeStatus.fits ? 'success' : 'danger';
                    const routeStatusIcon = routeStatus.fits ? '‚úÖ' : '‚ö†Ô∏è';
                    
                    // Calculate cost impact
                    const routeCost = calculateRouteCost(routeStatus);
                    const costImpactHTML = routeCost > 0 
                        ? `<span class="cost-impact negative">+‚Ç¨${routeCost} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.extraCost', 'extra cost') : 'extra cost'}</span>`
                        : '';
                    
                    // Get route section class for color coding
                    const routeSectionClass = routeStatus.name;
                    
                    routeBreakdownHTML += `
                        <div class="route-section ${routeSectionClass}">
                            <div class="route-section-header">
                                <strong>${routeStatus.displayName}</strong>
                                <span class="badge ${routeStatusClass}" style="margin-left: 8px;">${routeStatusIcon} ${routeStatus.fits ? (typeof i18n !== 'undefined' ? i18n.t('status.fits', 'Fits') : 'Fits') : (typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow')}</span>
                                ${costImpactHTML}
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.9rem;">
                                <div><strong>${routeStatus.totalCarts}</strong> ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.totalCarts', 'carts') : 'carts'}</div>
                                <div style="color: var(--text-secondary);">
                                    ${routeStatus.totalCarts} / ${routeStatus.max} ${typeof i18n !== 'undefined' ? i18n.t('status.capacity', 'capacity') : 'capacity'}
                                </div>
                                ${!routeStatus.fits ? `<div style="color: var(--danger); font-weight: 600;">+${routeStatus.overflow} ${typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'overflow') : 'overflow'}</div>` : ''}
                            </div>
                        </div>
                    `;
                });
                routeBreakdownHTML += '</div>';
            }
            
            // Add loading sequence for this truck
            const loadingSequences = calculateLoadingSequence(truckData, routeAnalysis);
            let loadingSequenceHTML = '';
            Object.keys(loadingSequences).forEach(routeName => {
                const sequence = loadingSequences[routeName];
                if (sequence.length === 0) return;
                
                const routeDisplayNames = {
                    rijnsburg: typeof i18n !== 'undefined' ? i18n.t('routes.rijnsburg', 'Rijnsburg') : 'Rijnsburg',
                    aalsmeer: typeof i18n !== 'undefined' ? i18n.t('routes.aalsmeer', 'Aalsmeer') : 'Aalsmeer',
                    naaldwijk: typeof i18n !== 'undefined' ? i18n.t('routes.naaldwijk', 'Naaldwijk') : 'Naaldwijk'
                };
                
                const sequenceId = `loading-seq-${routeName}-${Date.now()}`;
                const showMoreId = `show-more-${routeName}-${Date.now()}`;
                const fullListId = `full-list-${routeName}-${Date.now()}`;
                
                loadingSequenceHTML += `
                    <div class="loading-sequence">
                        <div class="loading-sequence-title">
                            üì¶ ${routeDisplayNames[routeName]} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.loadingSequence', 'Loading Sequence') : 'Loading Sequence'}
                        </div>
                        <div class="loading-sequence-help" style="background: #f0f9ff; padding: 12px; border-radius: 8px; margin: 10px 0; border-left: 4px solid #3b82f6;">
                            <strong style="color: #1e40af;">üìã ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.loadingSequenceHelp', 'How to Load:') : 'How to Load:'}</strong><br>
                            <span style="font-size: 0.9rem; color: #1e3a8a;">
                            ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.lastDeliveryFirst', 'Last delivery first (goes on top)') : 'Last delivery first (goes on top)'}, 
                            ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.firstDeliveryLast', 'first delivery last (goes at bottom)') : 'first delivery last (goes at bottom)'}.<br>
                            <em>${typeof i18n !== 'undefined' ? i18n.t('cartLoading.loadingSequenceExplanation', 'Why? So when unloading, first delivery is on top and easy to access!') : 'Why? So when unloading, first delivery is on top and easy to access!'}</em>
                            </span>
                        </div>
                        <div class="loading-steps" id="${sequenceId}">
                            ${sequence.slice(0, 10).map(item => `
                                <div class="loading-step" title="${item.client} - Step ${item.step}">
                                    <span class="loading-step-number">${item.step}</span>
                                    <span>${item.client.charAt(0).toUpperCase()}</span>
                                </div>
                            `).join('')}
                            ${sequence.length > 10 ? `
                                <button type="button" class="loading-more-btn" onclick="showFullLoadingSequence('${fullListId}', '${showMoreId}', ${sequence.length - 10})">
                                    +${sequence.length - 10} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.more', 'more') : 'more'}
                                </button>
                            ` : ''}
                        </div>
                        ${sequence.length > 10 ? `
                            <div class="loading-full-list" id="${fullListId}" style="display: none;">
                                ${sequence.map(item => `
                                    <div class="loading-full-item">
                                        <span class="loading-step-number">${item.step}</span>
                                        <span><strong>${item.client}</strong></span>
                                        <span style="color: var(--text-secondary); font-size: 0.75rem;">(${item.type === 'danish' ? (typeof i18n !== 'undefined' ? i18n.t('cartLoading.danishCart', 'Danish Cart') : 'Danish Cart') : (typeof i18n !== 'undefined' ? i18n.t('cartLoading.standardCart', 'Standard Cart') : 'Standard Cart')})</span>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            if (loadingSequenceHTML) {
                routeBreakdownHTML += loadingSequenceHTML;
            }
            
            card.innerHTML = `
                <div class="truck-header">
                    <div>
                        <h2 style="margin: 0;">${truckName}</h2>
                        <div style="margin-top: 8px;">
                            <span class="badge ${statusClass}">${statusIcon} ${statusText}</span>
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 0.9rem; color: var(--text-secondary);">
                            ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.routesOnTruck', 'Routes on this truck') : 'Routes on this truck'}: ${routes.length}
                        </div>
                    </div>
                </div>
                ${routeBreakdownHTML}

                <div class="truck-body">
                    <div class="truck-slots">
                        ${routeSlots.map(slot => {
                            if (slot.type === 'standard') {
                                const standardCartText = typeof i18n !== 'undefined' ? i18n.t('cartLoading.standardCart', 'Standard Cart') : 'Standard Cart';
                                const unknownText = typeof i18n !== 'undefined' ? i18n.t('common.unknown', 'Unknown') : 'Unknown';
                                const clients = Array.isArray(slot.clients) && slot.clients.length > 0 ? slot.clients : [slot.client || unknownText];
                                const colors = Array.isArray(slot.colors) && slot.colors.length > 0 ? slot.colors : [slot.color || '#3b82f6'];
                                const clientIcons = clients.map((client, idx) => {
                                    const initial = client ? client.charAt(0).toUpperCase() : 'S';
                                    const color = colors[idx] || '#3b82f6';
                                    return `<span style="display:inline-flex;align-items:center;justify-content:center;width:14px;height:14px;border-radius:50%;background:${color};color:#fff;font-size:10px;font-weight:600;margin-right:2px;">${initial}</span>`;
                                }).join('');
                                return `<div class="cart-slot filled-standard" 
                                         style="background: #ffffff; border-color: ${colors[0] || '#3b82f6'}; display:flex; align-items:center; justify-content:center; gap:2px; padding:2px;" 
                                         title="${standardCartText} - ${clients.join(', ')}">${clientIcons}</div>`;
                            } else if (slot.type === 'danish') {
                                const danishCartText = typeof i18n !== 'undefined' ? i18n.t('cartLoading.danishCart', 'Danish Cart') : 'Danish Cart';
                                const unknownText = typeof i18n !== 'undefined' ? i18n.t('common.unknown', 'Unknown') : 'Unknown';
                                const clients = Array.isArray(slot.clients) && slot.clients.length > 0 ? slot.clients : [slot.client || unknownText];
                                const colors = Array.isArray(slot.colors) && slot.colors.length > 0 ? slot.colors : [slot.color || '#8b5cf6'];
                                const clientIcons = clients.map((client, idx) => {
                                    const initial = client ? client.charAt(0).toUpperCase() : 'D';
                                    const color = colors[idx] || '#8b5cf6';
                                    return `<span style="display:inline-flex;align-items:center;justify-content:center;width:14px;height:14px;border-radius:50%;background:${color};color:#fff;font-size:10px;font-weight:600;margin-right:2px;">${initial}</span>`;
                                }).join('');
                                return `<div class="cart-slot filled-danish" 
                                         style="background: #ffffff; border-color: ${colors[0] || '#8b5cf6'}; display:flex; align-items:center; justify-content:center; gap:2px; padding:2px;" 
                                         title="${danishCartText} - ${clients.join(', ')}">${clientIcons}</div>`;
                            } else if (slot.type === 'overflow') {
                                const overflowText = typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow';
                                return `<div class="cart-slot overflow" title="${overflowText}">!</div>`;
                            } else {
                                return '<div class="cart-slot empty" title="Empty"></div>';
                            }
                        }).join('')}
                    </div>
                </div>
                
                ${clients.length > 0 ? `
                <div class="client-legend">
                    <strong style="width: 100%; margin-bottom: 8px; display: block;">${typeof i18n !== 'undefined' ? i18n.t('cartLoading.clientColors', 'Client Colors') : 'Client Colors'}:</strong>
                    ${clients.map(client => {
                        const color = clientColorMap[client];
                        return `
                            <div class="client-legend-item">
                                <div class="client-color-box" style="background: ${color};"></div>
                                <span>${client}</span>
                            </div>
                        `;
                    }).join('')}
                </div>
                ` : ''}

                <div class="capacity-indicator">
                    <div class="capacity-bar">
                        <div class="capacity-fill ${capacity.utilization > 90 ? 'danger' : capacity.utilization > 75 ? 'warning' : ''}" 
                             style="width: ${capacity.utilization}%"></div>
                    </div>
                    <div style="font-size: 0.9rem; color: var(--text-secondary);">
                        ${capacity.standard} ${capacity.standard === 1 
                            ? (typeof i18n !== 'undefined' ? i18n.t('cartLoading.standardCart', 'Standard Cart') : 'Standard Cart')
                            : (typeof i18n !== 'undefined' ? i18n.t('cartLoading.standardCarts', 'Standard Carts') : 'Standard Carts')} + 
                        ${capacity.danish} ${capacity.danish === 1 
                            ? (typeof i18n !== 'undefined' ? i18n.t('cartLoading.danishCart', 'Danish Cart') : 'Danish Cart')
                            : (typeof i18n !== 'undefined' ? i18n.t('cartLoading.danishCarts', 'Danish Carts') : 'Danish Carts')}
                    </div>
                </div>

                <div class="route-assignment">
                    <strong>Routes:</strong>
                ${routes.map(route => {
                        const routeName = route === 'rijnsburg' ? 'Rijnsburg (09:00)' :
                                         route === 'aalsmeer' ? 'Aalsmeer (10:00)' :
                                         route === 'naaldwijk' ? 'Naaldwijk (11:00)' :
                                         route === 'rijnsburg_evening' ? 'Rijnsburg (17:00)' :
                                         route === 'aalsmeer_evening' ? 'Aalsmeer (18:00)' :
                                         route === 'naaldwijk_evening' ? 'Naaldwijk (19:00)' : route;
                        const routeClass = `route-${route}`;
                        return `<span class="route-badge ${routeClass}">${routeName}</span>`;
                    }).join('')}
                    ${routes.length === 0 ? '<span style="color: var(--text-secondary);">No routes assigned</span>' : ''}
                </div>

                ${capacity.overflow > 0 ? `
                <div class="info-box danger" style="margin-top: 15px;">
                    <strong>${typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow'}:</strong> ${capacity.overflow} ${typeof i18n !== 'undefined' ? i18n.t('data.carts', 'carts') : 'carts'} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.dontFit', 'don\'t fit. Consider external carrier or neighbor\'s truck.') : 'don\'t fit. Consider external carrier or neighbor\'s truck.'}
                </div>
                ` : ''}
            `;

            return card;
        }

        function updateCartList(allCarts) {
            const container = document.getElementById('cart-list-by-route');
            container.innerHTML = '';
            window.__cartDetailMap = (allCarts || []).reduce((acc, cart) => {
                if (cart && cart.id) acc[cart.id] = cart;
                return acc;
            }, {});

            const cartsByRoute = {
                rijnsburg_morning: [],
                aalsmeer_morning: [],
                naaldwijk_morning: [],
                rijnsburg_evening: [],
                aalsmeer_evening: [],
                naaldwijk_evening: []
            };

            allCarts.forEach(cart => {
                const key = cart.routeKey || `${cart.route}_${cart.period || 'morning'}`;
                if (cartsByRoute[key]) {
                    cartsByRoute[key].push(cart);
                }
            });

            // Get truck names mapping
            const truckNames = {
                truck1: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck1', 'Truck 1') : 'Truck 1',
                truck2: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck2', 'Truck 2') : 'Truck 2',
                neighbor: typeof i18n !== 'undefined' ? i18n.t('cartLoading.neighborTruck', 'Neighbor\'s Truck') : 'Neighbor\'s Truck',
                external: typeof i18n !== 'undefined' ? i18n.t('cartLoading.externalTruck', 'External Truck') : 'External Truck'
            };

            Object.keys(ROUTES).forEach(routeKey => {
                const route = ROUTES[routeKey];
                const cartsKey = ['rijnsburg', 'aalsmeer', 'naaldwijk'].includes(routeKey)
                    ? `${routeKey}_morning`
                    : routeKey;
                const carts = cartsByRoute[cartsKey] || [];
                
                // Get the actual selected truck assignment for this route
                const assignedTrucksStr = routeTruckAssignments[cartsKey] || null;
                let truckDisplayName = typeof i18n !== 'undefined' ? i18n.t('cartLoading.notAssigned', 'Not Assigned') : 'Not Assigned';
                
                if (assignedTrucksStr) {
                    const assignedTruckIds = parseTruckAssignment(assignedTrucksStr);
                    // If only one truck, show its name. If multiple, show "Truck 1 + Truck 2" format
                    if (assignedTruckIds.length === 1) {
                        truckDisplayName = truckNames[assignedTruckIds[0]] || assignedTruckIds[0];
                    } else {
                        // Multiple trucks - show combined name
                        truckDisplayName = assignedTruckIds.map(id => truckNames[id] || id).join(' + ');
                    }
                }
                
                const routeCard = document.createElement('div');
                routeCard.className = 'card';
                routeCard.style.marginBottom = '20px';
                
                routeCard.innerHTML = `
                    <h3>Route ${route.id}: ${route.name} (${route.departureTime})</h3>
                    <div class="cart-list">
                        ${carts.length > 0 ? carts.map(cart => {
                            const cartTypeText = cart.type === 'danish' 
                                ? (typeof i18n !== 'undefined' ? i18n.t('cartLoading.danishCart', 'Danish Cart') : 'Danish Cart')
                                : (typeof i18n !== 'undefined' ? i18n.t('cartLoading.standardCart', 'Standard Cart') : 'Standard Cart');
                            const cartClients = Array.isArray(cart.clients) && cart.clients.length > 0
                                ? cart.clients
                                : [cart.client || 'Unknown'];
                            const clientBadges = cartClients.map(client => {
                                const color = clientColorMap[client] || getClientColor(client, 0);
                                const initial = client ? client.charAt(0).toUpperCase() : '?';
                                return `<span style="display:inline-flex;align-items:center;gap:6px;margin-right:8px;">
                                            <span style="width:10px;height:10px;border-radius:50%;background:${color};display:inline-block;"></span>
                                            <span style="font-size:0.85rem;">${client}</span>
                                        </span>`;
                            }).join('');
                            return `
                                <div class="cart-item ${cart.type} cart-detail-trigger" data-cart-id="${cart.id || ''}">
                                    <div>
                                        <strong>${cartClients.length > 1 ? 'Multiple Clients' : cartClients[0]}</strong>
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 4px;">
                                            ${cartTypeText}
                                        </div>
                                        <div style="margin-top: 6px; display: flex; flex-wrap: wrap; gap: 6px;">
                                            ${clientBadges}
                                        </div>
                                    </div>
                                    <div style="text-align:right;">
                                        <span class="badge ${cart.type === 'danish' ? 'primary' : 'info'}">
                                            ${cart.type === 'danish' ? 'D' : 'S'}
                                        </span>
                                        <div style="margin-top:6px;font-size:0.75rem;color:var(--text-secondary);">
                                            Click for layers
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('') : '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">No carts for this route</div>'}
                    </div>
                `;
                
                container.appendChild(routeCard);
            });
        }

        function getCartLayerConfig(cart) {
            const fustTypeCode = String(cart.fustTypeCode || cart.fustType || '612').split(' ')[0];
            const isDanish = cart.type === 'danish';
            const capacity = cart.capacity || (window.RouteMapping && window.RouteMapping.getCartCapacity
                ? window.RouteMapping.getCartCapacity(fustTypeCode, isDanish)
                : 72);

            if (isDanish) {
                const danishLayers = {
                    '902': { layers: 4, perLayer: 6 },
                    '996': { layers: 4, perLayer: 8 },
                    '612': { layers: 4, perLayer: Math.max(1, Math.round(capacity / 4)) },
                    '614': { layers: 4, perLayer: Math.max(1, Math.round(capacity / 4)) }
                };
                const config = danishLayers[fustTypeCode] || { layers: 4, perLayer: Math.max(1, Math.round(capacity / 4)) };
                return { ...config, capacity };
            }

            const standardLayers = {
                '612': { layers: 3, perLayer: 24 },
                '614': { layers: 3, perLayer: 24 },
                '575': { layers: 2, perLayer: 16 },
                '996': { layers: 2, perLayer: 16 },
                '902': { layers: 4, perLayer: 10 },
                '588': { layers: 4, perLayer: 10 },
                '821': { layers: 4, perLayer: 10 },
                '856': { layers: 4, perLayer: 5 }
            };
            const config = standardLayers[fustTypeCode] || { layers: 3, perLayer: Math.max(1, Math.round(capacity / 3)) };
            return { ...config, capacity };
        }

        function buildCartLayers(cart) {
            const { layers, perLayer, capacity } = getCartLayerConfig(cart);
            const usedSlots = Math.max(0, Math.min(capacity, Math.round(cart.usedSlots || capacity)));
            const clients = Array.isArray(cart.clients) && cart.clients.length > 0 ? cart.clients : [cart.client || 'Unknown'];
            const clientColors = {};
            clients.forEach((client, idx) => {
                clientColors[client] = getClientColor(client, idx);
            });

            const slotClients = [];
            for (let i = 0; i < usedSlots; i++) {
                slotClients.push(clients[i % clients.length]);
            }

            const layerCaps = [];
            let remaining = capacity;
            for (let i = 0; i < layers; i++) {
                const cap = i === layers - 1 ? remaining : Math.min(perLayer, remaining);
                layerCaps.push(cap);
                remaining = Math.max(0, remaining - cap);
            }

            const layerData = [];
            let slotIndex = 0;
            layerCaps.forEach((cap, idx) => {
                const items = [];
                for (let s = 0; s < cap; s++) {
                    if (slotIndex < usedSlots) {
                        const client = slotClients[slotIndex];
                        items.push({
                            client,
                            color: clientColors[client],
                            crateType: cart.fustTypeCode || String(cart.fustType || '612').split(' ')[0]
                        });
                        slotIndex += 1;
                    } else {
                        items.push(null);
                    }
                }
                const used = items.filter(Boolean).length;
                layerData.push({
                    index: idx,
                    capacity: cap,
                    used,
                    empty: cap - used,
                    slots: items
                });
            });

            return { layerData, clientColors, capacity, usedSlots };
        }

        function openCartDetail(cartId) {
            const cart = window.__cartDetailMap ? window.__cartDetailMap[cartId] : null;
            if (!cart) return;

            const modal = document.getElementById('cart-detail-modal');
            const title = document.getElementById('cart-detail-title');
            const body = document.getElementById('cart-detail-body');
            if (!modal || !title || !body) return;

            const cartTypeText = cart.type === 'danish'
                ? (typeof i18n !== 'undefined' ? i18n.t('cartLoading.danishCart', 'Danish Cart') : 'Danish Cart')
                : (typeof i18n !== 'undefined' ? i18n.t('cartLoading.standardCart', 'Standard Cart') : 'Standard Cart');
            const routeLabel = `${cart.route || ''} ${cart.period || ''}`.trim();
            title.textContent = `${cartTypeText} ‚Ä¢ ${routeLabel}`;

            const { layerData, clientColors, capacity, usedSlots } = buildCartLayers(cart);
            const emptySlots = Math.max(0, capacity - usedSlots);
            const emptyLayers = layerData.filter(layer => layer.used === 0).length;
            const clients = Array.isArray(cart.clients) && cart.clients.length > 0 ? cart.clients : [cart.client || 'Unknown'];
            const crateType = cart.fustTypeCode || String(cart.fustType || '612').split(' ')[0];

            const capacityNote = emptySlots === 0
                ? 'No free shelves ‚Äì next order creates new cart.'
                : `${emptyLayers} shelves left`;

            body.innerHTML = `
                <div class="cart-detail-summary">
                    <div><strong>Cart Type:</strong> ${cartTypeText}</div>
                    <div><strong>Crate Type:</strong> ${crateType}</div>
                    <div><strong>Used:</strong> ${usedSlots} / ${capacity}</div>
                    <div><strong>Empty:</strong> ${emptySlots} (${emptyLayers} shelves)</div>
                    <div><strong>Capacity Note:</strong> ${capacityNote}</div>
                </div>
                ${layerData.map(layer => `
                    <div class="cart-layer">
                        <div class="cart-layer-title">
                            <span>Layer ${layer.index + 1} (top ‚Üí bottom)</span>
                            <span>${layer.used}/${layer.capacity} used, ${layer.empty} empty</span>
                        </div>
                        <div class="cart-layer-grid" style="grid-template-columns: repeat(${layer.capacity}, 14px);">
                            ${layer.slots.map(slot => slot ? `
                                <div class="cart-layer-slot" style="background:${slot.color}" title="${slot.client} ‚Ä¢ ${slot.crateType}">
                                    ${slot.client ? slot.client.charAt(0).toUpperCase() : ''}
                                </div>
                            ` : `
                                <div class="cart-layer-slot empty" title="Empty">‚Äî</div>
                            `).join('')}
                        </div>
                    </div>
                `).join('')}
                <div class="cart-detail-legend">
                    ${clients.map(client => `
                        <div class="cart-detail-legend-item">
                            <span class="cart-detail-legend-color" style="background:${clientColors[client]}"></span>
                            <span>${client}</span>
                        </div>
                    `).join('')}
                </div>
            `;

            modal.classList.add('active');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeCartDetail() {
            const modal = document.getElementById('cart-detail-modal');
            if (!modal) return;
            modal.classList.remove('active');
            modal.setAttribute('aria-hidden', 'true');
        }

        document.addEventListener('click', (event) => {
            const trigger = event.target.closest('.cart-detail-trigger');
            if (trigger) {
                const cartId = trigger.getAttribute('data-cart-id');
                if (cartId) openCartDetail(cartId);
                return;
            }
            const modal = document.getElementById('cart-detail-modal');
            if (modal && event.target === modal) {
                closeCartDetail();
            }
        });

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                closeCartDetail();
            }
        });

        function updateSummaryStats(result) {
            // CRITICAL: Use CACHED cart count from Dashboard, not allCarts.length!
            let totalCartsFromCache = 0;
            if (window.CartCalculation && window.CartCalculation.getGlobalOrdersAndCarts) {
                const globalData = window.CartCalculation.getGlobalOrdersAndCarts(); // NO forceRefresh - only reads cache!
                totalCartsFromCache = globalData.cartResult.total || 0;
                console.log(`‚úÖ updateSummaryStats: Using cached cart count: ${totalCartsFromCache} carts`);
            } else {
                // Fallback to result.allCarts.length if cache not available
                totalCartsFromCache = result.allCarts ? result.allCarts.length : 0;
                console.warn(`‚ö†Ô∏è updateSummaryStats: Cache not available, using allCarts.length: ${totalCartsFromCache}`);
            }
            
            const allCarts = result.allCarts;
            const truck1Capacity = cartLoadingOptimizer.getTruckCapacity('truck1');
            const truck2Capacity = cartLoadingOptimizer.getTruckCapacity('truck2');
            const totalOverflow = truck1Capacity.overflow + truck2Capacity.overflow;
            let routesCovered = 0;
            if (window.CartCalculation && window.CartCalculation.getGlobalOrdersAndCarts) {
                const globalData = window.CartCalculation.getGlobalOrdersAndCarts();
                const cartResult = globalData.cartResult || {};
                const routeNames = ['Rijnsburg', 'Aalsmeer', 'Naaldwijk'];
                ['morning', 'evening'].forEach(period => {
                    routeNames.forEach(routeName => {
                        const count = cartResult?.[period]?.byRoute?.[routeName] || 0;
                        if (count > 0) routesCovered += 1;
                    });
                });
            } else {
                routesCovered = new Set([...result.truck1.routes, ...result.truck2.routes]).size;
            }

            // Use cached cart count (from Dashboard) instead of allCarts.length
            document.getElementById('total-carts').textContent = totalCartsFromCache;
            document.getElementById('carts-assigned').textContent = result.truck1.carts.length + result.truck2.carts.length;
            document.getElementById('overflow-count').textContent = totalOverflow;
            document.getElementById('routes-covered').textContent = `${routesCovered}/6`;
        }

        // Feature 1: Route Timeline Visualization
        function updateRouteTimeline(result) {
            const timelineContainer = document.querySelector('#route-timeline .timeline-container');
            const timelineDiv = document.getElementById('route-timeline');
            
            if (!timelineContainer) {
                if (timelineDiv) timelineDiv.style.display = 'none';
                return;
            }
            
            // CRITICAL: Get cart counts from SINGLE SOURCE OF TRUTH
            let cartResult = null;
            if (window.CartCalculation && window.CartCalculation.getGlobalOrdersAndCarts) {
                const globalData = window.CartCalculation.getGlobalOrdersAndCarts();
                cartResult = globalData.cartResult;
                console.log('‚úÖ Route Timeline: Using cart counts from SINGLE SOURCE');
            }
            
            if (!cartResult) {
                if (timelineDiv) timelineDiv.style.display = 'none';
                return;
            }
            
            timelineDiv.style.display = 'block';
            
            const routes = [
                { key: 'rijnsburg_morning', time: '09:00', name: typeof i18n !== 'undefined' ? i18n.t('routes.rijnsburg', 'Rijnsburg') : 'Rijnsburg', class: 'route1', routeName: 'Rijnsburg', period: 'morning' },
                { key: 'aalsmeer_morning', time: '10:00', name: typeof i18n !== 'undefined' ? i18n.t('routes.aalsmeer', 'Aalsmeer') : 'Aalsmeer', class: 'route2', routeName: 'Aalsmeer', period: 'morning' },
                { key: 'naaldwijk_morning', time: '11:00', name: typeof i18n !== 'undefined' ? i18n.t('routes.naaldwijk', 'Naaldwijk') : 'Naaldwijk', class: 'route3', routeName: 'Naaldwijk', period: 'morning' },
                { key: 'rijnsburg_evening', time: '17:00', name: typeof i18n !== 'undefined' ? i18n.t('routes.rijnsburg', 'Rijnsburg') : 'Rijnsburg', class: 'route1', routeName: 'Rijnsburg', period: 'evening' },
                { key: 'aalsmeer_evening', time: '18:00', name: typeof i18n !== 'undefined' ? i18n.t('routes.aalsmeer', 'Aalsmeer') : 'Aalsmeer', class: 'route2', routeName: 'Aalsmeer', period: 'evening' },
                { key: 'naaldwijk_evening', time: '19:00', name: typeof i18n !== 'undefined' ? i18n.t('routes.naaldwijk', 'Naaldwijk') : 'Naaldwijk', class: 'route3', routeName: 'Naaldwijk', period: 'evening' }
            ];
            
            // Determine which truck handles which route
            const truck1Routes = result.truck1 ? Array.from(result.truck1.routes) : [];
            const truck2Routes = result.truck2 ? Array.from(result.truck2.routes) : [];
            
            timelineContainer.innerHTML = '<div class="timeline-connector"></div>';
            
            routes.forEach(route => {
                // Get cart count from SINGLE SOURCE (cartResult)
                const carts = cartResult[route.period]?.byRoute?.[route.routeName] || 0;
                const maxCapacity = 17;
                const fits = carts <= maxCapacity;
                
                // Determine truck assignment
                const assigned = routeTruckAssignments[route.key] || null;
                let truckName = typeof i18n !== 'undefined' ? i18n.t('cartLoading.notAssigned', 'Not Assigned') : 'Not Assigned';
                if (assigned) {
                    const assignedTruckIds = parseTruckAssignment(assigned);
                    const names = {
                        truck1: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck1', 'Truck 1') : 'Truck 1',
                        truck2: typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck2', 'Truck 2') : 'Truck 2',
                        neighbor: typeof i18n !== 'undefined' ? i18n.t('cartLoading.neighborTruck', 'Neighbor\'s Truck') : 'Neighbor\'s Truck',
                        external: typeof i18n !== 'undefined' ? i18n.t('cartLoading.externalTruck', 'External Truck') : 'External Truck'
                    };
                    truckName = assignedTruckIds.map(id => names[id] || id).join(' + ');
                } else {
                    const isTruck1 = truck1Routes.includes(route.key);
                    truckName = isTruck1 
                        ? (typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck1', 'Truck 1') : 'Truck 1')
                        : (truck2Routes.includes(route.key) 
                            ? (typeof i18n !== 'undefined' ? i18n.t('cartLoading.truck2', 'Truck 2') : 'Truck 2')
                            : (typeof i18n !== 'undefined' ? i18n.t('cartLoading.notAssigned', 'Not Assigned') : 'Not Assigned'));
                }
                
                const statusIcon = fits ? '‚úÖ' : '‚ö†Ô∏è';
                const statusText = fits 
                    ? (typeof i18n !== 'undefined' ? i18n.t('status.fits', 'Fits') : 'Fits')
                    : (typeof i18n !== 'undefined' ? i18n.t('status.overflow', 'Overflow') : 'Overflow');
                
                const point = document.createElement('div');
                point.className = 'timeline-point';
                point.innerHTML = `
                    <div class="timeline-time ${route.class}">${route.time}</div>
                    <div class="timeline-route-info">
                        <strong>${route.name}</strong>
                        <div class="timeline-truck">${truckName}</div>
                        <div style="margin-top: 5px;">
                            <span>${statusIcon} ${statusText}</span>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 4px;">
                                ${carts} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.totalCarts', 'carts') : 'carts'}
                            </div>
                        </div>
                    </div>
                `;
                timelineContainer.appendChild(point);
            });
        }

        // Feature 2 & 3: Color-Coded Route Sections & Cost Impact
        function calculateRouteCost(routeInfo) {
            if (!routeInfo || routeInfo.fits) return 0;
            
            // Cost constants (matching optimizer.js)
            const OWN_TRUCK_COST = 150;
            const EXTERNAL_CARRIER_PER_CART = 25;
            
            // If overflow, calculate external carrier cost
            return routeInfo.overflow * EXTERNAL_CARRIER_PER_CART;
        }

        // Feature 4: Generate Alternative Assignments
        function generateAlternatives(result) {
            const alternativesToggle = document.getElementById('alternatives-toggle');
            const alternativesContainer = document.getElementById('alternatives-container');
            
            if (!result.routeAnalysis) {
                if (alternativesToggle) alternativesToggle.style.display = 'none';
                return;
            }
            
            alternativesToggle.style.display = 'block';
            
            // Generate alternative scenarios
            const alternatives = [];
            const route1 = result.routeAnalysis.rijnsburg;
            const route2 = result.routeAnalysis.aalsmeer;
            const route3 = result.routeAnalysis.naaldwijk;
            
            // Alternative 1: Current (default)
            alternatives.push({
                id: 'current',
                name: typeof i18n !== 'undefined' ? i18n.t('cartLoading.currentAssignment', 'Current Assignment') : 'Current Assignment',
                description: typeof i18n !== 'undefined' ? i18n.t('cartLoading.currentDesc', 'Truck 1: Route 1 + Route 3, Truck 2: Route 2') : 'Truck 1: Route 1 + Route 3, Truck 2: Route 2',
                cost: calculateTotalCost(result.routeAnalysis),
                recommended: true,
                routes: {
                    truck1: ['rijnsburg', 'naaldwijk'],
                    truck2: ['aalsmeer']
                }
            });
            
            // Alternative 2: Swap Route 3 to Truck 2 (if Route 2 fits)
            if (route2 && route2.fits && route3 && route3.totalCarts <= 17) {
                alternatives.push({
                    id: 'swap-route3',
                    name: typeof i18n !== 'undefined' ? i18n.t('cartLoading.alternative1', 'Alternative: Route 3 on Truck 2') : 'Alternative: Route 3 on Truck 2',
                    description: typeof i18n !== 'undefined' ? i18n.t('cartLoading.alt1Desc', 'Truck 1: Route 1 only, Truck 2: Route 2 + Route 3') : 'Truck 1: Route 1 only, Truck 2: Route 2 + Route 3',
                    cost: calculateTotalCost(result.routeAnalysis, { route3ToTruck2: true }),
                    recommended: false,
                    routes: {
                        truck1: ['rijnsburg'],
                        truck2: ['aalsmeer', 'naaldwijk']
                    }
                });
            }
            
            // Store alternatives for toggle function
            window.currentAlternatives = alternatives;
        }

        function calculateTotalCost(routeAnalysis, options = {}) {
            const OWN_TRUCK_COST = 150;
            const EXTERNAL_CARRIER_PER_CART = 25;
            
            let cost = 0;
            
            if (options.route3ToTruck2) {
                // Alternative: Route 3 on Truck 2
                cost += OWN_TRUCK_COST; // Truck 1: Route 1
                cost += OWN_TRUCK_COST; // Truck 2: Route 2 + Route 3
                
                // Check overflow
                const route1Overflow = routeAnalysis.rijnsburg ? (routeAnalysis.rijnsburg.overflow || 0) : 0;
                const route2Overflow = routeAnalysis.aalsmeer ? (routeAnalysis.aalsmeer.overflow || 0) : 0;
                const route3Overflow = routeAnalysis.naaldwijk ? (routeAnalysis.naaldwijk.overflow || 0) : 0;
                cost += (route1Overflow + route2Overflow + route3Overflow) * EXTERNAL_CARRIER_PER_CART;
            } else {
                // Default: Route 3 on Truck 1
                cost += OWN_TRUCK_COST; // Truck 1: Route 1 + Route 3
                cost += OWN_TRUCK_COST; // Truck 2: Route 2
                
                // Check overflow
                const route1Overflow = routeAnalysis.rijnsburg ? (routeAnalysis.rijnsburg.overflow || 0) : 0;
                const route2Overflow = routeAnalysis.aalsmeer ? (routeAnalysis.aalsmeer.overflow || 0) : 0;
                const route3Overflow = routeAnalysis.naaldwijk ? (routeAnalysis.naaldwijk.overflow || 0) : 0;
                cost += (route1Overflow + route2Overflow + route3Overflow) * EXTERNAL_CARRIER_PER_CART;
            }
            
            return cost;
        }

        function toggleAlternatives() {
            const container = document.getElementById('alternatives-container');
            const button = document.querySelector('#alternatives-toggle button');
            
            if (!container || !window.currentAlternatives) return;
            
            if (container.style.display === 'none' || !container.style.display) {
                container.style.display = 'grid';
                if (button) {
                    button.textContent = typeof i18n !== 'undefined' 
                        ? i18n.t('cartLoading.hideAlternatives', 'Hide Alternatives')
                        : 'Hide Alternatives';
                }
                
                container.innerHTML = '';
                window.currentAlternatives.forEach(alt => {
                    const card = document.createElement('div');
                    card.className = `alternative-card ${alt.recommended ? 'recommended' : ''}`;
                    card.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div>
                                <h3 style="margin: 0; font-size: 1rem;">${alt.name}</h3>
                                ${alt.recommended ? `<span class="badge success" style="margin-top: 5px;">${typeof i18n !== 'undefined' ? i18n.t('cartLoading.recommended', 'Recommended') : 'Recommended'}</span>` : ''}
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 1.2rem; font-weight: 700; color: var(--primary);">‚Ç¨${alt.cost}</div>
                            </div>
                        </div>
                        <p style="font-size: 0.9rem; color: var(--text-secondary); margin: 10px 0;">${alt.description}</p>
                    `;
                    container.appendChild(card);
                });
            } else {
                container.style.display = 'none';
                if (button) {
                    button.textContent = typeof i18n !== 'undefined' 
                        ? i18n.t('cartLoading.showAlternatives', 'Show Alternative Assignments')
                        : 'Show Alternative Assignments';
                }
            }
        }

        // Feature 5: Loading Sequence Optimization
        function calculateLoadingSequence(truckData, routeAnalysis) {
            const sequences = {};
            const routes = Array.from(truckData.routes);
            
            routes.forEach(routeName => {
                const routeCarts = truckData.carts.filter(cart => cart.route === routeName);
                const routeInfo = routeAnalysis[routeName];
                
                if (routeCarts.length === 0) return;
                
                // Sort carts: Last delivery first (LIFO - Last In First Out)
                // Group by client, then sort by delivery location/priority
                const sortedCarts = [...routeCarts].sort((a, b) => {
                    // Danish carts might need special handling
                    if (a.type === 'danish' && b.type !== 'danish') return 1;
                    if (a.type !== 'danish' && b.type === 'danish') return -1;
                    return 0;
                });
                
                sequences[routeName] = sortedCarts.map((cart, index) => ({
                    step: index + 1,
                    client: cart.client || 'Unknown',
                    type: cart.type || 'standard',
                    route: routeName
                }));
            });
            
            return sequences;
        }

        // Show full loading sequence when "+X more" is clicked
        function showFullLoadingSequence(fullListId, showMoreId, remainingCount) {
            const fullList = document.getElementById(fullListId);
            const showMoreBtn = document.querySelector(`button[onclick*="${fullListId}"]`);
            
            if (!fullList) return;
            
            if (fullList.style.display === 'none' || !fullList.style.display) {
                fullList.style.display = 'block';
                if (showMoreBtn) {
                    showMoreBtn.textContent = typeof i18n !== 'undefined' 
                        ? i18n.t('cartLoading.hideFullList', 'Hide Full List')
                        : 'Hide Full List';
                }
            } else {
                fullList.style.display = 'none';
                if (showMoreBtn) {
                    showMoreBtn.textContent = `+${remainingCount} ${typeof i18n !== 'undefined' ? i18n.t('cartLoading.more', 'more') : 'more'}`;
                }
            }
        }

        // Check on page load - auto-load orders from global state
        document.addEventListener('DOMContentLoaded', () => {
            // Wait for i18n and appState to be fully initialized
            function checkOrdersAndDisplay() {
                if (typeof i18n === 'undefined' || typeof window.appState === 'undefined') {
                    setTimeout(checkOrdersAndDisplay, 100);
                    return;
                }
                
                // Ensure language is set correctly
                const savedLang = localStorage.getItem('zuidplas_language') || 
                                  localStorage.getItem('zuidplas_user_language') || 
                                  'nl';
                if (i18n.currentLang !== savedLang) {
                    i18n.setLanguage(savedLang);
                }
                
                // CRITICAL: Use SINGLE SOURCE OF TRUTH for orders and cart calculation
                // This ensures ALL pages show the SAME numbers!
                console.log('üîÑ Cart Optimization: Loading orders from SINGLE SOURCE...');
                let orders = [];
                let cartResult = null;
                
                // CRITICAL: Get data from single source (Dashboard's cache)
                // forceRefresh = FALSE (only Dashboard can force refresh!)
                if (window.CartCalculation && window.CartCalculation.getGlobalOrdersAndCarts) {
                    console.log('üõí Cart Optimization: Using SINGLE SOURCE OF TRUTH (getGlobalOrdersAndCarts)...');
                    
                    // CRITICAL: Get cache from Dashboard (SAME SOURCE OF TRUTH)
                    const globalData = window.CartCalculation.getGlobalOrdersAndCarts(false);
                    orders = globalData.orders;
                    cartResult = globalData.cartResult;
                    
                    // CRITICAL: Check if cartResult is valid
                    if (!cartResult || cartResult.total === 0) {
                        console.error('‚ùå No cart calculation found!');
                        console.error('‚ùå Please go to Dashboard and click "Sync" or "Refresh Data" first!');
                        showError('No data available. Please sync data from Dashboard first.');
                        return;
                    }
                    
                    // CRITICAL: Ensure matchedOrdersCount is set from uniqueOrderIds
                    if (window.AppData && window.AppData.uniqueOrderIds && window.AppData.uniqueOrderIds.size > 0) {
                        cartResult.matchedOrdersCount = window.AppData.uniqueOrderIds.size;
                        console.log(`‚úÖ Using unique orders count from AppData: ${cartResult.matchedOrdersCount}`);
                    } else if (!cartResult.matchedOrdersCount && orders && orders.length > 0) {
                        // Count unique orders from orders array as fallback
                        const uniqueIds = new Set();
                        orders.forEach(o => {
                            const orderId = o.order_id || o.order?.id || o.order?.order_id || o.id;
                            if (orderId) uniqueIds.add(String(orderId));
                        });
                        cartResult.matchedOrdersCount = uniqueIds.size;
                        console.log(`‚úÖ Counted unique orders from array: ${cartResult.matchedOrdersCount}`);
                    }
                    
                    // CRITICAL: Log the correct counts
                    console.log(`‚úÖ Cart Optimization: Loaded ${cartResult.matchedOrdersCount || 'N/A'} UNIQUE orders (from ${orders.length} orderrows)`);
                    console.log(`‚úÖ Cart Optimization: Cart result - ${cartResult.total} carts`);
                    const cacheData = JSON.parse(localStorage.getItem(`ZUIDPLAS_CART_${new Date().toISOString().split('T')[0]}`) || localStorage.getItem('ZUIDPLAS_LATEST_CART_DATA') || localStorage.getItem('cachedCartResult') || 'null');
                    const cacheDateSafe = cacheData?.date || window.__zuidplas_cart_cache?.date || window._zuidplas_cart_cache?.date || 'N/A';
                    const currentDateSafe = window.appState?.currentDate || window.__zuidplas_orders_date || new Date().toISOString().split('T')[0];
                    console.log(`‚úÖ Cache date: ${cacheDateSafe}, Current date: ${currentDateSafe}`);
                } else {
                    console.error('‚ùå getGlobalOrdersAndCarts() not available!');
                    showError('Cart calculation system not available. Please refresh the page.');
                    return;
                }
                
                console.log('');
                console.log('‚úÖ CART LOADING PAGE using Dashboard cache:');
                console.log(`   Matched orders: ${cartResult.matchedOrdersCount} (NOT ${orders.length} orderrows!)`);
                console.log(`   Total carts: ${cartResult.total}`);
                console.log(`   Standard: ${cartResult.standard || 0}, Danish: ${cartResult.danish || 0}`);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                
                // CRITICAL: Use matched orders from cartResult (same as Dashboard)
                const matchedOrders = cartResult.matchedOrders || orders;
                
                if (!matchedOrders || matchedOrders.length === 0) {
                    // We have a valid cached cartResult, but the orders array is missing (usually old storage format).
                    // Don't block UI; keep summary numbers and ask user to re-sync once so orders include order_id.
                    console.warn('‚ö†Ô∏è Cached cart result found, but orders array is empty.');
                    console.warn('   Please go to Dashboard and click "Sync/Refresh Data" once, then reload this page.');
                    // Keep page usable (no auto-optimize) but do not hard-block.
                    clearCartOptimizationDisplay();
                    // Update summary stats from cartResult (already cached)
                    const cartsEl = document.getElementById('total-carts');
                    if (cartsEl) cartsEl.textContent = String(cartResult.total || 0);
                    const assignedEl = document.getElementById('carts-assigned');
                    if (assignedEl) assignedEl.textContent = String(cartResult.total || 0);
                    return;
                }
                
                // Orders are available - load them into orderManager
                console.log(`üì¶ Found ${matchedOrders.length} matched orders in cache, loading...`);
                orderManager.orders = matchedOrders;
                orderManager.filteredOrders = [...matchedOrders];
                
                // CRITICAL: Update UI with CACHED cart count immediately!
                console.log(`‚úÖ Updating UI with cached cart count: ${cartResult.total} carts`);
                const totalCartsEl = document.getElementById('total-carts');
                if (totalCartsEl) {
                    totalCartsEl.textContent = cartResult.total;
                }
                
                // UPDATE UI - CRITICAL: Use matchedOrdersCount!
                const totalOrdersEl = document.getElementById('cart-total-orders');
                if (totalOrdersEl) {
                    totalOrdersEl.textContent = cartResult.matchedOrdersCount;
                }
                const cartsAssignedEl = document.getElementById('carts-assigned');
                if (cartsAssignedEl) {
                    cartsAssignedEl.textContent = cartResult.total;
                }
                const standardEl = document.getElementById('cart-standard');
                if (standardEl) {
                    standardEl.textContent = cartResult.standard || 0;
                }
                const danishEl = document.getElementById('cart-danish');
                if (danishEl) {
                    danishEl.textContent = cartResult.danish || 0;
                }
                
                // CRITICAL: Update cart counts using CartDisplayManager
                // CartDisplayManager will use getGlobalOrdersAndCarts internally
                if (window.CartDisplayManager) {
                    const cartManager = new CartDisplayManager();
                    cartManager.updateDOM();
                    console.log('‚úÖ Cart counts updated using CartDisplayManager');
                } else {
                    console.warn('‚ö†Ô∏è CartDisplayManager not available');
                }
                
                // Ensure truck assignments are loaded before optimizing
                loadTruckAssignments();
                
                // Auto-optimize
                console.log('üîß Auto-optimizing cart loading...');
                optimizeCartLoading();
            }
            
            checkOrdersAndDisplay();
            
            // Listen for orders updates from other pages
            window.addEventListener('ordersUpdated', (event) => {
                console.log(`üì¢ Orders updated (${event.detail.count} orders), reloading...`);
                const orders = event.detail.orders || window.appState.getOrders();
                
                orderManager.orders = orders;
                orderManager.filteredOrders = [...orders];
                
                // CRITICAL: Update cart counts using CartDisplayManager
                if (window.CartDisplayManager) {
                    const cartManager = new CartDisplayManager(orders);
                    cartManager.updateDOM();
                    console.log('‚úÖ Cart counts updated using CartDisplayManager');
                }
                
                optimizeCartLoading();
            });
        });
        
        // Toggle sidebar collapse (desktop)
        function toggleSidebarCollapse() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('collapsed');
            localStorage.setItem('sidebarCollapsed', sidebar.classList.contains('collapsed'));
        }
        
        // Toggle sidebar on mobile
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('open');
        }
        
        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function(event) {
            const sidebar = document.getElementById('sidebar');
            const menuBtn = document.querySelector('.mobile-menu-btn');
            
            if (window.innerWidth <= 768 && 
                sidebar.classList.contains('open') && 
                !sidebar.contains(event.target) && 
                !menuBtn.contains(event.target)) {
                sidebar.classList.remove('open');
            }
        });
        
        // Restore sidebar state on load
        document.addEventListener('DOMContentLoaded', () => {
            const sidebar = document.getElementById('sidebar');
            const isCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
            if (isCollapsed && window.innerWidth > 768) {
                sidebar.classList.add('collapsed');
            }
        });
        
        // Language switcher
        window.setLanguage = function(lang) {
            if (typeof i18n !== 'undefined') {
                i18n.setLanguage(lang);
                updateLanguageButtons();
            }
        };
        
        function updateLanguageButtons() {
            if (typeof i18n === 'undefined') return;
            const currentLang = i18n.getLanguage();
            document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(`lang-btn-${currentLang}`);
            if (activeBtn) activeBtn.classList.add('active');
        }
    
        // Logout function - clears session and redirects to login
        function handleLogout() {
            if (confirm(typeof i18n !== 'undefined' ? i18n.t('common.confirmLogout', 'Are you sure you want to logout?') : 'Are you sure you want to logout?')) {
                // Clear all session data
                localStorage.removeItem('zuidplas_logged_in');
                localStorage.removeItem('florinet_token');
                localStorage.removeItem('florinet_token_expiry');
                localStorage.removeItem('florinet_username');
                localStorage.removeItem('florinet_password');
                localStorage.removeItem('zuidplas_demo_mode');
                sessionStorage.clear();
                
                // Redirect to login
                window.location.href = 'login.html';
            }
        }
        
        // Make logout function global
        window.handleLogout = handleLogout;

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // DEBUG STATE CHECKER
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function debugCheckState() {
            const globalCount = window.appState?.getOrderCount() || 0;
            
            // Check BOTH old and new localStorage keys
            const oldData = localStorage.getItem('cachedOrders');
            const newData = localStorage.getItem('zuidplas_orders');
            const oldCount = oldData ? JSON.parse(oldData).length : 0;
            const newCount = newData ? JSON.parse(newData).length : 0;
            
            const managerCount = orderManager?.orders?.length || 0;
            const lastSync = localStorage.getItem('lastSyncDate') || 'Never';
            const currentDate = window.appState?.currentDate || '-';
            
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üêõ DEBUG STATE CHECK (CART OPTIMIZATION)');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log(`Global State (memory): ${globalCount} orders`);
            console.log(`OLD LocalStorage (cachedOrders): ${oldCount} orders`);
            console.log(`NEW LocalStorage (zuidplas_orders): ${newCount} orders`);
            console.log(`OrderManager: ${managerCount} orders`);
            console.log(`Last Sync: ${lastSync}`);
            console.log(`Current Date: ${currentDate}`);
            console.log('window.appState:', window.appState);
            console.log('orderManager.orders:', orderManager?.orders?.slice(0, 2));
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            alert(`üêõ CART OPT STATE\n\nMemory: ${globalCount} orders\nOLD storage: ${oldCount}\nNEW storage: ${newCount}\nManager: ${managerCount}\nLast sync: ${lastSync}\nDate: ${currentDate}`);
        }
        
        // Update debug panel every 2 seconds
        function updateDebugPanel() {
            const globalCount = window.appState?.getOrderCount() || 0;
            
            // Check BOTH old and new localStorage keys
            const oldData = localStorage.getItem('cachedOrders');
            const newData = localStorage.getItem('zuidplas_orders');
            const localCount = newData ? JSON.parse(newData).length : (oldData ? JSON.parse(oldData).length : 0);
            
            const managerCount = orderManager?.orders?.length || 0;
            const lastSync = localStorage.getItem('lastSyncDate') || 'Never';
            const currentDate = window.appState?.currentDate || '-';
            
            const globalEl = document.getElementById('debug-global-orders');
            const localEl = document.getElementById('debug-local-orders');
            const managerEl = document.getElementById('debug-manager-orders');
            const syncEl = document.getElementById('debug-last-sync');
            const dateEl = document.getElementById('debug-current-date');
            
            if (globalEl) globalEl.textContent = globalCount;
            if (localEl) localEl.textContent = localCount;
            if (managerEl) managerEl.textContent = managerCount;
            if (syncEl) syncEl.textContent = lastSync === 'Never' ? 'Never' : new Date(lastSync).toLocaleTimeString();
            if (dateEl) dateEl.textContent = currentDate;
        }
        
        // Make functions global
        window.debugCheckState = debugCheckState;
        window.updateDebugPanel = updateDebugPanel;
        
        // Listen for orders updated event and update debug panel immediately
        window.addEventListener('ordersUpdated', (event) => {
            console.log('üì¢ Debug panel: Orders updated event received:', event.detail.count);
            updateDebugPanel();
        });
        
        // Update debug panel periodically
        setInterval(updateDebugPanel, 2000);
        
        // Initial update
        setTimeout(updateDebugPanel, 1000);

    </script>
</body>