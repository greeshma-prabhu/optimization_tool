<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Optimization - Zuidplas Logistics</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/layout.css">
</head>
<body>
    <!-- Top Header -->
    <header class="top-header">
        <div class="header-left">
            <div class="header-logo">
                <div class="logo-blocks">
                    <div class="logo-block d">D</div>
                    <div class="logo-block flower">
                        <div class="logo-flower-icon"></div>
                    </div>
                    <div class="logo-block z">Z</div>
                </div>
                <div class="logo-text-large">
                    <div class="logo-main-text">DE ZUIDPLAS</div>
                </div>
            </div>
        </div>
        <div class="header-right">
            <div class="user-menu">
                <div class="user-avatar">A</div>
                <span style="font-size: 14px; color: #374151;">Admin User</span>
                <div class="user-badge">Admin</div>
            </div>
            <button class="logout-btn-header" onclick="handleLogout()" data-i18n="common.logout">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                    <polyline points="16 17 21 12 16 7"></polyline>
                    <line x1="21" y1="12" x2="9" y2="12"></line>
                </svg>
                <span>Uitloggen</span>
            </button>
        </div>
    </header>

    <!-- Top Navigation Bar -->
    <nav class="top-nav">
        <div class="nav-items">
            <a href="index.html" class="nav-item active">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="7" height="7"></rect>
                    <rect x="14" y="3" width="7" height="7"></rect>
                    <rect x="14" y="14" width="7" height="7"></rect>
                    <rect x="3" y="14" width="7" height="7"></rect>
                </svg>
                <span data-i18n="nav.dashboard">Dashboard</span>
            </a>
            
            <a href="orders.html" class="nav-item">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                </svg>
                <span data-i18n="nav.orders">Orders</span>
            </a>
            
            <a href="optimization.html" class="nav-item">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polyline>
                </svg>
                <span data-i18n="nav.optimization">Optimization</span>
            </a>
            
            <a href="cart-loading.html" class="nav-item">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="2" y="7" width="20" height="14" rx="2"></rect>
                    <path d="M16 7V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v2"></path>
                    <line x1="12" y1="12" x2="12" y2="16"></line>
                    <line x1="8" y1="12" x2="8" y2="16"></line>
                    <line x1="16" y1="12" x2="16" y2="16"></line>
                </svg>
                <span data-i18n="nav.cartOptimization">Cart Optimization</span>
            </a>
            
            <a href="trucks.html" class="nav-item">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="1" y="3" width="15" height="13"></rect>
                    <polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon>
                    <circle cx="5.5" cy="18.5" r="2.5"></circle>
                    <circle cx="18.5" cy="18.5" r="2.5"></circle>
                </svg>
                <span data-i18n="nav.trucks">Trucks</span>
            </a>
            
            <a href="costs.html" class="nav-item">
                <svg class="nav-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="12" y1="1" x2="12" y2="23"></line>
                    <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>
                </svg>
                <span data-i18n="nav.costs">Costs</span>
            </a>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Page Header -->
        <div class="page-header">
            <div class="page-header-top">
                <div>
                    <h1 class="page-title" data-i18n="dashboard.title">Dashboard</h1>
                    <p class="page-subtitle" data-i18n="dashboard.subtitle">Route optimization overview for today</p>
                </div>
                <div class="dashboard-controls">
                    <div class="date-picker-wrapper">
                        <label class="date-picker-label" data-i18n="dashboard.selectDate">Select Date</label>
                        <div class="date-input-group">
                            <input type="date" id="order-date-picker" class="date-input" value="">
                            <button type="button" class="btn-icon" onclick="document.getElementById('order-date-picker').focus(); document.getElementById('order-date-picker').showPicker ? document.getElementById('order-date-picker').showPicker() : null;" title="Open calendar">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                    <line x1="16" y1="2" x2="16" y2="6"></line>
                                    <line x1="8" y1="2" x2="8" y2="6"></line>
                                    <line x1="3" y1="10" x2="21" y2="10"></line>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="action-buttons">
                        <button type="button" class="btn-sync" id="sync-btn" title="Sync data for selected date" onclick="syncDataForDate()">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.3"></path>
                            </svg>
                            <span data-i18n="dashboard.syncOrders">Sync</span>
                        </button>
                        <button type="button" class="btn-refresh" id="refresh-btn" title="Refresh today's orders (yesterday until 7 AM)" onclick="refreshTodaysOrders()">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" id="refresh-icon">
                                <polyline points="23 4 23 10 17 10"></polyline>
                                <polyline points="1 20 1 14 7 14"></polyline>
                                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                            </svg>
                            <span data-i18n="dashboard.refresh">Refresh Data</span>
                        </button>
                        <button type="button" class="btn-demo" id="demo-btn" title="Load demo data" onclick="loadDemoData()">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <line x1="9" y1="3" x2="9" y2="21"></line>
                                <line x1="15" y1="3" x2="15" y2="21"></line>
                                <line x1="3" y1="9" x2="21" y2="9"></line>
                                <line x1="3" y1="15" x2="21" y2="15"></line>
                            </svg>
                            <span data-i18n="dashboard.loadDemo">Demo</span>
                        </button>
                    </div>
                    <div class="header-status-info">
                        <!-- Removed "Last updated" - only showing "Last refreshed" below -->
                    </div>
                    <div class="current-date-time" id="currentDateTime"></div>
                </div>
            </div>
            <div id="api-status-message" class="api-status-message"></div>
        </div>

        <!-- Stats Cards -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-header">
                    <div>
                        <div class="stat-value" id="total-orders-count">0</div>
                        <div class="stat-label" data-i18n="dashboard.todayOrders">Today's Orders</div>
                    </div>
                    <div class="stat-icon-wrapper">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                        </svg>
                    </div>
                </div>
            </div>
            <div class="stat-card">
                <div class="stat-header">
                    <div>
                        <div class="stat-value" id="total-carts-needed">0</div>
                        <div class="stat-label" data-i18n="dashboard.totalCarts">Total Carts Needed</div>
                    </div>
                    <div class="stat-icon-wrapper">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="9" cy="21" r="1"></circle>
                            <circle cx="20" cy="21" r="1"></circle>
                            <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>
                        </svg>
                    </div>
                </div>
            </div>
            <div class="stat-card">
                <div class="stat-header">
                    <div>
                        <div class="stat-value" id="routes-status">0/3</div>
                        <div class="stat-label" data-i18n="dashboard.routesStatus">Active Routes</div>
                    </div>
                    <div class="stat-icon-wrapper">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="1" y="3" width="15" height="13"></rect>
                            <polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon>
                            <circle cx="5.5" cy="18.5" r="2.5"></circle>
                            <circle cx="18.5" cy="18.5" r="2.5"></circle>
                        </svg>
                    </div>
                </div>
            </div>
            <div class="stat-card">
                <div class="stat-header">
                    <div>
                        <div class="stat-value" id="optimization-score">0%</div>
                        <div class="stat-label" data-i18n="dashboard.optimizationScore">Optimization Score</div>
                    </div>
                    <div class="stat-icon-wrapper">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polyline>
                        </svg>
                    </div>
                </div>
            </div>
        </div>

        <!-- Route Summary by Departure Time -->
        <div class="card route-summary">
            <h2>üìç Route Breakdown by Departure Time</h2>
            <div class="route-cards-grid">
                <!-- Route 1: Rijnsburg -->
                <div class="route-summary-card rijnsburg">
                    <div class="route-header">
                        <h3>üöõ Route 1: Rijnsburg</h3>
                        <span class="departure-time">üïê 09:00</span>
                    </div>
                    <div class="route-stats">
                        <div class="stat">
                            <label>Orders</label>
                            <span id="rijnsburg-orders">0</span>
                        </div>
                        <div class="stat">
                            <label>Customers</label>
                            <span id="rijnsburg-customers">0</span>
                        </div>
                        <div class="stat">
                            <label>Carts</label>
                            <span id="rijnsburg-carts">0</span>
                        </div>
                        <div class="stat">
                            <label>Trucks</label>
                            <span id="rijnsburg-trucks">0</span>
                        </div>
                    </div>
                    <button class="btn-view-details" onclick="viewRouteDetails('rijnsburg')">
                        View Customer List
                    </button>
                </div>
                
                <!-- Route 2: Aalsmeer -->
                <div class="route-summary-card aalsmeer">
                    <div class="route-header">
                        <h3>üöõ Route 2: Aalsmeer</h3>
                        <span class="departure-time">üïê 10:00</span>
                    </div>
                    <div class="route-stats">
                        <div class="stat">
                            <label>Orders</label>
                            <span id="aalsmeer-orders">0</span>
                        </div>
                        <div class="stat">
                            <label>Customers</label>
                            <span id="aalsmeer-customers">0</span>
                        </div>
                        <div class="stat">
                            <label>Carts</label>
                            <span id="aalsmeer-carts">0</span>
                        </div>
                        <div class="stat">
                            <label>Trucks</label>
                            <span id="aalsmeer-trucks">0</span>
                        </div>
                    </div>
                    <div class="danish-indicator">
                        üá©üá∞ Includes Danish Cart Clients
                    </div>
                    <button class="btn-view-details" onclick="viewRouteDetails('aalsmeer')">
                        View Customer List
                    </button>
                </div>
                
                <!-- Route 3: Naaldwijk -->
                <div class="route-summary-card naaldwijk">
                    <div class="route-header">
                        <h3>üöõ Route 3: Naaldwijk</h3>
                        <span class="departure-time">üïê 11:00</span>
                    </div>
                    <div class="route-stats">
                        <div class="stat">
                            <label>Orders</label>
                            <span id="naaldwijk-orders">0</span>
                        </div>
                        <div class="stat">
                            <label>Customers</label>
                            <span id="naaldwijk-customers">0</span>
                        </div>
                        <div class="stat">
                            <label>Carts</label>
                            <span id="naaldwijk-carts">0</span>
                        </div>
                        <div class="stat">
                            <label>Trucks</label>
                            <span id="naaldwijk-trucks">0</span>
                        </div>
                    </div>
                    <button class="btn-view-details" onclick="viewRouteDetails('naaldwijk')">
                        View Customer List
                    </button>
                </div>
            </div>
            <div style="margin-top: 1.5rem; text-align: center;">
                <button id="check-mismatches-btn" class="btn btn-secondary" style="padding: 10px 20px; margin-top: 1rem;">
                    üîç Check Mismatched Orders
                </button>
            </div>
        </div>

        <!-- Route Overview Cards -->
        <div class="card">
            <h2 data-i18n="dashboard.routeOverview">Route Overview</h2>
            <div class="route-grid" id="route-overview">
                <!-- Populated by JavaScript -->
            </div>
        </div>

        <!-- Optimization Suggestions -->
        <div class="card">
            <h2 data-i18n="dashboard.optimizationSuggestions">Optimization Suggestions</h2>
            <div id="optimization-suggestions">
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);" data-i18n="dashboard.clickToSync">
                    Click "Sync Orders from API" to fetch real orders, or "Load Demo Data" to test with sample orders
                </div>
            </div>
        </div>

        <!-- DUMP BASKET - Unmatched Orders Section -->
        <div id="unmatched-section" style="display: none; margin-top: 20px;"></div>

        <!-- Error Message -->
        <div id="error-message" class="info-box danger" style="display: none; margin-top: 20px;"></div>
        
        <!-- Info Message -->
        <div id="info-message" class="info-box info" style="display: none; margin-top: 20px;"></div>
    </main>

    <!-- LANGUAGE SCRIPTS - MUST BE FIRST -->
    <script src="js/i18n.js"></script>
    <script src="js/i18n-init.js"></script>
    
    <!-- GLOBAL STATE MANAGER - BEFORE PAGE SCRIPTS -->
    <script src="js/app-state.js"></script>
    
    <!-- PAGE-SPECIFIC SCRIPTS -->
    <script src="js/data.js"></script>
    <script src="js/auth.js"></script>
    <script src="js/api.js"></script>
    <script src="js/route-mapping.js"></script> <!-- CLIENT-TO-ROUTE MAPPING -->
    <script src="js/cart-calculation.js"></script> <!-- NEW CORRECT CALCULATION -->
    <script src="js/order-validator.js"></script> <!-- ORDER VALIDATION -->
    <script src="js/carts.js"></script>
    <script src="js/ordermanager-shim.js"></script>
    <script src="js/orders.js"></script>
    <script src="js/optimizer.js"></script>
    <script src="js/navigation.js"></script>
    <script>
        // Update last refreshed time
        function updateLastRefreshed() {
            const lastRefresh = localStorage.getItem('zuidplas_last_refresh');
            const dateTimeEl = document.getElementById('currentDateTime');
            if (!dateTimeEl) return;
            
            const lang = localStorage.getItem('zuidplas_user_language') || localStorage.getItem('zuidplas_language') || 'nl';
            const locale = lang === 'nl' ? 'nl-NL' : 'en-US';
            
            if (lastRefresh) {
                const refreshDate = new Date(parseInt(lastRefresh));
                const timeStr = refreshDate.toLocaleTimeString(locale, { hour: '2-digit', minute: '2-digit' });
                const dateStr = refreshDate.toLocaleDateString(locale, { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric'
                });
                
                if (lang === 'nl') {
                    dateTimeEl.textContent = `Laatst vernieuwd: ${dateStr} om ${timeStr}`;
                } else {
                    dateTimeEl.textContent = `Last refreshed: ${dateStr} at ${timeStr}`;
                }
            } else {
                if (lang === 'nl') {
                    dateTimeEl.textContent = 'Nog niet vernieuwd';
                } else {
                    dateTimeEl.textContent = 'Not refreshed yet';
                }
            }
        }

        // Update last updated time display
        function updateLastUpdatedTime() {
            const now = new Date();
            const lang = localStorage.getItem('zuidplas_user_language') || localStorage.getItem('zuidplas_language') || 'nl';
            const locale = lang === 'nl' ? 'nl-NL' : 'en-US';
            const timeStr = now.toLocaleTimeString(locale, { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            const element = document.getElementById('lastUpdatedTime');
            if (element) {
                element.textContent = timeStr;
            }
        }
        
        // Update on load
        updateLastRefreshed();
        updateLastUpdatedTime();
        
        // Set default date to today and set up button listeners
        document.addEventListener('DOMContentLoaded', () => {
            const datePicker = document.getElementById('order-date-picker');
            if (datePicker && !datePicker.value) {
                const today = new Date();
                datePicker.value = today.toISOString().split('T')[0];
            }
            
            // Set up button event listeners (CRITICAL - must prevent calendar opening)
            const syncBtn = document.getElementById('sync-btn');
            const demoBtn = document.getElementById('demo-btn');
            
            if (syncBtn) {
                // Ensure button type is set
                syncBtn.setAttribute('type', 'button');
                
                // Remove any existing listeners by cloning
                const newSyncBtn = syncBtn.cloneNode(true);
                syncBtn.parentNode.replaceChild(newSyncBtn, syncBtn);
                
                // Get reference to the new button
                const finalSyncBtn = document.getElementById('sync-btn');
                
                finalSyncBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    console.log('Sync button clicked - calling syncOrders');
                    
                    if (typeof window.syncOrders === 'function') {
                        window.syncOrders(false);
                    } else if (typeof syncOrders === 'function') {
                        syncOrders(false);
                    } else {
                        console.error('syncOrders function not found!');
                    }
                    return false;
                }, false); // Use bubble phase, not capture
            }
            
            if (demoBtn) {
                // Ensure button type is set
                demoBtn.setAttribute('type', 'button');
                
                // Remove any existing listeners by cloning
                const newDemoBtn = demoBtn.cloneNode(true);
                demoBtn.parentNode.replaceChild(newDemoBtn, demoBtn);
                
                // Get reference to the new button
                const finalDemoBtn = document.getElementById('demo-btn');
                
                finalDemoBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    console.log('Demo button clicked - calling loadDemoData');
                    
                    if (typeof window.loadDemoData === 'function') {
                        window.loadDemoData();
                    } else if (typeof loadDemoData === 'function') {
                        loadDemoData();
                    } else {
                        console.error('loadDemoData function not found!');
                    }
                    return false;
                }, false); // Use bubble phase, not capture
            }
            
            // Prevent date picker from interfering with buttons
            if (datePicker) {
                datePicker.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
            }
        });

        // Use dummy data flag
        let useDummyData = false;
        window.isRefreshing = false;
        
        // OrderManager is provided by ordermanager-shim.js - DO NOT DECLARE IT HERE!

        // CRITICAL: Filter orders by delivery_date (same as Orders page)
        function filterOrdersByDeliveryDate(orderrows, targetDate) {
            // Format target date as DD-MM-YYYY
            const formatDateToDD_MM_YYYY = (dateStr) => {
                if (!dateStr) return null;
                const d = new Date(dateStr);
                if (isNaN(d.getTime())) return null;
                const day = String(d.getDate()).padStart(2, '0');
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const year = d.getFullYear();
                return `${day}-${month}-${year}`;
            };
            
            const targetDateStr = formatDateToDD_MM_YYYY(targetDate);
            
            if (!targetDateStr) {
                console.warn('‚ö†Ô∏è Invalid target date, returning all orders');
                return orderrows;
            }
            
            const filtered = orderrows.filter(row => {
                const deliveryDate = row.order?.delivery_date || row.delivery_date;
                
                if (!deliveryDate) {
                    // Skip orders without delivery_date
                    return false;
                }
                
                // Extract date from "2026-02-03T14:00:00.000000Z" or "03-02-2026"
                let orderDateStr = null;
                if (deliveryDate.includes('T')) {
                    // ISO format: "2026-02-03T14:00:00.000000Z"
                    orderDateStr = formatDateToDD_MM_YYYY(deliveryDate.split('T')[0]);
                } else {
                    // Already in DD-MM-YYYY format
                    orderDateStr = deliveryDate;
                }
                
                return orderDateStr === targetDateStr;
            });
            
            return filtered;
        }
        
        // Sync data for selected date - uses date picker
        // Make it available globally immediately
        window.syncDataForDate = async function() {
            if (window.isRefreshing) {
                console.log('Sync already in progress...');
                return;
            }
            
            console.log('üîÑ Sync data for selected date');
            
            window.isRefreshing = true;
            const btn = document.getElementById('sync-btn');
            if (btn) {
                btn.classList.add('refreshing');
                btn.disabled = true;
            }
            
            try {
                await window.syncOrders(false);
            } catch (error) {
                console.error('Sync failed:', error);
            } finally {
                window.isRefreshing = false;
                if (btn) {
                    btn.classList.remove('refreshing');
                    btn.disabled = false;
                }
            }
        };

        // Refresh today's orders (yesterday until 7 AM today) - planning window
        window.refreshTodaysOrders = async function() {
            if (window.isRefreshing) {
                console.log('Refresh already in progress...');
                return;
            }
            
            console.log('üîÑ Refresh today\'s orders (planning window)');
            
            window.isRefreshing = true;
            const btn = document.getElementById('refresh-btn');
            const statusMsg = document.getElementById('api-status-message');
            
            if (btn) {
                btn.classList.add('refreshing');
                btn.disabled = true;
            }
            
            try {
                if (statusMsg) {
                    statusMsg.innerHTML = '';
                    statusMsg.classList.remove('show', 'success', 'error');
                }
                
                // Store refresh timestamp
                localStorage.setItem('zuidplas_last_refresh', Date.now().toString());
                updateLastRefreshed();
                updateLastUpdatedTime();
                
                // Get selected date from date picker (same as sync)
                const datePicker = document.getElementById('order-date-picker');
                let selectedDate = null;
                if (datePicker && datePicker.value) {
                    selectedDate = new Date(datePicker.value);
                    console.log('üìÖ Refresh: Using selected date from picker:', selectedDate.toISOString().split('T')[0]);
                } else {
                    // Default to today
                    selectedDate = new Date();
                    if (datePicker) {
                        datePicker.value = selectedDate.toISOString().split('T')[0];
                    }
                    console.log('üìÖ Refresh: Using today as default:', selectedDate.toISOString().split('T')[0]);
                }
                
                // Fetch orders for the selected date (same as sync)
                console.log('üìÖ Fetching orders for selected date:', selectedDate.toISOString().split('T')[0]);
                const apiOrders = await florinetAPI.fetchOrdersForDate(selectedDate);
                
                if (apiOrders && apiOrders.length > 0) {
                    console.log('‚úÖ Loaded', apiOrders.length, 'raw orders from API');
                    
                    // CRITICAL: Filter by delivery_date FIRST (same as Orders page)
                    const selectedDateStr = selectedDate.toISOString().split('T')[0];
                    const filteredByDate = filterOrdersByDeliveryDate(apiOrders, selectedDateStr);
                    console.log(`üìÖ Dashboard: Filtered by delivery date: ${apiOrders.length} ‚Üí ${filteredByDate.length} orders`);
                    
                    // VALIDATE ORDERS - filter out invalid/test/cancelled/duplicates
                    let orders = filteredByDate;
                    if (window.OrderValidator && typeof window.OrderValidator.validateOrders === 'function') {
                        const validationResult = window.OrderValidator.validateOrders(filteredByDate);
                        orders = validationResult.orders;
                        console.log('‚úÖ Processing', orders.length, 'valid orders after validation');
                    } else {
                        console.log('‚ö†Ô∏è Order validator not available, using all orders');
                    }
                    
                    // Initialize optimizer
                    const optimizer = initializeOptimizer(orders);
                    const options = optimizer.generateOptions();
                    
                    // Update dashboard
                    updateDashboard(orders, options);
                    
                    // Get existing orders count for comparison
                    const existingCount = window.appState.getOrderCount();
                    const hasChanges = orders.length !== existingCount;
                    
                    if (hasChanges) {
                        console.log(`üîÑ Changes detected: ${existingCount} ‚Üí ${orders.length} orders`);
                    } else {
                        console.log('‚ÑπÔ∏è No changes detected - same number of orders');
                    }
                    
                    // STORE IN GLOBAL STATE (handles localStorage automatically)
                    console.log(`üîÑ Saving ${ordersWithCarts.length} orders to global state...`);
                    window.appState.setOrders(ordersWithCarts, selectedDate);
                    
                    // Update debug panel
                    setTimeout(() => {
                        updateDebugPanel();
                    }, 100);
                    
                    // Clear previous truck assignments
                    localStorage.removeItem('zuidplas_route_truck_assignments');
                    
                    // Update last updated time
                    updateLastUpdatedTime();
                    
                    // Show success message with change info
                    if (statusMsg) {
                        // Get matched/unmatched counts from cart result if available
                        const cartResult = window.__zuidplas_cart_cache?.cartResult;
                        const matchedCount = cartResult?.matchedOrdersCount || ordersWithCarts.length;
                        const unmatchedCount = cartResult?.unmatchedOrdersCount || 0;
                        
                        if (hasChanges) {
                            if (unmatchedCount > 0) {
                                statusMsg.innerHTML = `‚úÖ Updated: Found ${ordersWithCarts.length} orders from API (${matchedCount} matched, ${unmatchedCount} unmatched) - was ${existingCount}`;
                            } else {
                                statusMsg.innerHTML = `‚úÖ Updated: Found ${matchedCount} matched orders (was ${existingCount})`;
                            }
                        } else {
                            if (unmatchedCount > 0) {
                                statusMsg.innerHTML = `‚úÖ Refreshed: ${ordersWithCarts.length} orders from API (${matchedCount} matched, ${unmatchedCount} unmatched) - no changes`;
                            } else {
                                statusMsg.innerHTML = `‚úÖ Refreshed: ${matchedCount} matched orders (no changes)`;
                            }
                        }
                        statusMsg.classList.add('show', 'success');
                    }
                    
                    console.log('‚úÖ Today\'s orders refreshed:', ordersWithCarts.length, hasChanges ? '(updated)' : '(no changes)');
                } else {
                    console.log('‚ÑπÔ∏è No orders for today\'s planning window');
                    if (statusMsg) {
                        statusMsg.innerHTML = '‚ÑπÔ∏è No orders found for today\'s planning window (yesterday until 7 AM today)';
                        statusMsg.classList.add('show');
                    }
                }
            } catch (error) {
                console.error('Refresh today\'s orders failed:', error);
                if (statusMsg) {
                    statusMsg.innerHTML = `
                        <div style="padding: 16px; background: #fee2e2; border-left: 4px solid #ef4444; border-radius: 8px;">
                            <strong style="color: #991b1b;">‚ùå Failed to refresh today's orders</strong><br>
                            <small style="color: #7f1d1d;">${error.message}</small>
                        </div>
                    `;
                    statusMsg.classList.add('show', 'error');
                }
            } finally {
                window.isRefreshing = false;
                if (btn) {
                    btn.classList.remove('refreshing');
                    btn.disabled = false;
                }
            }
        };

        // Sync orders from API or use dummy data - make it global
        window.syncOrders = async function(useDummy = false) {
            const syncBtn = document.getElementById('sync-btn');
            const originalText = syncBtn ? syncBtn.innerHTML : '';
            const statusMsg = document.getElementById('api-status-message');
            useDummyData = useDummy;
            
            try {
                if (syncBtn) {
                    syncBtn.disabled = true;
                    const btnText = typeof i18n !== 'undefined' 
                        ? (useDummy ? i18n.t('dashboard.loadingDemo', 'Loading Demo Data...') : i18n.t('dashboard.syncing', 'Syncing...'))
                        : (useDummy ? 'üì¶ Loading Demo Data...' : '‚è≥ Syncing...');
                    syncBtn.innerHTML = btnText;
                }
                if (statusMsg) {
                    statusMsg.innerHTML = '';
                    statusMsg.classList.remove('show', 'success', 'error');
                }
                
                // Store refresh timestamp
                localStorage.setItem('zuidplas_last_refresh', Date.now().toString());
                updateLastRefreshed();
                updateLastUpdatedTime();
                
                // Get selected date from date picker
                const datePicker = document.getElementById('order-date-picker');
                let selectedDate = null;
                if (datePicker && datePicker.value) {
                    selectedDate = new Date(datePicker.value);
                    console.log('üìÖ Using selected date:', selectedDate.toISOString().split('T')[0]);
                } else {
                    // Set default to today
                    selectedDate = new Date();
                    if (datePicker) {
                        datePicker.value = selectedDate.toISOString().split('T')[0];
                    }
                    console.log('üìÖ Using today as default:', selectedDate.toISOString().split('T')[0]);
                }
                
                let orders = [];
                
                if (useDummy) {
                    // Use dummy data - initialize OrderManager ONLY for demo
                    try {
                        if (!orderManager && typeof OrderManager !== 'undefined') {
                            orderManager = new OrderManager();
                            console.log('‚úÖ OrderManager initialized for demo data');
                        }
                        
                        if (orderManager) {
                            orders = await orderManager.fetchOrders(selectedDate, true);
                            console.log('‚úÖ Loaded demo data:', orders.length, 'orders');
                        } else {
                            throw new Error('OrderManager not available');
                        }
                    } catch (demoError) {
                        console.error('‚ùå Demo data failed:', demoError);
                        // Show error message
                        if (statusMsg) {
                            statusMsg.innerHTML = `<div style="color: #ef4444; padding: 16px;">Demo data failed to load. OrderManager not available.</div>`;
                            statusMsg.classList.add('show', 'error');
                        }
                        orders = [];
                    }
                } else {
                    // Fetch orders from API for the selected date
                    try {
                        console.log('üìÖ Fetching orders for date:', selectedDate.toISOString().split('T')[0]);
                        const apiOrders = await florinetAPI.fetchOrdersForDate(selectedDate);
                        if (apiOrders && apiOrders.length > 0) {
                            console.log('‚úÖ Loaded', apiOrders.length, 'raw orders from API');
                            
                            // CRITICAL: Filter by delivery_date FIRST (same as Orders page)
                            const selectedDateStr = selectedDate.toISOString().split('T')[0];
                            const filteredByDate = filterOrdersByDeliveryDate(apiOrders, selectedDateStr);
                            console.log(`üìÖ Dashboard: Filtered by delivery date: ${apiOrders.length} ‚Üí ${filteredByDate.length} orders`);
                            
                            // VALIDATE ORDERS - filter out invalid/test/cancelled/duplicates
                            if (window.OrderValidator && typeof window.OrderValidator.validateOrders === 'function') {
                                const validationResult = window.OrderValidator.validateOrders(filteredByDate);
                                orders = validationResult.orders;
                                
                                // Get statistics
                                const stats = window.OrderValidator.getOrderStats(orders);
                                console.log('');
                                console.log('üìä ORDER STATISTICS:');
                                console.log('  Aalsmeer:', stats.byRoute.Aalsmeer, 'orders');
                                console.log('  Naaldwijk:', stats.byRoute.Naaldwijk, 'orders');
                                console.log('  Rijnsburg:', stats.byRoute.Rijnsburg, 'orders');
                                console.log('  Total customers:', Object.keys(stats.byCustomer).length);
                                if (stats.topCustomers.length > 0) {
                                    console.log('  Top customer:', stats.topCustomers[0].name, `(${stats.topCustomers[0].count} orders)`);
                                }
                                console.log('');
                            } else {
                                // Fallback if validator not loaded - use filtered orders
                                orders = filteredByDate;
                                console.log('‚ö†Ô∏è Order validator not available, using filtered orders');
                            }
                            
                            console.log('‚úÖ Processing', orders.length, 'valid orders');
                            
                            // ‚úÖ CRITICAL: SAVE TO GLOBAL STATE FIRST (before calculating carts!)
                            console.log(`üîÑ Saving ${orders.length} orders to global state FIRST...`);
                            window.appState.setOrders(orders, selectedDate);
                            
                            // CRITICAL: Wait a tiny bit to ensure cache is cleared
                            await new Promise(resolve => setTimeout(resolve, 100));
                            
                            // Initialize optimizer with orders that have carts assigned
                            console.log('üîß Initializing optimizer with', orders.length, 'orders...');
                            const optimizer = initializeOptimizer(orders);
                            const options = optimizer.generateOptions();
                            
                            // Update dashboard (now uses getGlobalOrdersAndCarts which will use the orders we just saved)
                            updateDashboard(orders, options);
                    
                    // Update debug panel
                    setTimeout(() => {
                        updateDebugPanel();
                    }, 100);
                    
                    // Clear previous truck assignments
                    localStorage.removeItem('zuidplas_route_truck_assignments');
                    console.log('üîÑ Cleared previous truck assignments - user must select fresh');
                        } else {
                            // No orders from API - this is OK, empty array is valid
                            console.log('‚ÑπÔ∏è No orders from API (empty array is normal)');
                            orders = [];
                        }
                    } catch (apiError) {
                        console.error('=================================');
                        console.error('‚ùå API FETCH FAILED - NO FALLBACK');
                        console.error('Error:', apiError);
                        console.error('=================================');
                        
                        // Show error to user - NO FALLBACK
                        if (statusMsg) {
                            statusMsg.innerHTML = `
                                <div style="padding: 16px; background: #fee2e2; border-left: 4px solid #ef4444; border-radius: 8px;">
                                    <strong style="color: #991b1b;">‚ùå API Connection Failed</strong><br>
                                    <small style="color: #7f1d1d;">${apiError.message}</small><br><br>
                                    <button onclick="manualRefresh()" style="padding: 8px 16px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 8px;">
                                        Retry Connection
                                    </button>
                                </div>
                            `;
                            statusMsg.classList.add('show', 'error');
                        }
                        
                        // Throw error - no fallback
                        throw apiError;
                    }
                }
                
                // Store flag for demo data
                if (useDummy) {
                    localStorage.setItem('zuidplas_using_demo_data', 'true');
                } else {
                    localStorage.setItem('zuidplas_using_demo_data', 'false');
                }
                
                // ‚úÖ CRITICAL: SAVE TO GLOBAL STATE FIRST (before calculating carts!)
                // This ensures getGlobalOrdersAndCarts() uses the SAME orders
                console.log(`üîÑ Saving ${orders.length} orders to global state FIRST...`);
                window.appState.setOrders(orders, selectedDate);
                
                // Initialize optimizer with orders
                console.log('üîß Initializing optimizer with', orders.length, 'orders...');
                const optimizer = initializeOptimizer(orders);
                
                // Generate options
                const options = optimizer.generateOptions();
                
                // Update dashboard (now uses getGlobalOrdersAndCarts which will use the orders we just saved)
                updateDashboard(orders, options);
                
                // Update debug panel
                setTimeout(() => {
                    updateDebugPanel();
                }, 100);
                
                syncBtn.innerHTML = useDummy ? '‚úÖ Demo Data Loaded' : '‚úÖ Synced';
                
                // Show status message
                if (statusMsg) {
                    if (useDummy) {
                        statusMsg.innerHTML = '‚úÖ Using demo data (20 sample orders)';
                        statusMsg.classList.add('show', 'success');
                    } else if (orders.length === 0) {
                        const dateStr = selectedDate ? selectedDate.toLocaleDateString() : 'today';
                        statusMsg.innerHTML = `‚ÑπÔ∏è No orders found for ${dateStr}. Try a different date or use demo data.`;
                        statusMsg.classList.add('show');
                    } else {
                        // Check if actually from API or demo data
                        const isDemoData = localStorage.getItem('zuidplas_using_demo_data') === 'true';
                        
                        // Get matched/unmatched counts from cart result if available
                        const cartResult = window.__zuidplas_cart_cache?.cartResult;
                        const matchedCount = cartResult?.matchedOrdersCount || orders.length;
                        const unmatchedCount = cartResult?.unmatchedOrdersCount || 0;
                        
                        if (isDemoData) {
                            statusMsg.innerHTML = `‚úÖ Using demo data (${orders.length} sample orders)`;
                        } else {
                            if (unmatchedCount > 0) {
                                statusMsg.innerHTML = `‚úÖ Found ${orders.length} orders from API (${matchedCount} matched, ${unmatchedCount} unmatched)`;
                            } else {
                                statusMsg.innerHTML = `‚úÖ Found ${matchedCount} matched orders from API`;
                            }
                        }
                        statusMsg.classList.add('show', 'success');
                    }
                }
                
                // Update last refreshed time
                updateLastRefreshed();
                updateLastUpdatedTime();
                
                if (syncBtn) {
                    setTimeout(() => {
                        syncBtn.innerHTML = originalText;
                        syncBtn.disabled = false;
                    }, 2000);
                }
                
            } catch (error) {
                syncBtn.innerHTML = '‚ùå Error';
                if (statusMsg) {
                    statusMsg.innerHTML = `‚ùå Error: ${error.message}. Try using demo data or check proxy server.`;
                    statusMsg.classList.add('show', 'error');
                }
                setTimeout(() => {
                    syncBtn.innerHTML = originalText;
                    syncBtn.disabled = false;
                }, 2000);
                console.error('Sync error:', error);
            }
        }

        // Load demo data button - make it global
        window.loadDemoData = function() {
            console.log('loadDemoData called');
            if (typeof window.syncOrders === 'function') {
                window.syncOrders(true);
            } else {
                console.error('window.syncOrders not available');
            }
        };

        // Update dashboard display
        function updateDashboard(orders, options) {
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üìä UPDATE DASHBOARD CALLED');
            console.log(`   Orders parameter: ${orders ? orders.length : 0}`);
            
            // CRITICAL: Dashboard loads data FIRST, so it should CALCULATE FRESH!
            // Other pages will then use the cached result from Dashboard
            if (typeof window.CartCalculation !== 'undefined' && window.CartCalculation.getGlobalOrdersAndCarts) {
                console.log('üõí Dashboard: Using SINGLE SOURCE OF TRUTH (getGlobalOrdersAndCarts)...');
                console.log('   ‚ö†Ô∏è IGNORING orders parameter - using global memory instead!');
                console.log('   üîÑ Dashboard loads data FIRST - will CALCULATE FRESH (not use old cache!)');
                
                // CRITICAL: Dashboard loads data first, so FORCE fresh calculation
                // Clear any old cache to ensure fresh calculation
                if (window.CartCalculation.clearCartCache) {
                    console.log('   üóëÔ∏è Clearing old cache to force fresh calculation...');
                    const oldCache = window.__zuidplas_cart_cache;
                    if (oldCache) {
                        console.log(`   Old cache had: ${oldCache.cartResult?.total || 'unknown'} carts`);
                    }
                    window.CartCalculation.clearCartCache();
                }
                
                // Verify orders in global memory
                const ordersInMemory = window.__zuidplas_orders_memory || [];
                console.log(`   üìä Orders in global memory: ${ordersInMemory.length}`);
                if (ordersInMemory.length > 0) {
                    console.log(`   First order ID: ${ordersInMemory[0]?.id || 'unknown'}`);
                    console.log(`   Last order ID: ${ordersInMemory[ordersInMemory.length - 1]?.id || 'unknown'}`);
                }
                
                // Now get fresh calculation (will calculate and cache for other pages)
                console.log('   üîÑ Calling getGlobalOrdersAndCarts(forceRefresh=true) - will calculate FRESH...');
                const globalData = window.CartCalculation.getGlobalOrdersAndCarts(true); // FORCE REFRESH!
                const cartResult = globalData.cartResult;
                const totalCarts = cartResult.total || 0;
                const actualOrders = globalData.orders;
                
                // CRITICAL: Use matched orders count, NOT all orders
                const matchedOrdersCount = cartResult.matchedOrdersCount || (cartResult.matchedOrders ? cartResult.matchedOrders.length : actualOrders.length);
                const unmatchedOrdersCount = cartResult.unmatchedOrdersCount || 0;
                
                console.log(`   ‚úÖ Got result: ${totalCarts} carts from ${matchedOrdersCount} matched orders`);
                console.log(`   üì• API returned: ${matchedOrdersCount + unmatchedOrdersCount} total orders`);
                console.log(`   ‚úÖ Matched (Excel clients): ${matchedOrdersCount} orders`);
                console.log(`   ‚ö†Ô∏è Unmatched (DUMP BASKET): ${unmatchedOrdersCount} orders`);
                
                // Update stats with MATCHED orders only (Excel clients)
                document.getElementById('total-orders-count').textContent = matchedOrdersCount;
                
                console.log(`   Orders from global memory: ${actualOrders.length} total`);
                console.log(`   Matched orders (displayed): ${matchedOrdersCount}`);
                console.log(`   Aalsmeer: ${cartResult.byRoute.Aalsmeer || 0} carts`);
                console.log(`   Naaldwijk: ${cartResult.byRoute.Naaldwijk || 0} carts`);
                console.log(`   Rijnsburg: ${cartResult.byRoute.Rijnsburg || 0} carts`);
                console.log(`   TOTAL: ${totalCarts} carts`);
                console.log(`   TRUCKS: ${cartResult.trucks || 0}`);
                
                document.getElementById('total-carts-needed').textContent = totalCarts;
                console.log(`‚úÖ Dashboard updated with SINGLE SOURCE calculation: ${totalCarts} carts (from ${matchedOrdersCount} matched orders)`);
                
                // Store verification data for Orders page comparison
                const currentDate = window.appState?.currentDate || new Date().toISOString().split('T')[0];
                const cacheKey = `cart_verification_${currentDate}`;
                sessionStorage.setItem(cacheKey, JSON.stringify({
                    page: 'Dashboard',
                    total: totalCarts,
                    date: currentDate,
                    byRoute: cartResult.byRoute
                }));
                console.log(`üìù Dashboard result stored for verification (date: ${currentDate}): ${totalCarts} carts`);
                
                // Update route summary cards (use matched orders only)
                const matchedOrdersForDisplay = cartResult.matchedOrders || actualOrders.filter(o => {
                    // Fallback: filter using isKnownClient if matchedOrders not available
                    if (window.RouteMapping && window.RouteMapping.isKnownClient) {
                        const customerName = o.customer_name || o.order?.customer_name || '';
                        const clientCheck = window.RouteMapping.isKnownClient(customerName);
                        return clientCheck.matched;
                    }
                    return true;
                });
                updateRouteSummary(matchedOrdersForDisplay, cartResult);
                
                // Display unmatched orders (DUMP BASKET)
                displayUnmatchedOrdersSection(cartResult.unmatchedOrders || window.unmatchedOrders || [], cartResult);
                
                // Use matched orders for route overview too
                orders = matchedOrdersForDisplay;
            } else {
                console.error('‚ùå getGlobalOrdersAndCarts() NOT AVAILABLE! This should never happen!');
                console.error('   CartCalculation available?', typeof window.CartCalculation !== 'undefined');
                console.error('   getGlobalOrdersAndCarts available?', window.CartCalculation && typeof window.CartCalculation.getGlobalOrdersAndCarts === 'function');
                // Don't use fallback - show error instead
                document.getElementById('total-carts-needed').textContent = 'ERROR';
                // Try to get matched orders count from cartResult if available
                const matchedCount = cartResult?.matchedOrdersCount || (orders ? orders.length : 0);
                document.getElementById('total-orders-count').textContent = matchedCount;
            }
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            // Update routes status
            try {
                // Use orders directly (they already have all data)
                const ordersWithCarts = orders || [];
                console.log('üìä Updating routes status with', ordersWithCarts.length, 'orders');
                const optimizer = initializeOptimizer(ordersWithCarts);
                const routeAnalysis = optimizer.processOrders();
                const routesWithOrders = Object.keys(routeAnalysis).filter(routeKey => {
                    const analysis = routeAnalysis[routeKey];
                    return analysis && analysis.orders && analysis.orders.length > 0;
                }).length;
                document.getElementById('routes-status').textContent = `${routesWithOrders}/3`;
            } catch (error) {
                console.error('Error updating routes status:', error);
                document.getElementById('routes-status').textContent = '0/3';
            }
            
            // Update routes
            updateRouteOverview(orders, options);
            
            // Update optimization suggestions
            updateOptimizationSuggestions(options);
            
            // Update optimization score
            if (options.length > 0) {
                const bestOption = options[0];
                document.getElementById('optimization-score').textContent = bestOption.score + '%';
            }
        }

        // Update route overview
        function updateRouteOverview(orders, options) {
            const container = document.getElementById('route-overview');
            if (!container) return;
            
            container.innerHTML = '';
            
            try {
                // CRITICAL: Use SINGLE SOURCE OF TRUTH for orders and cart calculation
                let ordersWithCarts = [];
                let cartResult = null;
                
                if (window.CartCalculation && window.CartCalculation.getGlobalOrdersAndCarts) {
                    console.log('üõí Route overview: Using SINGLE SOURCE OF TRUTH...');
                    const globalData = window.CartCalculation.getGlobalOrdersAndCarts();
                    ordersWithCarts = globalData.orders;
                    cartResult = globalData.cartResult;
                    console.log('‚úÖ Route overview using SINGLE SOURCE:');
                    console.log(`   Orders: ${ordersWithCarts.length}`);
                    console.log(`   Aalsmeer: ${cartResult.byRoute.Aalsmeer || 0} carts`);
                    console.log(`   Naaldwijk: ${cartResult.byRoute.Naaldwijk || 0} carts`);
                    console.log(`   Rijnsburg: ${cartResult.byRoute.Rijnsburg || 0} carts`);
                } else {
                    // Fallback: Try to get from cache anyway
                    console.warn('‚ö†Ô∏è Route overview: getGlobalOrdersAndCarts() not available, trying fallback...');
                    if (window.CartCalculation && window.CartCalculation.getGlobalOrdersAndCarts) {
                        const globalData = window.CartCalculation.getGlobalOrdersAndCarts();
                        ordersWithCarts = globalData.orders;
                        cartResult = globalData.cartResult;
                        console.log('‚úÖ Route overview: Got data from cache via fallback');
                    } else {
                        console.error('‚ùå Route overview: No cache available!');
                        ordersWithCarts = orders || [];
                        cartResult = { byRoute: { Aalsmeer: 0, Naaldwijk: 0, Rijnsburg: 0 } };
                    }
                }
                
                // Route mapping
                const routeMap = {
                    'rijnsburg': { id: 1, name: 'Rijnsburg', locationId: 36, time: '09:00' },
                    'aalsmeer': { id: 2, name: 'Aalsmeer', locationId: 32, time: '10:00' },
                    'naaldwijk': { id: 3, name: 'Naaldwijk', locationId: 34, time: '11:00' }
                };
                
                Object.keys(routeMap).forEach(routeKey => {
                    const route = routeMap[routeKey];
                    
                    // Get cart count from FUST calculation
                    const routeName = route.name;
                    const carts = cartResult ? (cartResult.byRoute[routeName] || 0) : 0;
                    
                    // Count orders for this route
                    const routeOrders = ordersWithCarts.filter(order => {
                        const orderLocationId = order.delivery_location_id || order.order?.delivery_location_id;
                        return orderLocationId === route.locationId && (order.assembly_amount || 0) > 0;
                    });
                    const orderCount = routeOrders.length;
                    
                    // Calculate status
                    const maxCapacity = 17;
                    const fits = carts <= maxCapacity;
                    const statusClass = fits ? 'success' : 'danger';
                    const statusText = fits ? (typeof i18n !== 'undefined' ? i18n.t('common.ready', 'Ready') : 'Ready') : (typeof i18n !== 'undefined' ? i18n.t('optimization.overflow', 'Overflow') : 'Overflow');
                    const progress = Math.min(100, (carts / maxCapacity) * 100);
                    
                    const card = document.createElement('div');
                    card.className = 'route-card';
                    card.innerHTML = `
                        <div class="route-header">
                            <div class="route-title">Route ${route.id}: ${route.name}</div>
                            <div class="route-time">${route.time}</div>
                        </div>
                        <div class="route-info">
                            <div class="route-info-item">
                                <div class="route-info-label">${typeof i18n !== 'undefined' ? i18n.t('optimization.orders', 'Orders') : 'Orders'}</div>
                                <div class="route-info-value">${orderCount}</div>
                            </div>
                            <div class="route-info-item">
                                <div class="route-info-label">${typeof i18n !== 'undefined' ? i18n.t('optimization.cartsNeeded', 'Carts Needed') : 'Carts Needed'}</div>
                                <div class="route-info-value">${carts} / ${maxCapacity}</div>
                            </div>
                            <div class="route-info-item">
                                <div class="route-info-label">${typeof i18n !== 'undefined' ? i18n.t('optimization.status', 'Status') : 'Status'}</div>
                                <div class="route-info-value"><span class="badge ${statusClass}">${statusText}</span></div>
                            </div>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${progress}%; background: ${progress >= 100 ? 'var(--danger)' : progress >= 80 ? 'var(--warning)' : 'var(--success)'}"></div>
                        </div>
                        ${!fits ? `<div class="info-box warning" style="margin-top: 15px;">${carts - maxCapacity} carts overflow</div>` : ''}
                        <div class="route-actions">
                            <a href="optimization.html" class="btn btn-primary">${typeof i18n !== 'undefined' ? i18n.t('optimization.runOptimization', 'Optimize') : 'Optimize'}</a>
                            <a href="orders.html" class="btn btn-secondary">${typeof i18n !== 'undefined' ? i18n.t('common.viewDetails', 'View Details') : 'View Details'}</a>
                        </div>
                    `;
                    
                    container.appendChild(card);
            });
            } catch (error) {
                console.error('Error updating route overview:', error);
                container.innerHTML = `<div class="info-box danger">Error loading route data: ${error.message}</div>`;
            }
        }

        // Update optimization suggestions
        function updateOptimizationSuggestions(options) {
            const container = document.getElementById('optimization-suggestions');
            if (!container || options.length === 0) {
                // Show default message with translation
                const defaultMsg = typeof i18n !== 'undefined' ? i18n.t('dashboard.clickToSync') : 'Click "Sync Orders from API" to fetch real orders, or "Load Demo Data" to test with sample orders';
                container.innerHTML = `<div style="text-align: center; padding: 40px; color: var(--text-secondary);">${defaultMsg}</div>`;
                return;
            }
            
            const bestOption = options[0];
            const recommendedText = typeof i18n !== 'undefined' ? i18n.t('optimization.recommended', 'Recommended') : 'Recommended';
            const totalCostText = typeof i18n !== 'undefined' ? i18n.t('costs.total', 'Total Cost') : 'Total Cost';
            const feasibilityText = typeof i18n !== 'undefined' ? i18n.t('common.feasibility', 'Feasibility') : 'Feasibility';
            const allFitsText = typeof i18n !== 'undefined' ? i18n.t('optimization.allFits', 'All fits') : 'All fits';
            const overflowText = typeof i18n !== 'undefined' ? i18n.t('optimization.overflow', 'Overflow detected') : 'Overflow detected';
            const scoreText = typeof i18n !== 'undefined' ? i18n.t('optimization.optimizationScore', 'Score') : 'Score';
            
            container.innerHTML = `
                <div style="background: #f0f9ff; padding: 20px; border-radius: 8px; border-left: 4px solid var(--primary); margin-bottom: 20px;">
                    <h3 style="margin-bottom: 15px;">‚≠ê ${recommendedText}: ${bestOption.name}</h3>
                    <p style="margin-bottom: 15px;">${bestOption.description}</p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                        <div><strong>${totalCostText}:</strong> ‚Ç¨${bestOption.cost}</div>
                        <div><strong>${feasibilityText}:</strong> <span class="badge ${bestOption.feasibility.fits ? 'success' : 'danger'}">${bestOption.feasibility.fits ? allFitsText : overflowText}</span></div>
                        <div><strong>${scoreText}:</strong> ${bestOption.score}%</div>
                    </div>
                    ${bestOption.requiresAction ? `<div class="info-box warning">${bestOption.requiresAction}</div>` : ''}
                    <div style="margin-top: 15px;">
                        <a href="optimization.html" class="btn btn-primary">${typeof i18n !== 'undefined' ? i18n.t('optimization.optimizationOptions', 'View All Options') : 'View All Options'}</a>
                    </div>
                </div>
                
                ${options.length > 1 ? `
                <div style="margin-top: 20px;">
                    <h4>${typeof i18n !== 'undefined' ? i18n.t('optimization.alternative', 'Alternative Options') + ':' : 'Alternative Options:'}</h4>
                    <div style="display: grid; gap: 15px; margin-top: 15px;">
                        ${options.slice(1, 4).map(option => `
                            <div style="padding: 15px; background: white; border-radius: 8px; border: 1px solid var(--border);">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <strong>${option.name}</strong>
                                        <div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 5px;">
                                            Cost: ‚Ç¨${option.cost} | Score: ${option.score}%
                                        </div>
                                    </div>
                                    <a href="optimization.html" class="btn btn-secondary" style="padding: 8px 16px;">${typeof i18n !== 'undefined' ? i18n.t('common.view', 'View') : 'View'}</a>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : ''}
            `;
        }

        // Toggle sidebar collapse (desktop)
        function toggleSidebarCollapse() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('collapsed');
            // Save state
            localStorage.setItem('sidebarCollapsed', sidebar.classList.contains('collapsed'));
        }
        
        // Toggle sidebar on mobile
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('open');
        }
        
        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function(event) {
            const sidebar = document.getElementById('sidebar');
            const menuBtn = document.querySelector('.mobile-menu-btn');
            
            if (window.innerWidth <= 768 && 
                sidebar.classList.contains('open') && 
                !sidebar.contains(event.target) && 
                !menuBtn.contains(event.target)) {
                sidebar.classList.remove('open');
            }
        });
        
        // Restore sidebar state on load
        document.addEventListener('DOMContentLoaded', () => {
            const sidebar = document.getElementById('sidebar');
            const isCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
            if (isCollapsed && window.innerWidth > 768) {
                sidebar.classList.add('collapsed');
            }
        });
        
        // Language switcher - GLOBAL and PERSISTENT across ALL pages
        window.setLanguage = function(lang) {
            // CRITICAL: Save to localStorage FIRST - this makes it global
            localStorage.setItem('zuidplas_language', lang);
            
            // Update current page immediately
            if (typeof i18n !== 'undefined') {
                i18n.currentLang = lang;
                i18n.setLanguage(lang);
                i18n.updatePage();
                updateLanguageButtons();
            }
            
            // Dispatch storage event so other pages can detect the change
            window.dispatchEvent(new StorageEvent('storage', {
                key: 'zuidplas_language',
                newValue: lang,
                oldValue: localStorage.getItem('zuidplas_user_language') || localStorage.getItem('zuidplas_language')
            }));
        };
        
        // Language buttons removed - language set at login only
        
        // Check if user needs to login (first time)
        function checkLogin() {
            const loggedIn = localStorage.getItem('zuidplas_logged_in');
            const currentPage = window.location.pathname;
            
            // Don't redirect if already on login page
            if (currentPage.includes('login.html')) {
                return;
            }
            
            // If not logged in and not in demo mode, redirect to login
            if (!loggedIn && !localStorage.getItem('zuidplas_demo_mode')) {
                // Check if user wants to skip login (demo mode)
                const skipLogin = sessionStorage.getItem('skip_login');
                if (!skipLogin) {
                    window.location.href = 'login.html';
                }
            }
        }
        
        // Auto-sync on load (optional)
        document.addEventListener('DOMContentLoaded', async () => {
            // Check login status
            checkLogin();
            
            // Load language from user session (set at login)
            setTimeout(() => {
                if (typeof i18n !== 'undefined') {
                    const userLang = localStorage.getItem('zuidplas_user_language') || 
                                     localStorage.getItem('zuidplas_user_language') || localStorage.getItem('zuidplas_language') || 
                                     'nl';
                    i18n.setLanguage(userLang);
                    i18n.updatePage();
                }
            }, 100);
            
            // Wait a bit for auth to complete
            setTimeout(async () => {
                try {
                    // Check authentication status
                    const token = await authManager.getValidToken();
                    if (token) {
                        console.log('‚úÖ Authentication ready');
                    }
                    
                    // No auto-refresh - user must click refresh button manually
                    console.log('‚úÖ Page loaded - use Refresh Data button to load orders');
                } catch (error) {
                    console.error('Initial load error:', error);
                }
            }, 1500);
        });
    
        // Update route summary cards with order and cart data
        function updateRouteSummary(orders, cartData) {
            if (!orders || !cartData || !window.RouteMapping) {
                console.warn('‚ö†Ô∏è Cannot update route summary - missing data');
                return;
            }
            
            // CRITICAL: Use ONLY matched orders from cartData (Excel clients only)
            // DO NOT use all orders - unmatched orders should NOT appear in route summaries!
            const matchedOrders = cartData.matchedOrders || orders.filter(o => {
                // Fallback: if matchedOrders not available, filter using isKnownClient
                const customerName = o.customer_name || o.order?.customer_name || '';
                const clientCheck = window.RouteMapping.isKnownClient(customerName);
                return clientCheck.matched;
            });
            
            console.log(`üìä updateRouteSummary: Using ${matchedOrders.length} matched orders (Excel clients only)`);
            console.log(`   Total orders passed: ${orders.length}`);
            console.log(`   Matched orders: ${matchedOrders.length}`);
            console.log(`   Unmatched orders (excluded): ${(cartData.unmatchedOrders || []).length}`);
            
            const routes = ['rijnsburg', 'aalsmeer', 'naaldwijk'];
            
            routes.forEach(route => {
                // Count orders for this route (ONLY from matched orders)
                const routeOrders = matchedOrders.filter(o => {
                    // Use route already set by separateOrdersByClientMatch, or getRouteForCustomer
                    const routeFromOrder = o.route || (() => {
                        const customerName = o.customer_name || o.order?.customer_name || '';
                        return window.RouteMapping.getRouteForCustomer(customerName);
                    })();
                    return routeFromOrder === route;
                });
                
                // Count unique customers (ONLY matched customers)
                const uniqueCustomers = new Set(routeOrders.map(o => o.customer_name || o.order?.customer_name || '').filter(Boolean));
                
                // Get carts for this route - check both proper case and lowercase
                const routeName = route.charAt(0).toUpperCase() + route.slice(1);
                let carts = cartData.byRoute[routeName] || cartData.byRoute[route] || 0;
                
                // CRITICAL: If we have orders but no carts, or vice versa, recalculate for this route
                if (routeOrders.length > 0 && carts === 0) {
                    console.warn(`‚ö†Ô∏è Route ${route} has ${routeOrders.length} orders but 0 carts - recalculating...`);
                    // Recalculate carts for this route's orders
                    if (window.CartCalculation && window.CartCalculation.calculateCarts) {
                        const routeCartResult = window.CartCalculation.calculateCarts(routeOrders);
                        carts = routeCartResult.byRoute[routeName] || routeCartResult.byRoute[route] || 0;
                        console.log(`   Recalculated: ${carts} carts for ${routeOrders.length} orders`);
                    }
                }
                
                const trucks = Math.ceil(carts / 17);
                
                // Update UI
                const ordersEl = document.getElementById(`${route}-orders`);
                const customersEl = document.getElementById(`${route}-customers`);
                const cartsEl = document.getElementById(`${route}-carts`);
                const trucksEl = document.getElementById(`${route}-trucks`);
                
                if (ordersEl) ordersEl.textContent = routeOrders.length;
                if (customersEl) customersEl.textContent = uniqueCustomers.size;
                if (cartsEl) cartsEl.textContent = carts;
                if (trucksEl) trucksEl.textContent = trucks;
                
                console.log(`‚úÖ Route ${route}: ${routeOrders.length} orders, ${uniqueCustomers.size} customers, ${carts} carts, ${trucks} trucks`);
            });
            
            console.log('‚úÖ Route summary cards updated');
        }
        
        // View route details - show customer list in scrollable modal
        function viewRouteDetails(route) {
            // CRITICAL: Get cart result to access matched orders
            const cartResult = window.__zuidplas_cart_cache?.cartResult;
            if (!cartResult) {
                alert('No cart data available. Please sync data first.');
                return;
            }
            
            // CRITICAL: Use ONLY matched orders (Excel clients only)
            // DO NOT use all orders - unmatched orders should NOT appear in customer lists!
            const matchedOrders = cartResult.matchedOrders || [];
            
            if (matchedOrders.length === 0) {
                alert('No matched orders loaded. Please sync data first.');
                return;
            }
            
            if (!window.RouteMapping) {
                alert('Route mapping not available.');
                return;
            }
            
            // Filter route orders from MATCHED orders only
            const routeOrders = matchedOrders.filter(o => {
                // Use route already set by separateOrdersByClientMatch, or getRouteForCustomer
                const routeFromOrder = o.route || (() => {
                    const customerName = o.customer_name || o.order?.customer_name || '';
                    return window.RouteMapping.getRouteForCustomer(customerName);
                })();
                return routeFromOrder === route;
            });
            
            console.log(`üìã viewRouteDetails(${route}): Showing ${routeOrders.length} matched orders (Excel clients only)`);
            console.log(`   Total matched orders: ${matchedOrders.length}`);
            console.log(`   Unmatched orders (excluded): ${(cartResult.unmatchedOrders || []).length}`);
            
            const customers = [...new Set(routeOrders.map(o => o.customer_name || o.order?.customer_name || '').filter(Boolean))].sort();
            const departureTime = window.RouteMapping.getDepartureTime(route);
            const cartsEl = document.getElementById(route + '-carts');
            const carts = cartsEl ? cartsEl.textContent : '0';
            
            // Remove any existing modals
            const existingModal = document.querySelector('.customer-list-modal');
            const existingBackdrop = document.querySelector('.modal-backdrop');
            if (existingModal) existingModal.remove();
            if (existingBackdrop) existingBackdrop.remove();
            
            // Create backdrop
            const backdrop = document.createElement('div');
            backdrop.className = 'modal-backdrop';
            
            // Create modal
            const modal = document.createElement('div');
            modal.className = 'customer-list-modal';
            
            // Route name with proper case
            const routeName = route.charAt(0).toUpperCase() + route.slice(1);
            
            // Add content
            modal.innerHTML = `
                <h3>üìç Route: ${routeName} - All Customers</h3>
                <div class="modal-stats">
                    <p><strong>üïê Departure:</strong> ${departureTime}</p>
                    <p><strong>üì¶ Total Orders:</strong> ${routeOrders.length}</p>
                    <p><strong>üöõ Carts Needed:</strong> ${carts}</p>
                    <p><strong>üë• Customers:</strong> ${customers.length}</p>
                </div>
                <div class="customer-list-container">
                    <ol>
                        ${customers.map(customer => `<li>${customer}</li>`).join('')}
                    </ol>
                </div>
                <button class="modal-close-btn" onclick="this.closest('.customer-list-modal').remove(); document.querySelector('.modal-backdrop').remove()">
                    Close
                </button>
            `;
            
            // Add to page
            document.body.appendChild(backdrop);
            document.body.appendChild(modal);
            
            // Close on backdrop click
            backdrop.onclick = (e) => {
                if (e.target === backdrop) {
                    modal.remove();
                    backdrop.remove();
                }
            };
            
            // Close on Escape key
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    modal.remove();
                    backdrop.remove();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
            
            console.log(`‚úÖ Showing ${customers.length} customers for ${route}`);
        }
        
        // Check for mismatched orders - CUSTOMER-BASED analysis
        function checkMismatchedOrders() {
            const ordersInMemory = window.__zuidplas_orders_memory || [];
            if (ordersInMemory.length === 0) {
                alert('No orders loaded. Please sync data first.');
                return;
            }
            
            if (!window.RouteMapping) {
                alert('Route mapping not available.');
                return;
            }
            
            // OFFICIAL CLIENT ROUTES - From Planningstabel 2.0 Excel (COMPLETE LIST)
            const OFFICIAL_EXCEL_ROUTES = {
                'rijnsburg': [
                    'A. Heemskerk',
                    'Aad van Duijn',
                    'Albert Noort',
                    'Bohemen',
                    'C van Klaveren',
                    'C.W de Mooij',
                    'Floral Sourcing',
                    'H. Star',
                    'Hermes Bloemen',
                    'Heyer',
                    'Hoek groothandel',
                    'Hollandirect',
                    'Kariflex',
                    'kooter',
                    'L&M',
                    'Maat & Zoon',
                    'Nagel',
                    'Nic den Heijer',
                    'Jason Walters',
                    'Retail Flower',
                    'Sorisso Verde',
                    'Star T.',
                    'Star v/d Gugten',
                    'V/D PLAS',
                    'V&E Export',
                    'Vianen',
                    'St. Gabriel'
                ],
                'aalsmeer': [
                    'BBI Blomstertorget',
                    'Bloemen Buro',
                    'Bloomenet',
                    'Blooming Direct',
                    'Carsea',
                    'Dijk Flora',
                    'Eurofleur Export',
                    'Flamingo',
                    'Floramondo',
                    'Florette',
                    'Flori Culture',
                    'Floripac',
                    'Floris Holland',
                    'Flora Nova',
                    'Flower Point',
                    'Flower Trade Consult',
                    'FTD',
                    'Hans Visser',
                    'Harrewijn',
                    'Hoekhuis Aalsmeer',
                    'Holex Flower',
                    'Holex Flower BV',
                    'Imex',
                    'KLOK Aalsmeer',
                    'MM Flowers',
                    'Passie Bloemen',
                    'PB Flowerbulbs',
                    'Plantion',
                    'Royal Lemkes',
                    'Stolk Flora',
                    'Superflora',
                    'Verdnatura Holland BV',
                    'Xaverius'
                ],
                'naaldwijk': [
                    'Astrafund',
                    'Bachetle',
                    'Bloom Bouqet',
                    'Bloomer Flowers',
                    'Capitol fl.',
                    'D vd Vijver',
                    'Diva Flowers',
                    'E- Flowers',
                    'Euroveiling',
                    'Flamingo Flowers',
                    'Florca Westland',
                    'Flowering Direct',
                    'Flowerportal',
                    'Flowers All-inn',
                    'FSF',
                    'Goldman',
                    'H. Star',
                    'Kontikiflor',
                    'Kontikiflor Zuidplas',
                    'Kuipers',
                    'Leeuwenburg',
                    'Lion Fleurex',
                    'MD Agro Import',
                    'Optimum Flora Group B.V.',
                    'Premium',
                    'Sjaak vd vijver',
                    'SQ Flora',
                    'v Vliet',
                    'Webshopflower',
                    'West Flora Export',
                    'Westflora',
                    'What If',
                    'Henk Schreuders',
                    'Henk Schreuders Bl.export',
                    'Hoekhuis Naaldwijk',
                    'Hoekhuis Naaldwijk Klondike'
                ]
            };
            
            // Smart suggestion function - matches customer names against Excel data
            function suggestCorrectRoute(customerName, currentRoute) {
                if (!customerName) return 'UNKNOWN';
                
                // Helper function to clean and normalize names for comparison
                const normalize = (name) => {
                    return name
                        .toLowerCase()
                        .replace(/\s+/g, ' ')
                        .replace(/[&\.\-]/g, ' ')
                        .replace(/b\.v\.|bv|b v|b\.v/gi, '')
                        .replace(/\(.*?\)/g, '')
                        .replace(/van der|vander|vd|v d/gi, ' ')
                        .replace(/de |het |van |der |den /gi, ' ')
                        .trim();
                };
                
                const normalizedCustomer = normalize(customerName);
                
                // Search through all Excel routes for a match
                for (const [route, clients] of Object.entries(OFFICIAL_EXCEL_ROUTES)) {
                    for (const excelClient of clients) {
                        const normalizedExcel = normalize(excelClient);
                        
                        // Exact match
                        if (normalizedCustomer === normalizedExcel) {
                            return route;
                        }
                        
                        // Customer name contains Excel name
                        if (normalizedCustomer.includes(normalizedExcel) && normalizedExcel.length > 3) {
                            return route;
                        }
                        
                        // Excel name contains customer name
                        if (normalizedExcel.includes(normalizedCustomer) && normalizedCustomer.length > 3) {
                            return route;
                        }
                        
                        // Word-based matching (at least 2 significant words match)
                        const customerWords = normalizedCustomer.split(' ').filter(w => w.length > 2);
                        const excelWords = normalizedExcel.split(' ').filter(w => w.length > 2);
                        
                        let matches = 0;
                        for (const cw of customerWords) {
                            for (const ew of excelWords) {
                                if (cw === ew || cw.includes(ew) || ew.includes(cw)) {
                                    matches++;
                                    break;
                                }
                            }
                        }
                        
                        if (matches >= 2) {
                            return route;
                        }
                    }
                }
                
                // Not found in Excel
                return 'NOT_IN_EXCEL';
            }
            
            console.log('üîç Analyzing customer route assignments...');
            console.log(`   Total orders: ${ordersInMemory.length}`);
            
            // Track route assignments per customer
            const customerRoutes = {};
            
            ordersInMemory.forEach(order => {
                const customerName = order.customer_name || order.order?.customer_name || '';
                if (!customerName) return;
                
                const orderId = order.id || order.order?.id || 'unknown';
                const locationId = order.delivery_location_id || order.order?.delivery_location_id;
                const assemblyAmount = order.assembly_amount || 0;
                
                if (!customerRoutes[customerName]) {
                    customerRoutes[customerName] = {
                        routes: new Set(),
                        orderCount: 0,
                        orders: [],
                        locationIds: new Set(),
                        wasDefaulted: false
                    };
                }
                
                // Get route from customer mapping
                const route = window.RouteMapping.getRouteForCustomer(customerName);
                customerRoutes[customerName].routes.add(route);
                customerRoutes[customerName].orderCount++;
                customerRoutes[customerName].orders.push({
                    orderId: orderId,
                    route: route,
                    locationId: locationId,
                    assemblyAmount: assemblyAmount
                });
                if (locationId) {
                    customerRoutes[customerName].locationIds.add(locationId);
                }
                
                // Check if defaulted (route is rijnsburg and customer not in mapping)
                if (route === 'rijnsburg') {
                    // Check if customer is actually in rijnsburg list
                    const inMapping = window.RouteMapping.CLIENT_ROUTE_MAPPING.rijnsburg.some(c => {
                        const clean = (n) => n.toLowerCase().trim();
                        return clean(c) === clean(customerName) || 
                               clean(customerName).includes(clean(c)) ||
                               clean(c).includes(clean(customerName));
                    });
                    if (!inMapping) {
                        customerRoutes[customerName].wasDefaulted = true;
                    }
                }
            });
            
            // Find problematic customers
            const problematicCustomers = [];
            const wellMatchedCustomers = [];
            
            Object.entries(customerRoutes).forEach(([customer, data]) => {
                const routesArray = Array.from(data.routes);
                
                if (data.routes.size > 1) {
                    // CRITICAL: Same customer assigned to multiple different routes
                    problematicCustomers.push({
                        customer,
                        routes: routesArray,
                        orderCount: data.orderCount,
                        orders: data.orders,
                        severity: 'CRITICAL',
                        issue: 'Same customer assigned to different routes - BUG!'
                    });
                } else if (data.wasDefaulted) {
                    // WARNING: Customer not found in mapping, defaulted to Rijnsburg
                    const locationIdArray = Array.from(data.locationIds);
                    const LOCATION_ID_TO_ROUTE = { 32: 'aalsmeer', 34: 'naaldwijk', 36: 'rijnsburg' };
                    const locationSuggestedRoute = locationIdArray.length > 0 ? LOCATION_ID_TO_ROUTE[locationIdArray[0]] : null;
                    
                    // Use smart suggestion function to check Excel data
                    const excelSuggestedRoute = suggestCorrectRoute(customer, routesArray[0]);
                    
                    // Prefer Excel suggestion over location_id
                    const finalSuggestedRoute = excelSuggestedRoute !== 'NOT_IN_EXCEL' ? excelSuggestedRoute : locationSuggestedRoute;
                    
                    problematicCustomers.push({
                        customer,
                        routes: routesArray,
                        orderCount: data.orderCount,
                        orders: data.orders,
                        locationIds: locationIdArray,
                        suggestedRoute: finalSuggestedRoute,
                        excelSuggestedRoute: excelSuggestedRoute,
                        severity: 'WARNING',
                        issue: excelSuggestedRoute !== 'NOT_IN_EXCEL' 
                            ? `Customer not found in route mapping, defaulted to ${routesArray[0]}. Excel data suggests: ${excelSuggestedRoute}`
                            : `Customer not found in route mapping or Excel, defaulted to ${routesArray[0]}. Location ID suggests: ${locationSuggestedRoute || 'unknown'}`
                    });
                } else {
                    wellMatchedCustomers.push({
                        customer,
                        route: routesArray[0],
                        orderCount: data.orderCount
                    });
                }
            });
            
            // Generate report
            if (problematicCustomers.length === 0) {
                alert('‚úÖ No mismatched customers found! All customers are correctly assigned.');
                console.log('‚úÖ No mismatched customers - all routes match correctly');
                return;
            }
            
            console.warn(`‚ö†Ô∏è Found ${problematicCustomers.length} problematic customers out of ${Object.keys(customerRoutes).length}`);
            
            // Create report text
            let reportText = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n`;
            reportText += `‚ïë       CUSTOMER ROUTE ASSIGNMENT ANALYSIS REPORT            ‚ïë\n`;
            reportText += `‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n`;
            reportText += `üìÖ Date: ${new Date().toLocaleDateString()}\n`;
            reportText += `üìä Total Customers: ${Object.keys(customerRoutes).length}\n`;
            reportText += `üì¶ Total Orders: ${ordersInMemory.length}\n`;
            reportText += `‚ö†Ô∏è Problematic Customers: ${problematicCustomers.length}\n`;
            reportText += `‚úÖ Well-Matched Customers: ${wellMatchedCustomers.length}\n\n`;
            reportText += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
            
            // Sort by severity
            const critical = problematicCustomers.filter(c => c.severity === 'CRITICAL');
            const warnings = problematicCustomers.filter(c => c.severity === 'WARNING');
            
            if (critical.length > 0) {
                reportText += `üî¥ CRITICAL - Same customer, different routes (${critical.length}):\n`;
                reportText += `${'‚ïê'.repeat(60)}\n\n`;
                critical.forEach((c, i) => {
                    reportText += `${i + 1}. ${c.customer}\n`;
                    reportText += `   Routes: ${c.routes.join(' vs ')}\n`;
                    reportText += `   Orders affected: ${c.orderCount}\n`;
                    reportText += `   Issue: ${c.issue}\n\n`;
                });
                reportText += `\n`;
            }
            
            if (warnings.length > 0) {
                reportText += `üü° WARNING - Not found in route mapping (${warnings.length}):\n`;
                reportText += `${'‚ïê'.repeat(60)}\n\n`;
                warnings.forEach((c, i) => {
                    reportText += `${i + 1}. ${c.customer}\n`;
                    reportText += `   Defaulted to: ${c.routes[0]}\n`;
                    reportText += `   Orders: ${c.orderCount}\n\n`;
                });
                reportText += `\n`;
            }
            
            reportText += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
            reportText += `üìã ACTION REQUIRED:\n\n`;
            
            if (critical.length > 0) {
                reportText += `For CRITICAL issues:\n`;
                reportText += `1. These customers are being assigned to DIFFERENT routes\n`;
                reportText += `2. This is a BUG in the route mapping logic\n`;
                reportText += `3. Fix immediately!\n\n`;
            }
            
            if (warnings.length > 0) {
                reportText += `For WARNING issues:\n`;
                reportText += `These customers were not found in route mapping and were defaulted.\n`;
                reportText += `Add them to js/route-mapping.js with the correct route.\n\n`;
            }
            
            reportText += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
            reportText += `‚úÖ WELL-MATCHED CUSTOMERS (${wellMatchedCustomers.length}):\n\n`;
            reportText += `By Route:\n`;
            reportText += `- Rijnsburg: ${wellMatchedCustomers.filter(c => c.route === 'rijnsburg').length} customers\n`;
            reportText += `- Aalsmeer: ${wellMatchedCustomers.filter(c => c.route === 'aalsmeer').length} customers\n`;
            reportText += `- Naaldwijk: ${wellMatchedCustomers.filter(c => c.route === 'naaldwijk').length} customers\n\n`;
            reportText += `Success Rate: ${((wellMatchedCustomers.length / Object.keys(customerRoutes).length) * 100).toFixed(1)}%\n`;
            
            // Show in modal
            const existingModal = document.querySelector('.mismatch-report-modal');
            const existingBackdrop = document.querySelector('.modal-backdrop');
            if (existingModal) existingModal.remove();
            if (existingBackdrop) existingBackdrop.remove();
            
            const backdrop = document.createElement('div');
            backdrop.className = 'modal-backdrop';
            
            const modal = document.createElement('div');
            modal.className = 'mismatch-report-modal';
            
            modal.innerHTML = `
                <h3>‚ö†Ô∏è Customer Route Analysis Report</h3>
                <div class="modal-stats">
                    <p><strong>Total Customers:</strong> ${Object.keys(customerRoutes).length}</p>
                    <p><strong>Total Orders:</strong> ${ordersInMemory.length}</p>
                    <p><strong>üî¥ Critical Issues:</strong> ${critical.length}</p>
                    <p><strong>üü° Needs Mapping:</strong> ${warnings.length}</p>
                    <p><strong>‚úÖ Well-Matched:</strong> ${wellMatchedCustomers.length}</p>
                </div>
                <div class="mismatch-list-container">
                    ${critical.length > 0 ? `
                        <h4 style="color: #ef4444; margin-top: 20px;">üî¥ CRITICAL - Same Customer, Different Routes</h4>
                        <table class="mismatch-table">
                            <thead>
                                <tr>
                                    <th>Customer</th>
                                    <th>Routes</th>
                                    <th>Orders</th>
                                    <th>Issue</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${critical.map(c => `
                                    <tr>
                                        <td><strong>${c.customer}</strong></td>
                                        <td>${c.routes.join(' vs ')}</td>
                                        <td>${c.orderCount}</td>
                                        <td style="color: #ef4444;">${c.issue}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    ` : ''}
                    ${warnings.length > 0 ? `
                        <h4 style="color: #f59e0b; margin-top: 20px;">üü° WARNING - Not Found in Route Mapping</h4>
                        <table class="mismatch-table">
                            <thead>
                                <tr>
                                    <th>Customer</th>
                                    <th>Defaulted Route</th>
                                    <th>Orders</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${warnings.map(c => `
                                    <tr>
                                        <td><strong>${c.customer}</strong></td>
                                        <td>${c.routes[0]}</td>
                                        <td>${c.orderCount}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    ` : ''}
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="modal-close-btn" onclick="this.closest('.mismatch-report-modal').remove(); document.querySelector('.modal-backdrop').remove()">
                        Close
                    </button>
                    <button class="modal-download-btn" onclick="downloadMismatchReport()">
                        üì• Download Report
                    </button>
                </div>
            `;
            
            document.body.appendChild(backdrop);
            document.body.appendChild(modal);
            
            // Store report for download
            window.mismatchReport = reportText;
            
            backdrop.onclick = (e) => {
                if (e.target === backdrop) {
                    modal.remove();
                    backdrop.remove();
                }
            };
            
            console.log(`‚úÖ Customer route analysis complete: ${problematicCustomers.length} problematic customers`);
        }
        
        // Download mismatch report
        function downloadMismatchReport() {
            if (!window.mismatchReport) {
                alert('No report available. Please run "Check Mismatched Orders" first.');
                return;
            }
            
            try {
                const blob = new Blob([window.mismatchReport], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `mismatched-orders-${new Date().toISOString().split('T')[0]}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                console.log('‚úÖ Mismatch report downloaded');
            } catch (e) {
                console.error('Failed to download report:', e);
                alert('Failed to download report: ' + e.message);
            }
        }
        
        /**
         * Display unmatched orders section (DUMP BASKET)
         */
        function displayUnmatchedOrdersSection(unmatchedOrders, cartResult) {
            const section = document.getElementById('unmatched-section');
            if (!section) return;
            
            if (!unmatchedOrders || unmatchedOrders.length === 0) {
                section.style.display = 'none';
                return;
            }
            
            // Get unique customer names
            const uniqueCustomers = [...new Set(unmatchedOrders.map(o => 
                o.customer_name || o.order?.customer_name || 'Unknown'
            ))].filter(Boolean).sort();
            
            section.style.display = 'block';
            section.innerHTML = `
                <div class="card" style="background: #fff3cd; border: 2px solid #ffc107; padding: 20px; border-radius: 8px;">
                    <h3 style="margin-top: 0; color: #856404;">‚ö†Ô∏è DUMP BASKET - Unmatched Orders</h3>
                    <p style="color: #856404; margin: 10px 0;">
                        These orders are <strong>NOT</strong> in the Excel client list and are <strong>excluded from calculations</strong>.
                    </p>
                    <div style="margin: 15px 0; padding: 10px; background: white; border-radius: 5px;">
                        <strong style="color: #856404;">Total Unmatched Orders: ${unmatchedOrders.length}</strong>
                        <br>
                        <strong style="color: #856404;">Unique Unmatched Customers: ${uniqueCustomers.length}</strong>
                        ${cartResult ? `<br><small style="color: #856404;">Matched Orders (processed): ${cartResult.matchedOrdersCount || 0}</small>` : ''}
                    </div>
                    <button onclick="viewUnmatchedOrdersDetail()" 
                            style="background: #ffc107; color: #856404; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; margin-top: 10px;">
                        üìã View Unmatched Orders List
                    </button>
                </div>
            `;
        }
        
        /**
         * Show detailed modal with unmatched customers
         */
        function viewUnmatchedOrdersDetail() {
            const unmatched = window.unmatchedOrders || [];
            
            if (unmatched.length === 0) {
                alert('No unmatched orders found.');
                return;
            }
            
            // Get unique customer names with order counts
            const customerCounts = {};
            unmatched.forEach(o => {
                const name = o.customer_name || o.order?.customer_name || 'Unknown';
                customerCounts[name] = (customerCounts[name] || 0) + 1;
            });
            
            const uniqueCustomers = Object.entries(customerCounts)
                .sort((a, b) => b[1] - a[1])  // Sort by order count (descending)
                .map(([name, count]) => ({ name, count }));
            
            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 1000; max-height: 80vh; width: 700px; overflow-y: auto;';
            
            modal.innerHTML = `
                <h3 style="margin-top: 0; color: #856404;">‚ö†Ô∏è Unmatched Customers (${uniqueCustomers.length})</h3>
                <p style="color: #666; margin: 10px 0;">
                    These customers need to be added to the Excel sheet (route-mapping.js) to be processed:
                </p>
                <div style="margin: 20px 0; padding: 15px; background: #fff3cd; border-radius: 5px;">
                    <strong>Total Unmatched Orders: ${unmatched.length}</strong>
                </div>
                <div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 5px; padding: 10px;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="background: #f5f5f5; border-bottom: 2px solid #ddd;">
                                <th style="padding: 8px; text-align: left;">#</th>
                                <th style="padding: 8px; text-align: left;">Customer Name</th>
                                <th style="padding: 8px; text-align: right;">Orders</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${uniqueCustomers.map((c, i) => `
                                <tr style="border-bottom: 1px solid #eee;">
                                    <td style="padding: 8px;">${i + 1}</td>
                                    <td style="padding: 8px;"><strong>${c.name}</strong></td>
                                    <td style="padding: 8px; text-align: right;">${c.count}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
                <button onclick="this.closest('div').remove(); document.querySelector('.modal-backdrop').remove()" 
                        style="margin-top: 20px; padding: 10px 30px; background: #ff6b00; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">
                    Close
                </button>
            `;
            
            const backdrop = document.createElement('div');
            backdrop.className = 'modal-backdrop';
            backdrop.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 999;';
            backdrop.onclick = () => { modal.remove(); backdrop.remove(); };
            
            document.body.appendChild(backdrop);
            document.body.appendChild(modal);
        }

        // Make functions globally accessible
        window.updateRouteSummary = updateRouteSummary;
        window.viewRouteDetails = viewRouteDetails;
        window.checkMismatchedOrders = checkMismatchedOrders;
        window.downloadMismatchReport = downloadMismatchReport;
        window.displayUnmatchedOrdersSection = displayUnmatchedOrdersSection;
        window.viewUnmatchedOrdersDetail = viewUnmatchedOrdersDetail;
        
        // Attach event listener to mismatch button
        document.addEventListener('DOMContentLoaded', () => {
            const mismatchBtn = document.getElementById('check-mismatches-btn');
            if (mismatchBtn) {
                mismatchBtn.addEventListener('click', checkMismatchedOrders);
            }
        });
        
        // Logout function - MUST BE GLOBAL
        function handleLogout() {
            const confirmMsg = typeof i18n !== 'undefined' 
                ? i18n.t('common.confirmLogout', 'Are you sure you want to logout?') 
                : 'Are you sure you want to logout?';
            
            if (confirm(confirmMsg)) {
                // Clear all session data
                localStorage.removeItem('zuidplas_logged_in');
                localStorage.removeItem('florinet_token');
                localStorage.removeItem('florinet_token_expiry');
                localStorage.removeItem('florinet_username');
                localStorage.removeItem('florinet_password');
                localStorage.removeItem('zuidplas_demo_mode');
                sessionStorage.clear();
                
                // Redirect to login
                window.location.href = 'login.html';
            }
        }
        
        // Make logout function global - CRITICAL!
        window.handleLogout = handleLogout;

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // DEBUG STATE CHECKER
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function debugCheckState() {
            const globalCount = window.appState?.getOrderCount() || 0;
            
            // Check BOTH old and new localStorage keys
            const oldData = localStorage.getItem('cachedOrders');
            const newData = localStorage.getItem('zuidplas_orders');
            const oldCount = oldData ? JSON.parse(oldData).length : 0;
            const newCount = newData ? JSON.parse(newData).length : 0;
            
            const lastSync = localStorage.getItem('lastSyncDate') || 'Never';
            const currentDate = window.appState?.currentDate || '-';
            
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üêõ DEBUG STATE CHECK (DASHBOARD)');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log(`Global State (memory): ${globalCount} orders`);
            console.log(`OLD LocalStorage (cachedOrders): ${oldCount} orders`);
            console.log(`NEW LocalStorage (zuidplas_orders): ${newCount} orders`);
            console.log(`Last Sync: ${lastSync}`);
            console.log(`Current Date: ${currentDate}`);
            console.log('window.appState:', window.appState);
            console.log('Sample order:', window.appState?.orders?.[0]);
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            alert(`üêõ DASHBOARD STATE\n\nMemory: ${globalCount} orders\nOLD storage: ${oldCount} orders\nNEW storage: ${newCount} orders\nLast sync: ${lastSync}\nDate: ${currentDate}`);
        }
        
        // Update debug panel every 2 seconds
        function updateDebugPanel() {
            const globalCount = window.appState?.getOrderCount() || 0;
            
            // Check BOTH old and new localStorage keys
            const oldData = localStorage.getItem('cachedOrders');
            const newData = localStorage.getItem('zuidplas_orders');
            const localCount = newData ? JSON.parse(newData).length : (oldData ? JSON.parse(oldData).length : 0);
            
            const lastSync = localStorage.getItem('lastSyncDate') || 'Never';
            const currentDate = window.appState?.currentDate || '-';
            
            const globalEl = document.getElementById('debug-global-orders');
            const localEl = document.getElementById('debug-local-orders');
            const syncEl = document.getElementById('debug-last-sync');
            const dateEl = document.getElementById('debug-current-date');
            
            if (globalEl) globalEl.textContent = globalCount;
            if (localEl) localEl.textContent = localCount;
            if (syncEl) syncEl.textContent = lastSync === 'Never' ? 'Never' : new Date(lastSync).toLocaleTimeString();
            if (dateEl) dateEl.textContent = currentDate;
        }
        
        // Make functions global
        window.debugCheckState = debugCheckState;
        window.updateDebugPanel = updateDebugPanel;
        
        // Listen for orders updated event and update debug panel immediately
        window.addEventListener('ordersUpdated', (event) => {
            console.log('üì¢ Debug panel: Orders updated event received:', event.detail.count);
            updateDebugPanel();
        });
        
        // Update debug panel periodically
        setInterval(updateDebugPanel, 2000);
        
        // Initial update
        setTimeout(updateDebugPanel, 1000);

    </script>
    
    <!-- Floating Buttons Overlap Fix -->
    <style>
        /* Hide floating buttons when chat widget is open */
        .floating-buttons.chat-open,
        .action-buttons.chat-open,
        .floating-action-buttons.chat-open {
            display: none !important;
            opacity: 0 !important;
            pointer-events: none !important;
            visibility: hidden !important;
        }
        
        /* Smooth transition for hiding/showing */
        .floating-buttons,
        .action-buttons,
        .floating-action-buttons {
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        /* Common chat widget selectors - ensure chat is above buttons */
        .chat-widget,
        .chat-container,
        .chat-popup,
        .chat-window,
        [class*="chat"],
        [id*="chat"],
        [class*="Chat"],
        [id*="Chat"] {
            z-index: 10000 !important;
        }
        
        /* Common floating button selectors */
        [class*="floating-button"],
        [id*="floating-button"],
        [class*="action-button"],
        [id*="action-button"],
        [class*="chatbot-button"],
        [id*="chatbot-button"],
        [class*="call-button"],
        [id*="call-button"],
        [class*="voice-button"],
        [id*="voice-button"] {
            transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
        }
    </style>
    
    <script>
        /**
         * Fix floating buttons overlapping chat widget
         * Hides floating buttons when chat widget opens
         * Shows floating buttons when chat widget closes
         */
        (function() {
            'use strict';
            
            // Common selectors for floating buttons
            const floatingButtonSelectors = [
                '.floating-buttons',
                '.action-buttons',
                '.floating-action-buttons',
                '[class*="floating-button"]',
                '[id*="floating-button"]',
                '[class*="action-button"]',
                '[id*="action-button"]'
            ];
            
            // Common selectors for chat widget
            const chatWidgetSelectors = [
                '.chat-widget',
                '.chat-container',
                '.chat-popup',
                '.chat-window',
                '[class*="chat"]',
                '[id*="chat"]',
                '[class*="Chat"]',
                '[id*="Chat"]'
            ];
            
            // Find floating buttons container
            function findFloatingButtons() {
                for (const selector of floatingButtonSelectors) {
                    const elements = document.querySelectorAll(selector);
                    if (elements.length > 0) {
                        return Array.from(elements);
                    }
                }
                return [];
            }
            
            // Find chat widget
            function findChatWidget() {
                for (const selector of chatWidgetSelectors) {
                    const element = document.querySelector(selector);
                    if (element && window.getComputedStyle(element).display !== 'none') {
                        return element;
                    }
                }
                return null;
            }
            
            // Hide floating buttons
            function hideFloatingButtons() {
                const buttons = findFloatingButtons();
                buttons.forEach(button => {
                    button.classList.add('chat-open');
                    button.style.display = 'none';
                });
                console.log('‚úÖ Floating buttons hidden (chat widget open)');
            }
            
            // Show floating buttons
            function showFloatingButtons() {
                const buttons = findFloatingButtons();
                buttons.forEach(button => {
                    button.classList.remove('chat-open');
                    button.style.display = '';
                });
                console.log('‚úÖ Floating buttons shown (chat widget closed)');
            }
            
            // Check if chat widget is open
            function isChatOpen() {
                const chatWidget = findChatWidget();
                if (!chatWidget) return false;
                
                const style = window.getComputedStyle(chatWidget);
                return style.display !== 'none' && 
                       style.visibility !== 'hidden' && 
                       style.opacity !== '0';
            }
            
            // Monitor chat widget state
            function monitorChatWidget() {
                let wasOpen = false;
                
                setInterval(() => {
                    const isOpen = isChatOpen();
                    
                    if (isOpen && !wasOpen) {
                        // Chat just opened
                        hideFloatingButtons();
                        wasOpen = true;
                    } else if (!isOpen && wasOpen) {
                        // Chat just closed
                        showFloatingButtons();
                        wasOpen = false;
                    }
                }, 500); // Check every 500ms
            }
            
            // Listen for chat widget events (common patterns)
            function setupEventListeners() {
                // Listen for common chat widget events
                document.addEventListener('click', function(e) {
                    // Check if clicking chat open button
                    if (e.target.matches('[class*="chatbot"], [id*="chatbot"], [class*="chat-open"], [id*="chat-open"]')) {
                        setTimeout(hideFloatingButtons, 100);
                    }
                    
                    // Check if clicking chat close button
                    if (e.target.matches('[class*="chat-close"], [id*="chat-close"], [class*="close"], [id*="close"]')) {
                        setTimeout(showFloatingButtons, 100);
                    }
                });
                
                // Listen for DOM mutations (chat widget might be added dynamically)
                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.addedNodes.length > 0) {
                            // Check if chat widget was added
                            const chatWidget = findChatWidget();
                            if (chatWidget) {
                                hideFloatingButtons();
                            }
                        }
                    });
                });
                
                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });
            }
            
            // Initialize when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', function() {
                    setupEventListeners();
                    monitorChatWidget();
                });
            } else {
                setupEventListeners();
                monitorChatWidget();
            }
            
            // Also check immediately
            setTimeout(function() {
                if (isChatOpen()) {
                    hideFloatingButtons();
                }
            }, 1000);
            
            console.log('‚úÖ Floating buttons overlap fix initialized');
        })();
    </script>
</body>
</html>
